import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigDecimal: { input: any; output: any; }
  Country: { input: any; output: any; }
  Currency: { input: any; output: any; }
  Date: { input: any; output: any; }
  DateTime: { input: any; output: any; }
  Json: { input: any; output: any; }
  KeyReferenceInput: { input: any; output: any; }
  Locale: { input: any; output: any; }
  Long: { input: any; output: any; }
  SearchFilter: { input: any; output: any; }
  SearchSort: { input: any; output: any; }
  Set: { input: any; output: any; }
  Time: { input: any; output: any; }
  YearMonth: { input: any; output: any; }
};

/** API Clients can be used to obtain OAuth 2 access tokens. The secret is only shown once in the response of creating the API Client. */
export type ApiClientWithSecret = {
  __typename?: 'APIClientWithSecret';
  accessTokenValiditySeconds?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  deleteAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  lastUsedAt?: Maybe<Scalars['Date']['output']>;
  name: Scalars['String']['output'];
  refreshTokenValiditySeconds?: Maybe<Scalars['Int']['output']>;
  scope: Scalars['String']['output'];
  secret: Scalars['String']['output'];
};

/** API Clients can be used to obtain OAuth 2 access tokens */
export type ApiClientWithoutSecret = {
  __typename?: 'APIClientWithoutSecret';
  accessTokenValiditySeconds?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  deleteAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  lastUsedAt?: Maybe<Scalars['Date']['output']>;
  name: Scalars['String']['output'];
  refreshTokenValiditySeconds?: Maybe<Scalars['Int']['output']>;
  scope: Scalars['String']['output'];
};

export type ApiClientWithoutSecretQueryResult = {
  __typename?: 'APIClientWithoutSecretQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ApiClientWithoutSecret>;
  total: Scalars['Long']['output'];
};

export type AwsLambdaDestination = ExtensionDestination & {
  __typename?: 'AWSLambdaDestination';
  accessKey: Scalars['String']['output'];
  accessSecret: Scalars['String']['output'];
  arn: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type AwsLambdaDestinationInput = {
  accessKey: Scalars['String']['input'];
  accessSecret: Scalars['String']['input'];
  arn: Scalars['String']['input'];
};

export type AbsoluteDiscountValue = CartDiscountValue & ProductDiscountValue & {
  __typename?: 'AbsoluteDiscountValue';
  money: Array<Money>;
  type: Scalars['String']['output'];
};

export type AbsoluteDiscountValueInput = {
  money: Array<MoneyInput>;
};

export enum ActionType {
  Create = 'Create',
  Update = 'Update'
}

/** A field to access the active cart. */
export type ActiveCartInterface = {
  activeCart?: Maybe<Cart>;
};

export type AddAssociateRolePermission = {
  permission: Permission;
};

export type AddAttributeGroupAttribute = {
  attribute: AttributeReferenceInput;
};

export type AddBusinessUnitAddress = {
  address: AddressInput;
};

export type AddBusinessUnitAssociate = {
  associate: AssociateDraft;
};

export type AddBusinessUnitBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddBusinessUnitShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddBusinessUnitStore = {
  store: ResourceIdentifierInput;
};

export type AddCartCustomLineItem = {
  custom?: InputMaybe<CustomFieldsDraft>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
  name: Array<LocalizedStringItemInputType>;
  priceMode?: InputMaybe<CustomLineItemPriceMode>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  slug: Scalars['String']['input'];
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type AddCartCustomShippingMethod = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveries?: InputMaybe<Array<DeliveryDraft>>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingAddress: AddressInput;
  shippingKey: Scalars['String']['input'];
  shippingMethodName: Scalars['String']['input'];
  shippingRate: ShippingRateDraft;
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type AddCartDiscountCode = {
  code: Scalars['String']['input'];
  validateDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AddCartDiscountStore = {
  store: ResourceIdentifierInput;
};

export type AddCartItemShippingAddress = {
  address: AddressInput;
};

export type AddCartLineItem = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  inventoryMode?: InputMaybe<InventoryMode>;
  key?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  sku?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddCartPayment = {
  payment: ResourceIdentifierInput;
};

export type AddCartShippingMethod = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveries?: InputMaybe<Array<DeliveryDraft>>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingAddress: AddressInput;
  shippingKey: Scalars['String']['input'];
  shippingMethod: ResourceIdentifierInput;
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
};

export type AddCartShoppingList = {
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  shoppingList: ResourceIdentifierInput;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
};

export type AddCategoryAsset = {
  asset: AssetDraftInput;
  position?: InputMaybe<Scalars['Int']['input']>;
};

export type AddChannelRoles = {
  roles: Array<ChannelRole>;
};

export type AddCustomerAddress = {
  address: AddressInput;
};

export type AddCustomerBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddCustomerShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddCustomerStore = {
  store: ResourceIdentifierInput;
};

export type AddInventoryEntryQuantity = {
  quantity: Scalars['Long']['input'];
};

export type AddMyBusinessUnitAddress = {
  address: AddressInput;
};

export type AddMyBusinessUnitBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddMyBusinessUnitShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddMyCartLineItem = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  sku?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddMyPaymentTransaction = {
  transaction: MyTransactionDraft;
};

export type AddOrderDelivery = {
  address?: InputMaybe<AddressInput>;
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  parcels?: InputMaybe<Array<ParcelDataDraftType>>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddOrderEditStagedAction = {
  stagedAction: StagedOrderUpdateAction;
};

export type AddOrderItemShippingAddress = {
  address: AddressInput;
};

export type AddOrderParcelToDelivery = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type AddOrderPayment = {
  payment: ResourceIdentifierInput;
};

export type AddOrderReturnInfo = {
  items: Array<ReturnItemDraftType>;
  returnDate?: InputMaybe<Scalars['DateTime']['input']>;
  returnTrackingId?: InputMaybe<Scalars['String']['input']>;
};

export type AddPaymentInterfaceInteraction = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddPaymentTransaction = {
  transaction: TransactionDraft;
};

export type AddProductAsset = {
  asset: AssetDraftInput;
  position?: InputMaybe<Scalars['Int']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddProductExternalImage = {
  image: ImageInput;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddProductPrice = {
  price: ProductPriceDataInput;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddProductSelectionProduct = {
  product: ResourceIdentifierInput;
  variantSelection?: InputMaybe<ProductVariantSelectionDraft>;
};

export type AddProductToCategory = {
  category: ResourceIdentifierInput;
  orderHint?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AddProductVariant = {
  assets?: InputMaybe<Array<AssetDraftInput>>;
  attributes?: InputMaybe<Array<ProductAttributeInput>>;
  images?: InputMaybe<Array<ImageInput>>;
  key?: InputMaybe<Scalars['String']['input']>;
  prices?: InputMaybe<Array<ProductPriceDataInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AddShippingMethodShippingRate = {
  shippingRate: ShippingRateDraft;
  zone: ResourceIdentifierInput;
};

export type AddShippingMethodZone = {
  zone: ResourceIdentifierInput;
};

export type AddShoppingListLineItem = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddShoppingListTextLineItem = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  name: Array<LocalizedStringItemInputType>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

export type AddStagedOrderCustomLineItem = {
  custom?: InputMaybe<CustomFieldsDraft>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
  name: Array<LocalizedStringItemInputType>;
  priceMode?: InputMaybe<CustomLineItemPriceMode>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
  slug: Scalars['String']['input'];
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type AddStagedOrderCustomLineItemOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderCustomLineItemOutput';
  draft: CustomLineItemDraftOutput;
  type: Scalars['String']['output'];
};

export type AddStagedOrderDelivery = {
  address?: InputMaybe<AddressInput>;
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  parcels?: InputMaybe<Array<ParcelDataDraftType>>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type AddStagedOrderDeliveryOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderDeliveryOutput';
  address?: Maybe<AddressDraft>;
  custom?: Maybe<CustomFieldsCommand>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  items: Array<DeliveryItem>;
  parcels: Array<ParcelData>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type AddStagedOrderDiscountCode = {
  code: Scalars['String']['input'];
  validateDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AddStagedOrderDiscountCodeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderDiscountCodeOutput';
  code: Scalars['String']['output'];
  type: Scalars['String']['output'];
  validateDuplicates: Scalars['Boolean']['output'];
};

export type AddStagedOrderItemShippingAddress = {
  address: AddressInput;
};

export type AddStagedOrderItemShippingAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderItemShippingAddressOutput';
  address: AddressDraft;
  type: Scalars['String']['output'];
};

export type AddStagedOrderLineItem = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  inventoryMode?: InputMaybe<InventoryMode>;
  key?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
  sku?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type AddStagedOrderLineItemOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderLineItemOutput';
  draft: LineItemDraftOutput;
  type: Scalars['String']['output'];
};

export type AddStagedOrderParcelToDelivery = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type AddStagedOrderParcelToDeliveryOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderParcelToDeliveryOutput';
  custom?: Maybe<CustomFieldsCommand>;
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  items: Array<DeliveryItem>;
  measurements?: Maybe<ParcelMeasurements>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  trackingData?: Maybe<TrackingData>;
  type: Scalars['String']['output'];
};

export type AddStagedOrderPayment = {
  payment: ResourceIdentifierInput;
};

export type AddStagedOrderPaymentOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderPaymentOutput';
  paymentResId: ResourceIdentifier;
  type: Scalars['String']['output'];
};

export type AddStagedOrderReturnInfo = {
  items: Array<ReturnItemDraftType>;
  returnDate?: InputMaybe<Scalars['DateTime']['input']>;
  returnTrackingId?: InputMaybe<Scalars['String']['input']>;
};

export type AddStagedOrderReturnInfoOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderReturnInfoOutput';
  items: Array<ReturnItemDraftTypeOutput>;
  returnDate?: Maybe<Scalars['DateTime']['output']>;
  returnTrackingId?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type AddStagedOrderShoppingList = {
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  shoppingList: ResourceIdentifierInput;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
};

export type AddStagedOrderShoppingListOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'AddStagedOrderShoppingListOutput';
  distributionChannelResId?: Maybe<ChannelReferenceIdentifier>;
  shoppingListResId: ResourceIdentifier;
  supplyChannelResId?: Maybe<ChannelReferenceIdentifier>;
  type: Scalars['String']['output'];
};

export type AddStandalonePriceTier = {
  tier: ProductPriceTierInput;
};

export type AddStateRoles = {
  roles: Array<StateRole>;
};

export type AddStoreCountry = {
  country: StoreCountryInput;
};

export type AddStoreDistributionChannel = {
  distributionChannel: ResourceIdentifierInput;
};

export type AddStoreProductSelection = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  productSelection: ResourceIdentifierInput;
};

export type AddStoreSupplyChannel = {
  supplyChannel: ResourceIdentifierInput;
};

export type AddTypeEnumValue = {
  fieldName: Scalars['String']['input'];
  value: EnumValueInput;
};

export type AddTypeFieldDefinition = {
  fieldDefinition: FieldDefinitionInput;
};

export type AddTypeLocalizedEnumValue = {
  fieldName: Scalars['String']['input'];
  value: LocalizedEnumValueInput;
};

export type AddZoneLocation = {
  location: ZoneLocation;
};

/** An address represents a postal address. */
export type Address = {
  __typename?: 'Address';
  additionalAddressInfo?: Maybe<Scalars['String']['output']>;
  additionalStreetInfo?: Maybe<Scalars['String']['output']>;
  apartment?: Maybe<Scalars['String']['output']>;
  building?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  country: Scalars['Country']['output'];
  custom?: Maybe<CustomFieldsType>;
  department?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  fax?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  mobile?: Maybe<Scalars['String']['output']>;
  pOBox?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  salutation?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  streetName?: Maybe<Scalars['String']['output']>;
  streetNumber?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type AddressDraft = {
  __typename?: 'AddressDraft';
  additionalAddressInfo?: Maybe<Scalars['String']['output']>;
  additionalStreetInfo?: Maybe<Scalars['String']['output']>;
  apartment?: Maybe<Scalars['String']['output']>;
  building?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  country: Scalars['Country']['output'];
  custom?: Maybe<CustomFieldsCommand>;
  department?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  fax?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  mobile?: Maybe<Scalars['String']['output']>;
  pOBox?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  postalCode?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  salutation?: Maybe<Scalars['String']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  streetName?: Maybe<Scalars['String']['output']>;
  streetNumber?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type AddressInput = {
  additionalAddressInfo?: InputMaybe<Scalars['String']['input']>;
  additionalStreetInfo?: InputMaybe<Scalars['String']['input']>;
  apartment?: InputMaybe<Scalars['String']['input']>;
  building?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  country: Scalars['Country']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  department?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  fax?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  mobile?: InputMaybe<Scalars['String']['input']>;
  pOBox?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  salutation?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  streetName?: InputMaybe<Scalars['String']['input']>;
  streetNumber?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum AnonymousCartSignInMode {
  /**
   * `LineItem`s of the anonymous cart will be copied to the customer’s active cart that has been modified most recently.
   *
   * The `CartState` of the anonymous cart gets changed to `Merged` while the `CartState` of the customer’s cart remains `Active`.
   *
   * `CustomLineItems` and `CustomFields` of the anonymous cart will not be copied to the customers cart.
   *
   * If a `LineItem` in the anonymous cart matches an existing line item in the customer’s cart (same product ID and variant ID), the maximum quantity of both LineItems is used as the new quantity. In that case `CustomFields` on the `LineItem` of the anonymous cart will not be in the resulting `LineItem`.
   */
  MergeWithExistingCustomerCart = 'MergeWithExistingCustomerCart',
  /** The anonymous cart is used as new active customer cart. No `LineItem`s get merged. */
  UseAsNewActiveCustomerCart = 'UseAsNewActiveCustomerCart'
}

export type Applied = OrderEditResult & {
  __typename?: 'Applied';
  appliedAt: Scalars['DateTime']['output'];
  excerptAfterEdit: OrderExcerpt;
  excerptBeforeEdit: OrderExcerpt;
  type: Scalars['String']['output'];
};

export type ApplyCartDeltaToCustomLineItemShippingDetailsTargets = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  targetsDelta: Array<ShippingTargetDraft>;
};

export type ApplyCartDeltaToLineItemShippingDetailsTargets = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  targetsDelta: Array<ShippingTargetDraft>;
};

export type ApplyStagedChanges = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalFlow = Versioned & {
  __typename?: 'ApprovalFlow';
  approvals: Array<ApprovalFlowApproval>;
  businessUnit: BusinessUnit;
  businessUnitRef: KeyReference;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  order?: Maybe<Order>;
  orderRef: Reference;
  rejection?: Maybe<ApprovalFlowRejection>;
  rules: Array<ApprovalRule>;
  status: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalFlowApproval = {
  __typename?: 'ApprovalFlowApproval';
  approvedAt: Scalars['DateTime']['output'];
  approver: Associate;
};

export type ApprovalFlowApproved = MessagePayload & {
  __typename?: 'ApprovalFlowApproved';
  associateId: Scalars['String']['output'];
  immediatePendingApprovers: Array<RuleApprover>;
  orderId: Scalars['String']['output'];
  pendingApprovers: Array<RuleApprover>;
  roles: Array<RuleApprover>;
  ruleInfos: Array<RuleInfo>;
  type: Scalars['String']['output'];
};

export type ApprovalFlowCompleted = MessagePayload & {
  __typename?: 'ApprovalFlowCompleted';
  orderId: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type ApprovalFlowCreated = MessagePayload & {
  __typename?: 'ApprovalFlowCreated';
  immediatePendingApprovers: Array<RuleApprover>;
  orderId: Scalars['String']['output'];
  pendingApprovers: Array<RuleApprover>;
  ruleInfos: Array<RuleInfo>;
  type: Scalars['String']['output'];
};

export type ApprovalFlowQueryResult = {
  __typename?: 'ApprovalFlowQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ApprovalFlow>;
  total: Scalars['Long']['output'];
};

export type ApprovalFlowRejected = MessagePayload & {
  __typename?: 'ApprovalFlowRejected';
  associateId: Scalars['String']['output'];
  orderId: Scalars['String']['output'];
  reason?: Maybe<Scalars['String']['output']>;
  ruleInfos: Array<RuleInfo>;
  type: Scalars['String']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalFlowRejection = {
  __typename?: 'ApprovalFlowRejection';
  reason?: Maybe<Scalars['String']['output']>;
  rejectedAt: Scalars['DateTime']['output'];
  rejecter: Associate;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalFlowUpdateAction = {
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  approve?: InputMaybe<ApproveApprovalFlow>;
  reject?: InputMaybe<RejectApprovalFlow>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalRule = Versioned & {
  __typename?: 'ApprovalRule';
  approvers: ApproverHierarchy;
  businessUnit: BusinessUnit;
  businessUnitRef: KeyReference;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name: Scalars['String']['output'];
  predicate: Scalars['String']['output'];
  requesters: Array<RuleRequester>;
  status: ApprovalRuleStatus;
  version: Scalars['Long']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalRuleDraft = {
  approvers: ApproverHierarchyDraft;
  description?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  predicate: Scalars['String']['input'];
  requesters: Array<RuleRequesterDraft>;
  status: ApprovalRuleStatus;
};

export type ApprovalRuleQueryResult = {
  __typename?: 'ApprovalRuleQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ApprovalRule>;
  total: Scalars['Long']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export enum ApprovalRuleStatus {
  Active = 'Active',
  Inactive = 'Inactive'
}

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApprovalRuleUpdateAction = {
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  setApprovers?: InputMaybe<SetApprovalRuleApprovers>;
  setDescription?: InputMaybe<SetApprovalRuleDescription>;
  setKey?: InputMaybe<SetApprovalRuleKey>;
  setName?: InputMaybe<SetApprovalRuleName>;
  setPredicate?: InputMaybe<SetApprovalRulePredicate>;
  setRequesters?: InputMaybe<SetApprovalRuleRequesters>;
  setStatus?: InputMaybe<SetApprovalRuleStatus>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproveApprovalFlow = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverConjunction = {
  __typename?: 'ApproverConjunction';
  and: Array<ApproverDisjunction>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverConjunctionDraft = {
  and: Array<ApproverDisjunctionDraft>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverDisjunction = {
  __typename?: 'ApproverDisjunction';
  or: Array<RuleApprover>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverDisjunctionDraft = {
  or: Array<RuleApproverDraft>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverHierarchy = {
  __typename?: 'ApproverHierarchy';
  tiers: Array<ApproverConjunction>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ApproverHierarchyDraft = {
  tiers: Array<ApproverConjunctionDraft>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociate = CartQueryInterface & OrderQueryInterface & QuoteQueryInterface & QuoteRequestQueryInterface & {
  __typename?: 'AsAssociate';
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  approvalFlow?: Maybe<ApprovalFlow>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  approvalFlows: ApprovalFlowQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  approvalRule?: Maybe<ApprovalRule>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  approvalRules: ApprovalRuleQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnit?: Maybe<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnits: BusinessUnitQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  cart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  carts: CartQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  order?: Maybe<Order>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  orders: OrderQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quote?: Maybe<Quote>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quoteRequest?: Maybe<QuoteRequest>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quoteRequests: QuoteRequestQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quotes: QuoteQueryResult;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateApprovalFlowArgs = {
  id: Scalars['String']['input'];
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateApprovalFlowsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateApprovalRuleArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateApprovalRulesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateBusinessUnitArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateBusinessUnitsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateCartArgs = {
  id: Scalars['String']['input'];
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateQuoteRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateQuoteRequestsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateQuotesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AsAssociateArgument = {
  associateId: Scalars['String']['input'];
  businessUnitKey: Scalars['KeyReferenceInput']['input'];
};

export type Asset = {
  __typename?: 'Asset';
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  sources: Array<AssetSource>;
  tags: Array<Scalars['String']['output']>;
};


export type AssetDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type AssetNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type AssetDimensions = {
  __typename?: 'AssetDimensions';
  height: Scalars['Int']['output'];
  width: Scalars['Int']['output'];
};

export type AssetDimensionsInput = {
  height: Scalars['Int']['input'];
  width: Scalars['Int']['input'];
};

export type AssetDraftInput = {
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
  sources?: InputMaybe<Array<AssetSourceInput>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  type?: InputMaybe<ResourceIdentifierInput>;
};

export type AssetSource = {
  __typename?: 'AssetSource';
  contentType?: Maybe<Scalars['String']['output']>;
  dimensions?: Maybe<AssetDimensions>;
  key?: Maybe<Scalars['String']['output']>;
  uri: Scalars['String']['output'];
};

export type AssetSourceInput = {
  contentType?: InputMaybe<Scalars['String']['input']>;
  dimensions?: InputMaybe<AssetDimensionsInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  uri: Scalars['String']['input'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type Associate = {
  __typename?: 'Associate';
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRoleAssignments: Array<AssociateRoleAssignment>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  /** @deprecated Replaced with associateRoleAssignments */
  roles: Array<SimpleAssociateRole>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateDraft = {
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRoleAssignments?: InputMaybe<Array<AssociateRoleAssignmentDraft>>;
  customer: ResourceIdentifierInput;
  /** Deprecated, replaced with associateRoleAssignments */
  roles?: InputMaybe<Array<SimpleAssociateRole>>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum AssociateInheritanceMode {
  Disabled = 'Disabled',
  Enabled = 'Enabled'
}

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateRole = Versioned & {
  __typename?: 'AssociateRole';
  buyerAssignable: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  permissions: Array<Permission>;
  version: Scalars['Long']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateRoleAssignment = {
  __typename?: 'AssociateRoleAssignment';
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRole: AssociateRole;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRoleRef?: Maybe<KeyReference>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  inheritance: AssociateInheritanceMode;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateRoleAssignmentDraft = {
  associateRole: ResourceIdentifierInput;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  inheritance?: InputMaybe<AssociateInheritanceMode>;
};

export type AssociateRoleBuyerAssignableChanged = MessagePayload & {
  __typename?: 'AssociateRoleBuyerAssignableChanged';
  buyerAssignable: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

export type AssociateRoleCreated = MessagePayload & {
  __typename?: 'AssociateRoleCreated';
  associateRole: AssociateRole;
  type: Scalars['String']['output'];
};

export type AssociateRoleDeleted = MessagePayload & {
  __typename?: 'AssociateRoleDeleted';
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateRoleDraft = {
  buyerAssignable: Scalars['Boolean']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<Array<Permission>>;
};

export type AssociateRoleNameSet = MessagePayload & {
  __typename?: 'AssociateRoleNameSet';
  name?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type AssociateRolePermissionAdded = MessagePayload & {
  __typename?: 'AssociateRolePermissionAdded';
  permission: Permission;
  type: Scalars['String']['output'];
};

export type AssociateRolePermissionRemoved = MessagePayload & {
  __typename?: 'AssociateRolePermissionRemoved';
  permission: Permission;
  type: Scalars['String']['output'];
};

export type AssociateRolePermissionsSet = MessagePayload & {
  __typename?: 'AssociateRolePermissionsSet';
  permissions?: Maybe<Array<Permission>>;
  type: Scalars['String']['output'];
};

export type AssociateRoleQueryResult = {
  __typename?: 'AssociateRoleQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<AssociateRole>;
  total: Scalars['Long']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type AssociateRoleUpdateAction = {
  addPermission?: InputMaybe<AddAssociateRolePermission>;
  changeBuyerAssignable?: InputMaybe<ChangeAssociateRoleBuyerAssignable>;
  removePermission?: InputMaybe<RemoveAssociateRolePermission>;
  setCustomField?: InputMaybe<SetAssociateRoleCustomField>;
  setCustomType?: InputMaybe<SetAssociateRoleCustomType>;
  setName?: InputMaybe<SetAssociateRoleName>;
  setPermissions?: InputMaybe<SetAssociateRolePermissions>;
};

export type Attribute = {
  name: Scalars['String']['output'];
};

export enum AttributeConstraint {
  /** A set of attributes, that have this constraint, should have different combinations in each variant */
  CombinationUnique = 'CombinationUnique',
  /** No constraints are applied to the attribute */
  None = 'None',
  /** Attribute value should be the same in all variants */
  SameForAll = 'SameForAll',
  /** Attribute value should be different in each variant */
  Unique = 'Unique'
}

export type AttributeDefinition = {
  __typename?: 'AttributeDefinition';
  attributeConstraint: AttributeConstraint;
  inputHint: TextInputHint;
  inputTip?: Maybe<Scalars['String']['output']>;
  inputTipAllLocales?: Maybe<Array<LocalizedString>>;
  isRequired: Scalars['Boolean']['output'];
  isSearchable: Scalars['Boolean']['output'];
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
  name: Scalars['String']['output'];
  type: AttributeDefinitionType;
};


export type AttributeDefinitionInputTipArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type AttributeDefinitionLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type AttributeDefinitionDraft = {
  attributeConstraint?: InputMaybe<AttributeConstraint>;
  inputHint?: InputMaybe<TextInputHint>;
  inputTip?: InputMaybe<Array<LocalizedStringItemInputType>>;
  isRequired: Scalars['Boolean']['input'];
  isSearchable: Scalars['Boolean']['input'];
  label: Array<LocalizedStringItemInputType>;
  name: Scalars['String']['input'];
  type: AttributeTypeDraft;
};

export type AttributeDefinitionResult = {
  __typename?: 'AttributeDefinitionResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<AttributeDefinition>;
  total: Scalars['Int']['output'];
};

/** (https://docs.commercetools.com/api/projects/productTypes#attributetype)[https://docs.commercetools.com/api/projects/productTypes#attributetype] */
export type AttributeDefinitionType = {
  name: Scalars['String']['output'];
};

export type AttributeGroup = Versioned & {
  __typename?: 'AttributeGroup';
  attributes: Array<AttributeReference>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  version: Scalars['Long']['output'];
};


export type AttributeGroupDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type AttributeGroupNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type AttributeGroupDraft = {
  attributes: Array<AttributeReferenceInput>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
};

export type AttributeGroupLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'AttributeGroupLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type AttributeGroupLimitsProjection = {
  __typename?: 'AttributeGroupLimitsProjection';
  total: AttributeGroupLimitWithCurrent;
};

export type AttributeGroupQueryResult = {
  __typename?: 'AttributeGroupQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<AttributeGroup>;
  total: Scalars['Long']['output'];
};

export type AttributeGroupUpdateAction = {
  addAttribute?: InputMaybe<AddAttributeGroupAttribute>;
  changeName?: InputMaybe<ChangeAttributeGroupName>;
  removeAttribute?: InputMaybe<RemoveAttributeGroupAttribute>;
  setAttributes?: InputMaybe<SetAttributeGroupAttributes>;
  setDescription?: InputMaybe<SetAttributeGroupDescription>;
  setKey?: InputMaybe<SetAttributeGroupKey>;
};

export type AttributeReference = {
  __typename?: 'AttributeReference';
  key: Scalars['String']['output'];
};

export type AttributeReferenceInput = {
  key: Scalars['String']['input'];
};

export type AttributeSetElementTypeDraft = {
  boolean?: InputMaybe<SimpleAttributeTypeDraft>;
  date?: InputMaybe<SimpleAttributeTypeDraft>;
  datetime?: InputMaybe<SimpleAttributeTypeDraft>;
  enum?: InputMaybe<EnumTypeDraft>;
  lenum?: InputMaybe<LocalizableEnumTypeDraft>;
  ltext?: InputMaybe<SimpleAttributeTypeDraft>;
  money?: InputMaybe<SimpleAttributeTypeDraft>;
  number?: InputMaybe<SimpleAttributeTypeDraft>;
  reference?: InputMaybe<ReferenceTypeDefinitionDraft>;
  text?: InputMaybe<SimpleAttributeTypeDraft>;
  time?: InputMaybe<SimpleAttributeTypeDraft>;
};

export type AttributeSetTypeDraft = {
  elementType: AttributeSetElementTypeDraft;
};

export type AttributeTypeDraft = {
  boolean?: InputMaybe<SimpleAttributeTypeDraft>;
  date?: InputMaybe<SimpleAttributeTypeDraft>;
  datetime?: InputMaybe<SimpleAttributeTypeDraft>;
  enum?: InputMaybe<EnumTypeDraft>;
  lenum?: InputMaybe<LocalizableEnumTypeDraft>;
  ltext?: InputMaybe<SimpleAttributeTypeDraft>;
  money?: InputMaybe<SimpleAttributeTypeDraft>;
  number?: InputMaybe<SimpleAttributeTypeDraft>;
  reference?: InputMaybe<ReferenceTypeDefinitionDraft>;
  set?: InputMaybe<AttributeSetTypeDraft>;
  text?: InputMaybe<SimpleAttributeTypeDraft>;
  time?: InputMaybe<SimpleAttributeTypeDraft>;
};

/** AuthenticationMode values. BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum AuthenticationMode {
  ExternalAuth = 'ExternalAuth',
  Password = 'Password'
}

export type AuthorizationHeader = HttpDestinationAuthentication & {
  __typename?: 'AuthorizationHeader';
  headerValue: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type AuthorizationHeaderInput = {
  headerValue: Scalars['String']['input'];
};

export enum AwsAuthenticationMode {
  Credentials = 'Credentials',
  Iam = 'IAM'
}

export type AzureFunctionsAuthentication = HttpDestinationAuthentication & {
  __typename?: 'AzureFunctionsAuthentication';
  key: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type AzureFunctionsAuthenticationInput = {
  key: Scalars['String']['input'];
};

export type AzureServiceBusDestination = Destination & {
  __typename?: 'AzureServiceBusDestination';
  connectionString: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type AzureServiceBusDestinationInput = {
  connectionString: Scalars['String']['input'];
};

export type BaseMoney = {
  centAmount: Scalars['Long']['output'];
  currencyCode: Scalars['Currency']['output'];
  fractionDigits: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type BaseMoneyInput = {
  centPrecision?: InputMaybe<MoneyInput>;
  highPrecision?: InputMaybe<HighPrecisionMoneyInput>;
};

export type BaseSearchKeywordInput = {
  custom?: InputMaybe<CustomSuggestTokenizerInput>;
  whitespace?: InputMaybe<WhitespaceSuggestTokenizerInput>;
};

export type BooleanAttribute = Attribute & {
  __typename?: 'BooleanAttribute';
  name: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type BooleanAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'BooleanAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type BooleanField = CustomField & {
  __typename?: 'BooleanField';
  name: Scalars['String']['output'];
  value: Scalars['Boolean']['output'];
};

export type BooleanType = FieldType & {
  __typename?: 'BooleanType';
  name: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type BusinessUnit = Versioned & {
  __typename?: 'BusinessUnit';
  addresses: Array<Address>;
  /** This field contains the BusinessUnits KeyReferences from the Company to the parent Division of this BusinessUnit in that order. */
  ancestors: Array<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateMode: BusinessUnitAssociateMode;
  associates: Array<Associate>;
  billingAddressIds: Array<Scalars['String']['output']>;
  billingAddresses: Array<Address>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  defaultBillingAddress?: Maybe<Address>;
  defaultBillingAddressId?: Maybe<Scalars['String']['output']>;
  defaultShippingAddress?: Maybe<Address>;
  defaultShippingAddressId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  inheritedAssociates?: Maybe<Array<InheritedAssociate>>;
  /** This field contains the inherited stores from its parentUnit if storeMode is set to FromParent. */
  inheritedStores?: Maybe<Array<InheritedStore>>;
  key: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name: Scalars['String']['output'];
  parentUnit?: Maybe<BusinessUnit>;
  parentUnitRef?: Maybe<KeyReference>;
  shippingAddressIds: Array<Scalars['String']['output']>;
  shippingAddresses: Array<Address>;
  status: BusinessUnitStatus;
  storeMode?: Maybe<Scalars['String']['output']>;
  stores?: Maybe<Array<Store>>;
  storesRef?: Maybe<Array<KeyReference>>;
  topLevelUnit: BusinessUnit;
  topLevelUnitRef?: Maybe<KeyReference>;
  unitType: BusinessUnitType;
  version: Scalars['Long']['output'];
};

export type BusinessUnitAddressAdded = MessagePayload & {
  __typename?: 'BusinessUnitAddressAdded';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitAddressChanged = MessagePayload & {
  __typename?: 'BusinessUnitAddressChanged';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitAddressRemoved = MessagePayload & {
  __typename?: 'BusinessUnitAddressRemoved';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitAssociateAdded = MessagePayload & {
  __typename?: 'BusinessUnitAssociateAdded';
  associate: Associate;
  type: Scalars['String']['output'];
};

export type BusinessUnitAssociateChanged = MessagePayload & {
  __typename?: 'BusinessUnitAssociateChanged';
  associate: Associate;
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum BusinessUnitAssociateMode {
  Explicit = 'Explicit',
  ExplicitAndFromParent = 'ExplicitAndFromParent'
}

export type BusinessUnitAssociateModeChanged = MessagePayload & {
  __typename?: 'BusinessUnitAssociateModeChanged';
  associateMode: BusinessUnitAssociateMode;
  oldAssociateMode?: Maybe<BusinessUnitAssociateMode>;
  type: Scalars['String']['output'];
};

export type BusinessUnitAssociateRemoved = MessagePayload & {
  __typename?: 'BusinessUnitAssociateRemoved';
  associate: Associate;
  type: Scalars['String']['output'];
};

export type BusinessUnitAssociatesSet = MessagePayload & {
  __typename?: 'BusinessUnitAssociatesSet';
  associates: Array<Associate>;
  type: Scalars['String']['output'];
};

export type BusinessUnitBillingAddressAdded = MessagePayload & {
  __typename?: 'BusinessUnitBillingAddressAdded';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitBillingAddressRemoved = MessagePayload & {
  __typename?: 'BusinessUnitBillingAddressRemoved';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitConfiguration = {
  __typename?: 'BusinessUnitConfiguration';
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  myBusinessUnitAssociateRoleOnCreation?: Maybe<AssociateRole>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  myBusinessUnitAssociateRoleOnCreationRef?: Maybe<KeyReference>;
  myBusinessUnitStatusOnCreation: BusinessUnitConfigurationStatus;
};

export enum BusinessUnitConfigurationStatus {
  Active = 'Active',
  Inactive = 'Inactive'
}

export type BusinessUnitContactEmailSet = MessagePayload & {
  __typename?: 'BusinessUnitContactEmailSet';
  contactEmail?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type BusinessUnitCreated = MessagePayload & {
  __typename?: 'BusinessUnitCreated';
  businessUnit: BusinessUnit;
  type: Scalars['String']['output'];
};

export type BusinessUnitDefaultBillingAddressSet = MessagePayload & {
  __typename?: 'BusinessUnitDefaultBillingAddressSet';
  address?: Maybe<Address>;
  type: Scalars['String']['output'];
};

export type BusinessUnitDefaultShippingAddressSet = MessagePayload & {
  __typename?: 'BusinessUnitDefaultShippingAddressSet';
  address?: Maybe<Address>;
  type: Scalars['String']['output'];
};

export type BusinessUnitDeleted = MessagePayload & {
  __typename?: 'BusinessUnitDeleted';
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type BusinessUnitDraft = {
  addresses?: InputMaybe<Array<AddressInput>>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateMode?: InputMaybe<BusinessUnitAssociateMode>;
  associates?: InputMaybe<Array<AssociateDraft>>;
  /** The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses. */
  billingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  /** The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address. */
  defaultBillingAddress?: InputMaybe<Scalars['Int']['input']>;
  /** The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address. */
  defaultShippingAddress?: InputMaybe<Scalars['Int']['input']>;
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  parentUnit?: InputMaybe<ResourceIdentifierInput>;
  /** The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses. */
  shippingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  storeMode?: InputMaybe<Scalars['String']['input']>;
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
  unitType: BusinessUnitType;
};

export type BusinessUnitNameChanged = MessagePayload & {
  __typename?: 'BusinessUnitNameChanged';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type BusinessUnitParentChanged = MessagePayload & {
  __typename?: 'BusinessUnitParentChanged';
  newParentUnit?: Maybe<BusinessUnit>;
  newParentUnitRef?: Maybe<KeyReference>;
  oldParentUnit?: Maybe<BusinessUnit>;
  oldParentUnitRef?: Maybe<KeyReference>;
  type: Scalars['String']['output'];
};

export type BusinessUnitQueryResult = {
  __typename?: 'BusinessUnitQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<BusinessUnit>;
  total: Scalars['Long']['output'];
};

export type BusinessUnitShippingAddressAdded = MessagePayload & {
  __typename?: 'BusinessUnitShippingAddressAdded';
  address: Address;
  type: Scalars['String']['output'];
};

export type BusinessUnitShippingAddressRemoved = MessagePayload & {
  __typename?: 'BusinessUnitShippingAddressRemoved';
  address: Address;
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum BusinessUnitStatus {
  Active = 'Active',
  Inactive = 'Inactive'
}

export type BusinessUnitStatusChanged = MessagePayload & {
  __typename?: 'BusinessUnitStatusChanged';
  status: BusinessUnitStatus;
  type: Scalars['String']['output'];
};

export type BusinessUnitStoreAdded = MessagePayload & {
  __typename?: 'BusinessUnitStoreAdded';
  store: Store;
  storeRef: KeyReference;
  type: Scalars['String']['output'];
};

export type BusinessUnitStoreModeChanged = MessagePayload & {
  __typename?: 'BusinessUnitStoreModeChanged';
  oldStoreMode: Scalars['String']['output'];
  oldStores?: Maybe<Array<Store>>;
  oldStoresRef?: Maybe<Array<KeyReference>>;
  storeMode: Scalars['String']['output'];
  stores?: Maybe<Array<Store>>;
  storesRef?: Maybe<Array<KeyReference>>;
  type: Scalars['String']['output'];
};

export type BusinessUnitStoreRemoved = MessagePayload & {
  __typename?: 'BusinessUnitStoreRemoved';
  store: Store;
  storeRef: KeyReference;
  type: Scalars['String']['output'];
};

export type BusinessUnitStoresSet = MessagePayload & {
  __typename?: 'BusinessUnitStoresSet';
  stores: Array<Store>;
  storesRef: Array<KeyReference>;
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum BusinessUnitType {
  Company = 'Company',
  Division = 'Division'
}

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type BusinessUnitUpdateAction = {
  addAddress?: InputMaybe<AddBusinessUnitAddress>;
  addAssociate?: InputMaybe<AddBusinessUnitAssociate>;
  addBillingAddressId?: InputMaybe<AddBusinessUnitBillingAddressId>;
  addShippingAddressId?: InputMaybe<AddBusinessUnitShippingAddressId>;
  addStore?: InputMaybe<AddBusinessUnitStore>;
  changeAddress?: InputMaybe<ChangeBusinessUnitAddress>;
  changeAssociate?: InputMaybe<ChangeBusinessUnitAssociate>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  changeAssociateMode?: InputMaybe<ChangeBusinessUnitAssociateMode>;
  changeName?: InputMaybe<ChangeBusinessUnitName>;
  changeParentUnit?: InputMaybe<ChangeBusinessUnitParentUnit>;
  changeStatus?: InputMaybe<ChangeBusinessUnitStatus>;
  removeAddress?: InputMaybe<RemoveBusinessUnitAddress>;
  removeAssociate?: InputMaybe<RemoveBusinessUnitAssociate>;
  removeBillingAddressId?: InputMaybe<RemoveBusinessUnitBillingAddressId>;
  removeShippingAddressId?: InputMaybe<RemoveBusinessUnitShippingAddressId>;
  removeStore?: InputMaybe<RemoveBusinessUnitStore>;
  setAddressCustomField?: InputMaybe<SetBusinessUnitAddressCustomField>;
  setAddressCustomType?: InputMaybe<SetBusinessUnitAddressCustomType>;
  setAssociates?: InputMaybe<SetBusinessUnitAssociates>;
  setContactEmail?: InputMaybe<SetBusinessUnitContactEmail>;
  setCustomField?: InputMaybe<SetBusinessUnitCustomField>;
  setCustomType?: InputMaybe<SetBusinessUnitCustomType>;
  setDefaultBillingAddress?: InputMaybe<SetBusinessUnitDefaultBillingAddress>;
  setDefaultShippingAddress?: InputMaybe<SetBusinessUnitDefaultShippingAddress>;
  setStoreMode?: InputMaybe<SetBusinessUnitStoreMode>;
  setStores?: InputMaybe<SetBusinessUnitStores>;
};

export type CancelQuoteRequest = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

/** A shopping cart holds product variants and can be ordered. Each cart either belongs to a registered customer or is an anonymous cart. */
export type Cart = ReferenceExpandable & Versioned & {
  __typename?: 'Cart';
  anonymousId?: Maybe<Scalars['String']['output']>;
  billingAddress?: Maybe<Address>;
  businessUnit?: Maybe<BusinessUnit>;
  businessUnitRef?: Maybe<KeyReference>;
  cartState: CartState;
  country?: Maybe<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customLineItems: Array<CustomLineItem>;
  customer?: Maybe<Customer>;
  customerEmail?: Maybe<Scalars['String']['output']>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  customerId?: Maybe<Scalars['String']['output']>;
  deleteDaysAfterLastModification?: Maybe<Scalars['Int']['output']>;
  directDiscounts: Array<DirectDiscount>;
  discountCodes: Array<DiscountCodeInfo>;
  id: Scalars['String']['output'];
  inventoryMode: InventoryMode;
  itemShippingAddresses: Array<Address>;
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lineItems: Array<LineItem>;
  locale?: Maybe<Scalars['Locale']['output']>;
  origin: CartOrigin;
  paymentInfo?: Maybe<PaymentInfo>;
  refusedGifts: Array<CartDiscount>;
  refusedGiftsRefs: Array<Reference>;
  shipping: Array<Shipping>;
  shippingAddress?: Maybe<Address>;
  shippingCustomFields?: Maybe<CustomFieldsType>;
  shippingInfo?: Maybe<ShippingInfo>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  shippingMode: ShippingMode;
  shippingRateInput?: Maybe<ShippingRateInput>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  taxCalculationMode: TaxCalculationMode;
  taxMode: TaxMode;
  taxRoundingMode: RoundingMode;
  taxedPrice?: Maybe<TaxedPrice>;
  taxedShippingPrice?: Maybe<TaxedPrice>;
  totalLineItemQuantity?: Maybe<Scalars['Long']['output']>;
  totalPrice: Money;
  version: Scalars['Long']['output'];
};


/** A shopping cart holds product variants and can be ordered. Each cart either belongs to a registered customer or is an anonymous cart. */
export type CartLineItemsArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type CartClassificationInput = {
  values: Array<LocalizedEnumValueInput>;
};

export type CartClassificationType = ShippingRateInputType & {
  __typename?: 'CartClassificationType';
  type: Scalars['String']['output'];
  values: Array<ShippingRateInputLocalizedEnumValue>;
};

export type CartCreated = MessagePayload & {
  __typename?: 'CartCreated';
  discountCodesRefs: Array<Reference>;
  lineItemCount: Scalars['Int']['output'];
  totalPrice: Money;
  type: Scalars['String']['output'];
};

/**
 *
 * Cart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.
 *
 * The number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.
 *
 */
export type CartDiscount = ReferenceExpandable & Versioned & {
  __typename?: 'CartDiscount';
  cartPredicate: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  isActive: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  referenceRefs: Array<Reference>;
  requiresDiscountCode: Scalars['Boolean']['output'];
  sortOrder: Scalars['String']['output'];
  stackingMode: StackingMode;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  stores: Array<Store>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  storesRef: Array<KeyReference>;
  target?: Maybe<CartDiscountTarget>;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: CartDiscountValue;
  version: Scalars['Long']['output'];
};


/**
 *
 * Cart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.
 *
 * The number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.
 *
 */
export type CartDiscountDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/**
 *
 * Cart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.
 *
 * The number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.
 *
 */
export type CartDiscountNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CartDiscountDraft = {
  cartPredicate: Scalars['String']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
  requiresDiscountCode?: InputMaybe<Scalars['Boolean']['input']>;
  sortOrder: Scalars['String']['input'];
  stackingMode?: InputMaybe<StackingMode>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
  target?: InputMaybe<CartDiscountTargetInput>;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
  value: CartDiscountValueInput;
};

export type CartDiscountLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'CartDiscountLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type CartDiscountLimitsProjection = {
  __typename?: 'CartDiscountLimitsProjection';
  totalActiveWithoutDiscountCodes: CartDiscountLimitWithCurrent;
};

/** Fields to access cartDiscounts. Includes direct access to a single cartDiscount and searching for cartDiscounts. */
export type CartDiscountQueryInterface = {
  cartDiscount?: Maybe<CartDiscount>;
  cartDiscounts: CartDiscountQueryResult;
};


/** Fields to access cartDiscounts. Includes direct access to a single cartDiscount and searching for cartDiscounts. */
export type CartDiscountQueryInterfaceCartDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access cartDiscounts. Includes direct access to a single cartDiscount and searching for cartDiscounts. */
export type CartDiscountQueryInterfaceCartDiscountsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type CartDiscountQueryResult = {
  __typename?: 'CartDiscountQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<CartDiscount>;
  total: Scalars['Long']['output'];
};

export type CartDiscountTarget = {
  type: Scalars['String']['output'];
};

export type CartDiscountTargetInput = {
  customLineItems?: InputMaybe<CustomLineItemsTargetInput>;
  lineItems?: InputMaybe<LineItemsTargetInput>;
  multiBuyCustomLineItems?: InputMaybe<MultiBuyCustomLineItemsTargetInput>;
  multiBuyLineItems?: InputMaybe<MultiBuyLineItemsTargetInput>;
  shipping?: InputMaybe<ShippingTargetInput>;
};

export type CartDiscountUpdateAction = {
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  addStore?: InputMaybe<AddCartDiscountStore>;
  changeCartPredicate?: InputMaybe<ChangeCartDiscountCartPredicate>;
  changeIsActive?: InputMaybe<ChangeCartDiscountIsActive>;
  changeName?: InputMaybe<ChangeCartDiscountName>;
  changeRequiresDiscountCode?: InputMaybe<ChangeCartDiscountRequiresDiscountCode>;
  changeSortOrder?: InputMaybe<ChangeCartDiscountSortOrder>;
  changeStackingMode?: InputMaybe<ChangeCartDiscountStackingMode>;
  changeTarget?: InputMaybe<ChangeCartDiscountTarget>;
  changeValue?: InputMaybe<ChangeCartDiscountValue>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  removeStore?: InputMaybe<RemoveCartDiscountStore>;
  setCustomField?: InputMaybe<SetCartDiscountCustomField>;
  setCustomType?: InputMaybe<SetCartDiscountCustomType>;
  setDescription?: InputMaybe<SetCartDiscountDescription>;
  setKey?: InputMaybe<SetCartDiscountKey>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  setStores?: InputMaybe<SetCartDiscountStores>;
  setValidFrom?: InputMaybe<SetCartDiscountValidFrom>;
  setValidFromAndUntil?: InputMaybe<SetCartDiscountValidFromAndUntil>;
  setValidUntil?: InputMaybe<SetCartDiscountValidUntil>;
};

export type CartDiscountValue = {
  type: Scalars['String']['output'];
};

export type CartDiscountValueBaseMoneyInput = {
  /** CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision). */
  centAmount?: InputMaybe<Scalars['Long']['input']>;
  centPrecision?: InputMaybe<MoneyInput>;
  /** CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision). */
  currencyCode?: InputMaybe<Scalars['Currency']['input']>;
  highPrecision?: InputMaybe<HighPrecisionMoneyInput>;
};

export type CartDiscountValueInput = {
  absolute?: InputMaybe<AbsoluteDiscountValueInput>;
  fixed?: InputMaybe<FixedPriceDiscountValueInput>;
  giftLineItem?: InputMaybe<GiftLineItemValueInput>;
  relative?: InputMaybe<RelativeDiscountValueInput>;
};

export type CartDraft = {
  anonymousId?: InputMaybe<Scalars['String']['input']>;
  billingAddress?: InputMaybe<AddressInput>;
  businessUnit?: InputMaybe<ResourceIdentifierInput>;
  country?: InputMaybe<Scalars['Country']['input']>;
  currency: Scalars['Currency']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  customLineItems?: InputMaybe<Array<CustomLineItemDraft>>;
  customShipping?: InputMaybe<Array<CustomShippingDraft>>;
  customerEmail?: InputMaybe<Scalars['String']['input']>;
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
  discountCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  externalTaxRateForShippingMethod?: InputMaybe<ExternalTaxRateDraft>;
  inventoryMode?: InputMaybe<InventoryMode>;
  itemShippingAddresses?: InputMaybe<Array<AddressInput>>;
  key?: InputMaybe<Scalars['String']['input']>;
  lineItems?: InputMaybe<Array<LineItemDraft>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  origin?: InputMaybe<CartOrigin>;
  shipping?: InputMaybe<Array<ShippingDraft>>;
  shippingAddress?: InputMaybe<AddressInput>;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
  shippingMode?: InputMaybe<ShippingMode>;
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
  store?: InputMaybe<ResourceIdentifierInput>;
  taxCalculationMode?: InputMaybe<TaxCalculationMode>;
  taxMode?: InputMaybe<TaxMode>;
  taxRoundingMode?: InputMaybe<RoundingMode>;
};

export type CartLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'CartLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type CartLimitsProjection = {
  __typename?: 'CartLimitsProjection';
  total: CartLimitWithCurrent;
};

export enum CartOrigin {
  /** The cart was created by the customer. This is the default value */
  Customer = 'Customer',
  /** The cart was created by the merchant on behalf of the customer */
  Merchant = 'Merchant',
  /** The cart was created by our platform and belongs to a Quote. BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  Quote = 'Quote'
}

/** Fields to access carts. Includes direct access to a single cart and searching for carts. */
export type CartQueryInterface = {
  cart?: Maybe<Cart>;
  carts: CartQueryResult;
};


/** Fields to access carts. Includes direct access to a single cart and searching for carts. */
export type CartQueryInterfaceCartArgs = {
  id: Scalars['String']['input'];
};


/** Fields to access carts. Includes direct access to a single cart and searching for carts. */
export type CartQueryInterfaceCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type CartQueryResult = {
  __typename?: 'CartQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Cart>;
  total: Scalars['Long']['output'];
};

export type CartScoreInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type CartScoreType = ShippingRateInputType & {
  __typename?: 'CartScoreType';
  type: Scalars['String']['output'];
};

export enum CartState {
  /** The cart can be updated and ordered. It is the default state. */
  Active = 'Active',
  /** The cart is frozen. The cart is ready for checkout and a few update actions are not allowed. */
  Frozen = 'Frozen',
  /** Anonymous cart whose content was merged into a customers cart on signin. No further operations on the cart are allowed. */
  Merged = 'Merged',
  /** The cart was ordered. No further operations on the cart are allowed. */
  Ordered = 'Ordered'
}

export type CartUpdateAction = {
  addCustomLineItem?: InputMaybe<AddCartCustomLineItem>;
  addCustomShippingMethod?: InputMaybe<AddCartCustomShippingMethod>;
  addDiscountCode?: InputMaybe<AddCartDiscountCode>;
  addItemShippingAddress?: InputMaybe<AddCartItemShippingAddress>;
  addLineItem?: InputMaybe<AddCartLineItem>;
  addPayment?: InputMaybe<AddCartPayment>;
  addShippingMethod?: InputMaybe<AddCartShippingMethod>;
  addShoppingList?: InputMaybe<AddCartShoppingList>;
  applyDeltaToCustomLineItemShippingDetailsTargets?: InputMaybe<ApplyCartDeltaToCustomLineItemShippingDetailsTargets>;
  applyDeltaToLineItemShippingDetailsTargets?: InputMaybe<ApplyCartDeltaToLineItemShippingDetailsTargets>;
  changeCustomLineItemMoney?: InputMaybe<ChangeCartCustomLineItemMoney>;
  changeCustomLineItemPriceMode?: InputMaybe<ChangeCartCustomLineItemPriceMode>;
  changeCustomLineItemQuantity?: InputMaybe<ChangeCartCustomLineItemQuantity>;
  changeLineItemQuantity?: InputMaybe<ChangeCartLineItemQuantity>;
  changeTaxCalculationMode?: InputMaybe<ChangeCartTaxCalculationMode>;
  changeTaxMode?: InputMaybe<ChangeCartTaxMode>;
  changeTaxRoundingMode?: InputMaybe<ChangeCartTaxRoundingMode>;
  freezeCart?: InputMaybe<FreezeCart>;
  recalculate?: InputMaybe<RecalculateCart>;
  removeCustomLineItem?: InputMaybe<RemoveCartCustomLineItem>;
  removeDiscountCode?: InputMaybe<RemoveCartDiscountCode>;
  removeItemShippingAddress?: InputMaybe<RemoveCartItemShippingAddress>;
  removeLineItem?: InputMaybe<RemoveCartLineItem>;
  removePayment?: InputMaybe<RemoveCartPayment>;
  removeShippingMethod?: InputMaybe<RemoveCartShippingMethod>;
  setAnonymousId?: InputMaybe<SetCartAnonymousId>;
  setBillingAddress?: InputMaybe<SetCartBillingAddress>;
  setBillingAddressCustomField?: InputMaybe<SetCartBillingAddressCustomField>;
  setBillingAddressCustomType?: InputMaybe<SetCartBillingAddressCustomType>;
  setBusinessUnit?: InputMaybe<SetCartBusinessUnit>;
  setCartTotalTax?: InputMaybe<SetCartTotalTax>;
  setCountry?: InputMaybe<SetCartCountry>;
  setCustomField?: InputMaybe<SetCartCustomField>;
  setCustomLineItemCustomField?: InputMaybe<SetCartCustomLineItemCustomField>;
  setCustomLineItemCustomType?: InputMaybe<SetCartCustomLineItemCustomType>;
  setCustomLineItemShippingDetails?: InputMaybe<SetCartCustomLineItemShippingDetails>;
  setCustomLineItemTaxAmount?: InputMaybe<SetCartCustomLineItemTaxAmount>;
  setCustomLineItemTaxRate?: InputMaybe<SetCartCustomLineItemTaxRate>;
  setCustomShippingMethod?: InputMaybe<SetCartCustomShippingMethod>;
  setCustomType?: InputMaybe<SetCartCustomType>;
  setCustomerEmail?: InputMaybe<SetCartCustomerEmail>;
  setCustomerGroup?: InputMaybe<SetCartCustomerGroup>;
  setCustomerId?: InputMaybe<SetCartCustomerId>;
  setDeleteDaysAfterLastModification?: InputMaybe<SetCartDeleteDaysAfterLastModification>;
  setDirectDiscounts?: InputMaybe<SetCartDirectDiscounts>;
  setItemShippingAddressCustomField?: InputMaybe<SetCartItemShippingAddressCustomField>;
  setItemShippingAddressCustomType?: InputMaybe<SetCartItemShippingAddressCustomType>;
  setKey?: InputMaybe<SetCartKey>;
  setLineItemCustomField?: InputMaybe<SetCartLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetCartLineItemCustomType>;
  setLineItemDistributionChannel?: InputMaybe<SetCartLineItemDistributionChannel>;
  setLineItemInventoryMode?: InputMaybe<SetCartLineItemInventoryMode>;
  setLineItemPrice?: InputMaybe<SetCartLineItemPrice>;
  setLineItemShippingDetails?: InputMaybe<SetCartLineItemShippingDetails>;
  setLineItemSupplyChannel?: InputMaybe<SetCartLineItemSupplyChannel>;
  setLineItemTaxAmount?: InputMaybe<SetCartLineItemTaxAmount>;
  setLineItemTaxRate?: InputMaybe<SetCartLineItemTaxRate>;
  setLineItemTotalPrice?: InputMaybe<SetCartLineItemTotalPrice>;
  setLocale?: InputMaybe<SetCartLocale>;
  setShippingAddress?: InputMaybe<SetCartShippingAddress>;
  setShippingAddressCustomField?: InputMaybe<SetCartShippingAddressCustomField>;
  setShippingAddressCustomType?: InputMaybe<SetCartShippingAddressCustomType>;
  setShippingCustomField?: InputMaybe<SetCartShippingCustomField>;
  setShippingCustomType?: InputMaybe<SetCartShippingCustomType>;
  setShippingMethod?: InputMaybe<SetCartShippingMethod>;
  setShippingMethodTaxAmount?: InputMaybe<SetCartShippingMethodTaxAmount>;
  setShippingMethodTaxRate?: InputMaybe<SetCartShippingMethodTaxRate>;
  setShippingRateInput?: InputMaybe<SetCartShippingRateInput>;
  unfreezeCart?: InputMaybe<UnfreezeCart>;
  updateItemShippingAddress?: InputMaybe<UpdateCartItemShippingAddress>;
};

export type CartValueInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type CartValueType = ShippingRateInputType & {
  __typename?: 'CartValueType';
  type: Scalars['String']['output'];
};

export type CartsConfiguration = {
  __typename?: 'CartsConfiguration';
  allowAddingUnpublishedProducts: Scalars['Boolean']['output'];
  countryTaxRateFallbackEnabled: Scalars['Boolean']['output'];
  deleteDaysAfterLastModification?: Maybe<Scalars['Int']['output']>;
};

export type CartsConfigurationInput = {
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
};

export type Category = ReferenceExpandable & Versioned & {
  __typename?: 'Category';
  ancestors: Array<Category>;
  ancestorsRef: Array<Reference>;
  assets: Array<Asset>;
  /** Number of direct child categories. */
  childCount: Scalars['Int']['output'];
  /** Direct child categories. */
  children?: Maybe<Array<Category>>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  externalId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  metaDescription?: Maybe<Scalars['String']['output']>;
  metaDescriptionAllLocales?: Maybe<Array<LocalizedString>>;
  metaKeywords?: Maybe<Scalars['String']['output']>;
  metaKeywordsAllLocales?: Maybe<Array<LocalizedString>>;
  metaTitle?: Maybe<Scalars['String']['output']>;
  metaTitleAllLocales?: Maybe<Array<LocalizedString>>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  orderHint: Scalars['String']['output'];
  parent?: Maybe<Category>;
  parentRef?: Maybe<Reference>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  /** Number of staged products in the category subtree. */
  stagedProductCount: Scalars['Int']['output'];
  version: Scalars['Long']['output'];
};


export type CategoryDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategoryMetaDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategoryMetaKeywordsArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategoryMetaTitleArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategoryNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategorySlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CategoryCreated = MessagePayload & {
  __typename?: 'CategoryCreated';
  category: Category;
  type: Scalars['String']['output'];
};

export type CategoryDraft = {
  assets?: InputMaybe<Array<AssetDraftInput>>;
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  metaDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaKeywords?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaTitle?: InputMaybe<Array<LocalizedStringItemInputType>>;
  name: Array<LocalizedStringItemInputType>;
  orderHint?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<ResourceIdentifierInput>;
  slug: Array<LocalizedStringItemInputType>;
};

export type CategoryLimitsProjection = {
  __typename?: 'CategoryLimitsProjection';
  maxCategories: Limit;
};

export type CategoryOrderHint = {
  __typename?: 'CategoryOrderHint';
  categoryId: Scalars['String']['output'];
  orderHint: Scalars['String']['output'];
};

export type CategoryOrderHintInput = {
  orderHint: Scalars['String']['input'];
  uuid: Scalars['String']['input'];
};

export type CategoryOrderHintProductSearch = {
  __typename?: 'CategoryOrderHintProductSearch';
  categoryId: Scalars['String']['output'];
  orderHint: Scalars['String']['output'];
};

export type CategoryQueryResult = {
  __typename?: 'CategoryQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Category>;
  total: Scalars['Long']['output'];
};

export type CategorySearch = {
  __typename?: 'CategorySearch';
  ancestors: Array<CategorySearch>;
  ancestorsRef: Array<Reference>;
  assets: Array<Asset>;
  childCount: Scalars['Int']['output'];
  /** Direct child categories. */
  children: Array<CategorySearch>;
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  externalId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  orderHint: Scalars['String']['output'];
  parent?: Maybe<CategorySearch>;
  parentRef?: Maybe<Reference>;
  productTypeNames: Array<Scalars['String']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  stagedProductCount: Scalars['Int']['output'];
  version: Scalars['Long']['output'];
};


export type CategorySearchDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategorySearchNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategorySearchSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CategorySearchResult = {
  __typename?: 'CategorySearchResult';
  count: Scalars['Int']['output'];
  offset: Scalars['Int']['output'];
  results: Array<CategorySearch>;
  total: Scalars['Int']['output'];
};

export type CategorySlugChanged = MessagePayload & {
  __typename?: 'CategorySlugChanged';
  oldSlug?: Maybe<Scalars['String']['output']>;
  oldSlugAllLocales?: Maybe<Array<LocalizedString>>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  type: Scalars['String']['output'];
};


export type CategorySlugChangedOldSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type CategorySlugChangedSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CategoryUpdateAction = {
  addAsset?: InputMaybe<AddCategoryAsset>;
  changeAssetName?: InputMaybe<ChangeCategoryAssetName>;
  changeAssetOrder?: InputMaybe<ChangeCategoryAssetOrder>;
  changeName?: InputMaybe<ChangeCategoryName>;
  changeOrderHint?: InputMaybe<ChangeCategoryOrderHint>;
  changeParent?: InputMaybe<ChangeCategoryParent>;
  changeSlug?: InputMaybe<ChangeCategorySlug>;
  removeAsset?: InputMaybe<RemoveCategoryAsset>;
  setAssetCustomField?: InputMaybe<SetCategoryAssetCustomField>;
  setAssetCustomType?: InputMaybe<SetCategoryAssetCustomType>;
  setAssetDescription?: InputMaybe<SetCategoryAssetDescription>;
  setAssetKey?: InputMaybe<SetCategoryAssetKey>;
  setAssetSources?: InputMaybe<SetCategoryAssetSources>;
  setAssetTags?: InputMaybe<SetCategoryAssetTags>;
  setCustomField?: InputMaybe<SetCategoryCustomField>;
  setCustomType?: InputMaybe<SetCategoryCustomType>;
  setDescription?: InputMaybe<SetCategoryDescription>;
  setExternalId?: InputMaybe<SetCategoryExternalId>;
  setKey?: InputMaybe<SetCategoryKey>;
  setMetaDescription?: InputMaybe<SetCategoryMetaDescription>;
  setMetaKeywords?: InputMaybe<SetCategoryMetaKeywords>;
  setMetaTitle?: InputMaybe<SetCategoryMetaTitle>;
};

export type ChangeAssociateRoleBuyerAssignable = {
  buyerAssignable: Scalars['Boolean']['input'];
};

export type ChangeAttributeGroupName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeBusinessUnitAddress = {
  address: AddressInput;
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type ChangeBusinessUnitAssociate = {
  associate: AssociateDraft;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type ChangeBusinessUnitAssociateMode = {
  associateMode: BusinessUnitAssociateMode;
};

export type ChangeBusinessUnitName = {
  name: Scalars['String']['input'];
};

export type ChangeBusinessUnitParentUnit = {
  parentUnit: ResourceIdentifierInput;
};

export type ChangeBusinessUnitStatus = {
  status: BusinessUnitStatus;
};

export type ChangeCartCustomLineItemMoney = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
};

export type ChangeCartCustomLineItemPriceMode = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  mode: CustomLineItemPriceMode;
};

export type ChangeCartCustomLineItemQuantity = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
};

export type ChangeCartDiscountCartPredicate = {
  cartPredicate: Scalars['String']['input'];
};

export type ChangeCartDiscountIsActive = {
  isActive: Scalars['Boolean']['input'];
};

export type ChangeCartDiscountName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeCartDiscountRequiresDiscountCode = {
  requiresDiscountCode: Scalars['Boolean']['input'];
};

export type ChangeCartDiscountSortOrder = {
  sortOrder: Scalars['String']['input'];
};

export type ChangeCartDiscountStackingMode = {
  stackingMode: StackingMode;
};

export type ChangeCartDiscountTarget = {
  target: CartDiscountTargetInput;
};

export type ChangeCartDiscountValue = {
  value: CartDiscountValueInput;
};

export type ChangeCartLineItemQuantity = {
  /** Only valid for the general Carts API. Ignored for the My Carts API. */
  externalPrice?: InputMaybe<BaseMoneyInput>;
  /** Only valid for the general Carts API. Ignored for the My Carts API. */
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
};

export type ChangeCartTaxCalculationMode = {
  taxCalculationMode: TaxCalculationMode;
};

export type ChangeCartTaxMode = {
  taxMode: TaxMode;
};

export type ChangeCartTaxRoundingMode = {
  taxRoundingMode: RoundingMode;
};

export type ChangeCategoryAssetName = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeCategoryAssetOrder = {
  assetOrder: Array<Scalars['String']['input']>;
};

export type ChangeCategoryName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeCategoryOrderHint = {
  orderHint: Scalars['String']['input'];
};

export type ChangeCategoryParent = {
  parent: ResourceIdentifierInput;
};

export type ChangeCategorySlug = {
  slug: Array<LocalizedStringItemInputType>;
};

export type ChangeChannelDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type ChangeChannelKey = {
  key: Scalars['String']['input'];
};

export type ChangeChannelName = {
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type ChangeCustomerAddress = {
  address: AddressInput;
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type ChangeCustomerEmail = {
  email: Scalars['String']['input'];
};

export type ChangeCustomerGroupName = {
  name: Scalars['String']['input'];
};

export type ChangeDiscountCodeCartDiscounts = {
  cartDiscounts: Array<ResourceIdentifierInput>;
};

export type ChangeDiscountCodeGroups = {
  groups: Array<Scalars['String']['input']>;
};

export type ChangeDiscountCodeIsActive = {
  isActive: Scalars['Boolean']['input'];
};

export type ChangeExtensionDestination = {
  destination: ExtensionDestinationInput;
};

export type ChangeExtensionTriggers = {
  triggers: Array<TriggerInput>;
};

export type ChangeInventoryEntryQuantity = {
  quantity: Scalars['Long']['input'];
};

export type ChangeMyBusinessUnitAddress = {
  address: AddressInput;
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type ChangeMyBusinessUnitAssociate = {
  associate: AssociateDraft;
};

export type ChangeMyBusinessUnitName = {
  name: Scalars['String']['input'];
};

export type ChangeMyBusinessUnitParentUnit = {
  parentUnit: ResourceIdentifierInput;
};

export type ChangeMyCartTaxMode = {
  taxMode: TaxMode;
};

export type ChangeMyQuoteMyQuoteState = {
  quoteState: MyQuoteState;
};

export type ChangeOrderPaymentState = {
  paymentState: PaymentState;
};

export type ChangeOrderShipmentState = {
  shipmentState: ShipmentState;
};

export type ChangeOrderState = {
  orderState: OrderState;
};

export type ChangePaymentAmountPlanned = {
  amount: MoneyInput;
};

export type ChangePaymentTransactionInteractionId = {
  interactionId: Scalars['String']['input'];
  transactionId: Scalars['String']['input'];
};

export type ChangePaymentTransactionState = {
  state: TransactionState;
  transactionId: Scalars['String']['input'];
};

export type ChangePaymentTransactionTimestamp = {
  timestamp: Scalars['DateTime']['input'];
  transactionId: Scalars['String']['input'];
};

export type ChangeProductAssetName = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type ChangeProductAssetOrder = {
  assetOrder: Array<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type ChangeProductDiscountIsActive = {
  isActive: Scalars['Boolean']['input'];
};

export type ChangeProductDiscountName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeProductDiscountPredicate = {
  predicate: Scalars['String']['input'];
};

export type ChangeProductDiscountSortOrder = {
  sortOrder: Scalars['String']['input'];
};

export type ChangeProductDiscountValue = {
  value: ProductDiscountValueInput;
};

export type ChangeProductImageLabel = {
  imageUrl: Scalars['String']['input'];
  label?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type ChangeProductMasterVariant = {
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type ChangeProductName = {
  name: Array<LocalizedStringItemInputType>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChangeProductPrice = {
  price: ProductPriceDataInput;
  priceId?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type ChangeProductSelectionName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeProductSlug = {
  slug: Array<LocalizedStringItemInputType>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ChangeProjectSettingsCartsConfiguration = {
  cartsConfiguration: CartsConfigurationInput;
};

export type ChangeProjectSettingsCountries = {
  countries: Array<Scalars['Country']['input']>;
};

export type ChangeProjectSettingsCountryTaxRateFallbackEnabled = {
  countryTaxRateFallbackEnabled: Scalars['Boolean']['input'];
};

export type ChangeProjectSettingsCurrencies = {
  currencies: Array<Scalars['Currency']['input']>;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type ChangeProjectSettingsCustomerSearchStatus = {
  status: CustomerSearchStatus;
};

export type ChangeProjectSettingsLanguages = {
  languages: Array<Scalars['Locale']['input']>;
};

export type ChangeProjectSettingsMessagesConfiguration = {
  messagesConfiguration: MessagesConfigurationDraft;
};

export type ChangeProjectSettingsMessagesEnabled = {
  messagesEnabled: Scalars['Boolean']['input'];
};

export type ChangeProjectSettingsMyBusinessUnitStatusOnCreation = {
  status: BusinessUnitConfigurationStatus;
};

export type ChangeProjectSettingsName = {
  name: Scalars['String']['input'];
};

export type ChangeProjectSettingsOrderSearchStatus = {
  status: OrderSearchStatus;
};

export type ChangeProjectSettingsProductSearchIndexingEnabled = {
  enabled: Scalars['Boolean']['input'];
};

export type ChangeProjectSettingsShoppingListsConfiguration = {
  shoppingListsConfiguration: ShoppingListsConfigurationInput;
};

export type ChangeProjectSettingsStandalonePriceSearchIndexingEnabled = {
  enabled: Scalars['Boolean']['input'];
};

export type ChangeQuoteCustomer = {
  customer: ResourceIdentifierInput;
};

export type ChangeQuoteRequestCustomer = {
  customer: ResourceIdentifierInput;
};

export type ChangeQuoteRequestState = {
  quoteRequestState: QuoteRequestState;
};

export type ChangeQuoteState = {
  quoteState: QuoteState;
};

export type ChangeShippingMethodIsDefault = {
  isDefault: Scalars['Boolean']['input'];
};

export type ChangeShippingMethodName = {
  name: Scalars['String']['input'];
};

export type ChangeShippingMethodTaxCategory = {
  taxCategory: ResourceIdentifierInput;
};

export type ChangeShoppingListLineItemQuantity = {
  lineItemId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type ChangeShoppingListLineItemsOrder = {
  lineItemOrder: Array<Scalars['String']['input']>;
};

export type ChangeShoppingListName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeShoppingListTextLineItemName = {
  name: Array<LocalizedStringItemInputType>;
  textLineItemId: Scalars['String']['input'];
};

export type ChangeShoppingListTextLineItemQuantity = {
  quantity: Scalars['Int']['input'];
  textLineItemId: Scalars['String']['input'];
};

export type ChangeShoppingListTextLineItemsOrder = {
  textLineItemOrder: Array<Scalars['String']['input']>;
};

export type ChangeStagedOrderCustomLineItemMoney = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
};

export type ChangeStagedOrderCustomLineItemMoneyOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderCustomLineItemMoneyOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  money: BaseMoney;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderCustomLineItemQuantity = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
};

export type ChangeStagedOrderCustomLineItemQuantityOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderCustomLineItemQuantityOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderLineItemQuantity = {
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
};

export type ChangeStagedOrderLineItemQuantityOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderLineItemQuantityOutput';
  externalPrice?: Maybe<BaseMoney>;
  externalTotalPrice?: Maybe<ExternalLineItemTotalPrice>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderOrderState = {
  orderState: OrderState;
};

export type ChangeStagedOrderOrderStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderOrderStateOutput';
  orderState: OrderState;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderPaymentState = {
  paymentState: PaymentState;
};

export type ChangeStagedOrderPaymentStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderPaymentStateOutput';
  paymentState: PaymentState;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderShipmentState = {
  shipmentState: ShipmentState;
};

export type ChangeStagedOrderShipmentStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderShipmentStateOutput';
  shipmentState: ShipmentState;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderTaxCalculationMode = {
  taxCalculationMode: TaxCalculationMode;
};

export type ChangeStagedOrderTaxCalculationModeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderTaxCalculationModeOutput';
  taxCalculationMode: TaxCalculationMode;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderTaxMode = {
  taxMode: TaxMode;
};

export type ChangeStagedOrderTaxModeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderTaxModeOutput';
  taxMode: TaxMode;
  type: Scalars['String']['output'];
};

export type ChangeStagedOrderTaxRoundingMode = {
  taxRoundingMode: RoundingMode;
};

export type ChangeStagedOrderTaxRoundingModeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ChangeStagedOrderTaxRoundingModeOutput';
  taxRoundingMode: RoundingMode;
  type: Scalars['String']['output'];
};

export type ChangeStagedQuoteState = {
  stagedQuoteState: StagedQuoteState;
};

export type ChangeStandalonePriceActive = {
  active: Scalars['Boolean']['input'];
};

export type ChangeStandalonePriceValue = {
  /** default is `false` */
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  value: BaseMoneyInput;
};

export type ChangeStateInitial = {
  initial: Scalars['Boolean']['input'];
};

export type ChangeStateKey = {
  key: Scalars['String']['input'];
};

export type ChangeStateType = {
  type: StateType;
};

export type ChangeStoreProductSelectionActive = {
  active: Scalars['Boolean']['input'];
  productSelection: ResourceIdentifierInput;
};

export type ChangeSubscription = {
  __typename?: 'ChangeSubscription';
  resourceTypeId: Scalars['String']['output'];
};

export type ChangeSubscriptionDestination = {
  destination: DestinationInput;
};

export type ChangeSubscriptionInput = {
  resourceTypeId: Scalars['String']['input'];
};

export type ChangeTypeEnumValueLabel = {
  fieldName: Scalars['String']['input'];
  value: EnumValueInput;
};

export type ChangeTypeEnumValueOrder = {
  fieldName: Scalars['String']['input'];
  keys: Array<Scalars['String']['input']>;
};

export type ChangeTypeFieldDefinitionOrder = {
  fieldNames: Array<Scalars['String']['input']>;
};

export type ChangeTypeInputHint = {
  fieldName: Scalars['String']['input'];
  inputHint: TextInputHint;
};

export type ChangeTypeKey = {
  key: Scalars['String']['input'];
};

export type ChangeTypeLabel = {
  fieldName: Scalars['String']['input'];
  label: Array<LocalizedStringItemInputType>;
};

export type ChangeTypeLocalizedEnumValueLabel = {
  fieldName: Scalars['String']['input'];
  value: LocalizedEnumValueInput;
};

export type ChangeTypeLocalizedEnumValueOrder = {
  fieldName: Scalars['String']['input'];
  keys: Array<Scalars['String']['input']>;
};

export type ChangeTypeName = {
  name: Array<LocalizedStringItemInputType>;
};

export type ChangeZoneName = {
  name: Scalars['String']['input'];
};

export type Channel = ReferenceExpandable & ReviewTarget & Versioned & {
  __typename?: 'Channel';
  address?: Maybe<Address>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  geoLocation?: Maybe<Geometry>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  reviewRatingStatistics?: Maybe<ReviewRatingStatistics>;
  roles: Array<ChannelRole>;
  version: Scalars['Long']['output'];
};


export type ChannelDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ChannelNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ChannelDraft = {
  address?: InputMaybe<AddressInput>;
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  geoLocation?: InputMaybe<GeometryInput>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
  roles: Array<ChannelRole>;
};

export type ChannelQueryResult = {
  __typename?: 'ChannelQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Channel>;
  total: Scalars['Long']['output'];
};

export type ChannelReferenceIdentifier = {
  __typename?: 'ChannelReferenceIdentifier';
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  typeId: Scalars['String']['output'];
};

export enum ChannelRole {
  /** Role tells that this channel can be used to track inventory entries.Channels with this role can be treated as warehouses */
  InventorySupply = 'InventorySupply',
  /** Role tells that this channel can be used to track order export activities. */
  OrderExport = 'OrderExport',
  /** Role tells that this channel can be used to track order import activities. */
  OrderImport = 'OrderImport',
  /** This role can be combined with some other roles (e.g. with `InventorySupply`) to represent the fact that this particular channel is the primary/master channel among the channels of the same type. */
  Primary = 'Primary',
  /** Role tells that this channel can be used to expose products to a specific distribution channel. It can be used by the cart to select a product price. */
  ProductDistribution = 'ProductDistribution'
}

export type ChannelUpdateAction = {
  addRoles?: InputMaybe<AddChannelRoles>;
  changeDescription?: InputMaybe<ChangeChannelDescription>;
  changeKey?: InputMaybe<ChangeChannelKey>;
  changeName?: InputMaybe<ChangeChannelName>;
  removeRoles?: InputMaybe<RemoveChannelRoles>;
  setAddress?: InputMaybe<SetChannelAddress>;
  setAddressCustomField?: InputMaybe<SetChannelAddressCustomField>;
  setAddressCustomType?: InputMaybe<SetChannelAddressCustomType>;
  setCustomField?: InputMaybe<SetChannelCustomField>;
  setCustomType?: InputMaybe<SetChannelCustomType>;
  setGeoLocation?: InputMaybe<SetChannelGeoLocation>;
  setRoles?: InputMaybe<SetChannelRoles>;
};

export type ClassificationShippingRateInput = ShippingRateInput & {
  __typename?: 'ClassificationShippingRateInput';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
  type: Scalars['String']['output'];
};


export type ClassificationShippingRateInputLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ClassificationShippingRateInputDraft = {
  key: Scalars['String']['input'];
};

export type ClassificationShippingRateInputDraftOutput = ShippingRateInputDraftOutput & {
  __typename?: 'ClassificationShippingRateInputDraftOutput';
  key: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type CloudEventsSubscriptionsFormat = NotificationFormat & {
  __typename?: 'CloudEventsSubscriptionsFormat';
  cloudEventsVersion: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type CloudEventsSubscriptionsFormatInput = {
  cloudEventsVersion: Scalars['String']['input'];
};

export type CommercetoolsSubscription = Versioned & {
  __typename?: 'CommercetoolsSubscription';
  changes: Array<ChangeSubscription>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  destination: Destination;
  format: NotificationFormat;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  messages: Array<MessageSubscription>;
  status: SubscriptionHealthStatus;
  version: Scalars['Long']['output'];
};

export type CommercetoolsSubscriptionQueryResult = {
  __typename?: 'CommercetoolsSubscriptionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<CommercetoolsSubscription>;
  total: Scalars['Long']['output'];
};

export type ConfluentCloudDestination = Destination & {
  __typename?: 'ConfluentCloudDestination';
  acks: Scalars['String']['output'];
  apiKey: Scalars['String']['output'];
  apiSecret: Scalars['String']['output'];
  bootstrapServer: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  topic: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type ConfluentCloudDestinationInput = {
  acks: Scalars['String']['input'];
  apiKey: Scalars['String']['input'];
  apiSecret: Scalars['String']['input'];
  bootstrapServer: Scalars['String']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
  topic: Scalars['String']['input'];
};

export type CreateApiClient = {
  accessTokenValiditySeconds?: InputMaybe<Scalars['Int']['input']>;
  deleteDaysAfterCreation?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  refreshTokenValiditySeconds?: InputMaybe<Scalars['Int']['input']>;
  scope: Scalars['String']['input'];
};

export type CreateProductSelectionDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<ProductSelectionMode>;
  name: Array<LocalizedStringItemInputType>;
};

export type CreateStandalonePrice = {
  active?: Scalars['Boolean']['input'];
  channel?: InputMaybe<ResourceIdentifierInput>;
  country?: InputMaybe<Scalars['Country']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
  discounted?: InputMaybe<DiscountedProductPriceValueInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  sku: Scalars['String']['input'];
  staged?: InputMaybe<StagedPriceDraft>;
  tiers?: InputMaybe<Array<ProductPriceTierInput>>;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
  value: BaseMoneyInput;
};

export type CreateStore = {
  countries?: InputMaybe<Array<StoreCountryInput>>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannels?: InputMaybe<Array<ResourceIdentifierInput>>;
  key: Scalars['String']['input'];
  languages?: InputMaybe<Array<Scalars['Locale']['input']>>;
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
  productSelections?: InputMaybe<Array<ProductSelectionSettingDraft>>;
  supplyChannels?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type CreateZone = {
  description?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locations?: InputMaybe<Array<ZoneLocation>>;
  name: Scalars['String']['input'];
};

export type CustomField = {
  name: Scalars['String']['output'];
};

/**
 * A key-value pair representing the field name and value of one single custom field.
 *
 * The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.
 *
 *
 * Examples for `value`:
 *
 * * FieldType `String`: `"\"This is a string\""`
 * * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
 * * FieldType `Number`: `"4"`
 * * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
 * * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
 */
export type CustomFieldInput = {
  name: Scalars['String']['input'];
  /**
   * The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.
   *
   *
   * Examples for `value`:
   *
   * * FieldType `String`: `"\"This is a string\""`
   * * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
   * * FieldType `Number`: `"4"`
   * * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
   * * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
   */
  value: Scalars['String']['input'];
};

export type CustomFieldsCommand = {
  __typename?: 'CustomFieldsCommand';
  fields: Scalars['Json']['output'];
  typeId?: Maybe<Scalars['String']['output']>;
  typeKey?: Maybe<Scalars['String']['output']>;
  typeResId?: Maybe<ResourceIdentifier>;
};

export type CustomFieldsDraft = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type CustomFieldsType = {
  __typename?: 'CustomFieldsType';
  /** This field contains non-typed data. */
  customFieldsRaw?: Maybe<Array<RawCustomField>>;
  type?: Maybe<TypeDefinition>;
  typeRef: Reference;
};


export type CustomFieldsTypeCustomFieldsRawArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A custom line item is a generic item that can be added to the cart but is not bound to a product. You can use it for discounts (negative money), vouchers, complex cart rules, additional services or fees. You control the lifecycle of this item. */
export type CustomLineItem = {
  __typename?: 'CustomLineItem';
  custom?: Maybe<CustomFieldsType>;
  discountedPricePerQuantity: Array<DiscountedLineItemPriceForQuantity>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  money: BaseMoney;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  perMethodTaxRate: Array<MethodTaxRate>;
  priceMode: CustomLineItemPriceMode;
  quantity: Scalars['Long']['output'];
  shippingDetails?: Maybe<ItemShippingDetails>;
  slug: Scalars['String']['output'];
  state: Array<ItemState>;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  taxRate?: Maybe<TaxRate>;
  taxedPrice?: Maybe<TaxedItemPrice>;
  taxedPricePortions: Array<MethodTaxedPrice>;
  totalPrice: Money;
};


/** A custom line item is a generic item that can be added to the cart but is not bound to a product. You can use it for discounts (negative money), vouchers, complex cart rules, additional services or fees. You control the lifecycle of this item. */
export type CustomLineItemNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CustomLineItemDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
  name: Array<LocalizedStringItemInputType>;
  priceMode?: InputMaybe<CustomLineItemPriceMode>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  slug: Scalars['String']['input'];
  taxCategory?: InputMaybe<ReferenceInput>;
};

export type CustomLineItemDraftOutput = {
  __typename?: 'CustomLineItemDraftOutput';
  custom?: Maybe<CustomFieldsCommand>;
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  key?: Maybe<Scalars['String']['output']>;
  money: BaseMoney;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  priceMode: CustomLineItemPriceMode;
  quantity?: Maybe<Scalars['Long']['output']>;
  shippingDetails?: Maybe<ItemShippingDetailsDraftOutput>;
  slug: Scalars['String']['output'];
  taxCategoryResId?: Maybe<ResourceIdentifier>;
};


export type CustomLineItemDraftOutputNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type CustomLineItemImportDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  money: BaseMoneyInput;
  name: Array<LocalizedStringItemInputType>;
  priceMode?: InputMaybe<CustomLineItemPriceMode>;
  quantity: Scalars['Long']['input'];
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  slug: Scalars['String']['input'];
  state?: InputMaybe<Array<ItemStateDraftType>>;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
  taxRate?: InputMaybe<TaxRateInput>;
};

export enum CustomLineItemPriceMode {
  /** Cart discounts are deactivated for the custom line items with this price mode. */
  External = 'External',
  /** This is the default mode. */
  Standard = 'Standard'
}

export type CustomLineItemReturnItem = ReturnItem & {
  __typename?: 'CustomLineItemReturnItem';
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  customLineItemId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  paymentState: ReturnPaymentState;
  quantity: Scalars['Long']['output'];
  shipmentState: ReturnShipmentState;
  type: Scalars['String']['output'];
};

export type CustomLineItemStateTransition = MessagePayload & OrderMessagePayload & {
  __typename?: 'CustomLineItemStateTransition';
  customLineItemId: Scalars['String']['output'];
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  fromState?: Maybe<State>;
  fromStateRef: Reference;
  quantity: Scalars['Long']['output'];
  toState?: Maybe<State>;
  toStateRef: Reference;
  transitionDate: Scalars['DateTime']['output'];
  type: Scalars['String']['output'];
};

export type CustomLineItemsTarget = CartDiscountTarget & {
  __typename?: 'CustomLineItemsTarget';
  predicate: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type CustomLineItemsTargetInput = {
  predicate: Scalars['String']['input'];
};

export type CustomObject = ReferenceExpandable & Versioned & {
  __typename?: 'CustomObject';
  container: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  value: Scalars['Json']['output'];
  version: Scalars['Long']['output'];
};

/**
 * An input object used to create a new, or update an existing Custom Object.
 *
 * The value should be passed in a form of escaped JSON.
 *
 * Example for `value` field:
 *
 * ```
 * "{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
 * ```
 */
export type CustomObjectDraft = {
  container: Scalars['String']['input'];
  key: Scalars['String']['input'];
  /**
   * The value should be passed in a form of escaped JSON.
   *
   * Example for `value` field:
   *
   * ```
   * "{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
   * ```
   */
  value: Scalars['String']['input'];
  version?: InputMaybe<Scalars['Long']['input']>;
};

export type CustomObjectLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'CustomObjectLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type CustomObjectLimitsProjection = {
  __typename?: 'CustomObjectLimitsProjection';
  total: CustomObjectLimitWithCurrent;
};

export type CustomObjectQueryResult = {
  __typename?: 'CustomObjectQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<CustomObject>;
  total: Scalars['Long']['output'];
};

export type CustomShippingDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveries?: InputMaybe<Array<DeliveryDraft>>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  key: Scalars['String']['input'];
  shippingAddress: AddressInput;
  shippingMethodName: Scalars['String']['input'];
  shippingRate: ShippingRateDraft;
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
  taxCategory?: InputMaybe<ReferenceInput>;
};

export type CustomSuggestTokenizer = SuggestTokenizer & {
  __typename?: 'CustomSuggestTokenizer';
  inputs: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type CustomSuggestTokenizerInput = {
  inputs: Array<Scalars['String']['input']>;
};

export type CustomSuggestTokenizerProductSearch = SuggestTokenizerProductSearch & {
  __typename?: 'CustomSuggestTokenizerProductSearch';
  inputs: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type Customer = ReferenceExpandable & Versioned & {
  __typename?: 'Customer';
  MMU_TEST?: Maybe<Scalars['String']['output']>;
  addresses: Array<Address>;
  authenticationMode?: Maybe<AuthenticationMode>;
  billingAddressIds: Array<Scalars['String']['output']>;
  billingAddresses: Array<Address>;
  companyName?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  customerNumber?: Maybe<Scalars['String']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  defaultBillingAddress?: Maybe<Address>;
  defaultBillingAddressId?: Maybe<Scalars['String']['output']>;
  defaultShippingAddress?: Maybe<Address>;
  defaultShippingAddressId?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  isEmailVerified: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lastName?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['Locale']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  salutation?: Maybe<Scalars['String']['output']>;
  shippingAddressIds: Array<Scalars['String']['output']>;
  shippingAddresses: Array<Address>;
  stores: Array<Store>;
  storesRef: Array<KeyReference>;
  title?: Maybe<Scalars['String']['output']>;
  vatId?: Maybe<Scalars['String']['output']>;
  version: Scalars['Long']['output'];
};

/** A field to access a customer's active cart. */
export type CustomerActiveCartInterface = {
  customerActiveCart?: Maybe<Cart>;
};


/** A field to access a customer's active cart. */
export type CustomerActiveCartInterfaceCustomerActiveCartArgs = {
  customerId: Scalars['String']['input'];
};

export type CustomerAddressAdded = MessagePayload & {
  __typename?: 'CustomerAddressAdded';
  address: Address;
  type: Scalars['String']['output'];
};

export type CustomerAddressChanged = MessagePayload & {
  __typename?: 'CustomerAddressChanged';
  address: Address;
  type: Scalars['String']['output'];
};

export type CustomerAddressRemoved = MessagePayload & {
  __typename?: 'CustomerAddressRemoved';
  address: Address;
  type: Scalars['String']['output'];
};

export type CustomerCompanyNameSet = MessagePayload & {
  __typename?: 'CustomerCompanyNameSet';
  companyName?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type CustomerCreated = MessagePayload & {
  __typename?: 'CustomerCreated';
  customer: Customer;
  type: Scalars['String']['output'];
};

export type CustomerDateOfBirthSet = MessagePayload & {
  __typename?: 'CustomerDateOfBirthSet';
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  type: Scalars['String']['output'];
};

export type CustomerDeleted = MessagePayload & {
  __typename?: 'CustomerDeleted';
  type: Scalars['String']['output'];
};

export type CustomerEmailChanged = MessagePayload & {
  __typename?: 'CustomerEmailChanged';
  email: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type CustomerEmailToken = Versioned & {
  __typename?: 'CustomerEmailToken';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  customerId: Scalars['String']['output'];
  expiresAt: Scalars['DateTime']['output'];
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  value: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};

export type CustomerEmailTokenCreated = MessagePayload & {
  __typename?: 'CustomerEmailTokenCreated';
  customerId: Scalars['String']['output'];
  expiresAt: Scalars['DateTime']['output'];
  type: Scalars['String']['output'];
};

export type CustomerEmailVerified = MessagePayload & {
  __typename?: 'CustomerEmailVerified';
  type: Scalars['String']['output'];
};

export type CustomerFirstNameSet = MessagePayload & {
  __typename?: 'CustomerFirstNameSet';
  firstName?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

/** A customer can be a member in a customer group (e.g. reseller, gold member). A customer group can be used in price calculations with special prices being assigned to certain customer groups. */
export type CustomerGroup = ReferenceExpandable & Versioned & {
  __typename?: 'CustomerGroup';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};

export type CustomerGroupDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  groupName: Scalars['String']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerGroupLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'CustomerGroupLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type CustomerGroupLimitsProjection = {
  __typename?: 'CustomerGroupLimitsProjection';
  total: CustomerGroupLimitWithCurrent;
};

export type CustomerGroupQueryResult = {
  __typename?: 'CustomerGroupQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<CustomerGroup>;
  total: Scalars['Long']['output'];
};

export type CustomerGroupReferenceIdentifier = {
  __typename?: 'CustomerGroupReferenceIdentifier';
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  typeId: Scalars['String']['output'];
};

export type CustomerGroupSet = MessagePayload & {
  __typename?: 'CustomerGroupSet';
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type CustomerGroupUpdateAction = {
  changeName?: InputMaybe<ChangeCustomerGroupName>;
  setCustomField?: InputMaybe<SetCustomerGroupCustomField>;
  setCustomType?: InputMaybe<SetCustomerGroupCustomType>;
  setKey?: InputMaybe<SetCustomerGroupKey>;
};

export type CustomerLastNameSet = MessagePayload & {
  __typename?: 'CustomerLastNameSet';
  lastName?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type CustomerLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'CustomerLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type CustomerLimitsProjection = {
  __typename?: 'CustomerLimitsProjection';
  total: CustomerLimitWithCurrent;
};

export type CustomerPasswordToken = Versioned & {
  __typename?: 'CustomerPasswordToken';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  customerId: Scalars['String']['output'];
  expiresAt: Scalars['DateTime']['output'];
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  value: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};

export type CustomerPasswordTokenCreated = MessagePayload & {
  __typename?: 'CustomerPasswordTokenCreated';
  customerId: Scalars['String']['output'];
  expiresAt: Scalars['DateTime']['output'];
  type: Scalars['String']['output'];
};

export type CustomerPasswordUpdated = MessagePayload & {
  __typename?: 'CustomerPasswordUpdated';
  reset: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

/** Fields to access customer accounts. Includes direct access to a single customer and searching for customers. */
export type CustomerQueryInterface = {
  customer?: Maybe<Customer>;
  customers: CustomerQueryResult;
};


/** Fields to access customer accounts. Includes direct access to a single customer and searching for customers. */
export type CustomerQueryInterfaceCustomerArgs = {
  emailToken?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  passwordToken?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access customer accounts. Includes direct access to a single customer and searching for customers. */
export type CustomerQueryInterfaceCustomersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerQueryResult = {
  __typename?: 'CustomerQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Customer>;
  total: Scalars['Long']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type CustomerSearchConfiguration = {
  __typename?: 'CustomerSearchConfiguration';
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  status: CustomerSearchStatus;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export enum CustomerSearchStatus {
  Activated = 'Activated',
  Deactivated = 'Deactivated'
}

export type CustomerSignInDraft = {
  anonymousCart?: InputMaybe<ResourceIdentifierInput>;
  /** This field will be deprecated in favour of anonymousCart.id. */
  anonymousCartId?: InputMaybe<Scalars['String']['input']>;
  anonymousCartSignInMode?: InputMaybe<AnonymousCartSignInMode>;
  anonymousId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  updateProductData?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerSignInResult = {
  __typename?: 'CustomerSignInResult';
  cart?: Maybe<Cart>;
  customer: Customer;
};

export type CustomerSignMeInDraft = {
  activeCartSignInMode?: InputMaybe<AnonymousCartSignInMode>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  updateProductData?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerSignMeUpDraft = {
  addresses?: InputMaybe<Array<AddressInput>>;
  /** The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses. */
  billingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address. */
  defaultBillingAddress?: InputMaybe<Scalars['Int']['input']>;
  /** The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address. */
  defaultShippingAddress?: InputMaybe<Scalars['Int']['input']>;
  email: Scalars['String']['input'];
  firstName?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  salutation?: InputMaybe<Scalars['String']['input']>;
  /** The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses. */
  shippingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
  vatId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerSignUpDraft = {
  addresses?: InputMaybe<Array<AddressInput>>;
  anonymousCart?: InputMaybe<ResourceIdentifierInput>;
  /** This field will be deprecated in favour of anonymousCart.id. */
  anonymousCartId?: InputMaybe<Scalars['String']['input']>;
  anonymousId?: InputMaybe<Scalars['String']['input']>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  authenticationMode?: InputMaybe<AuthenticationMode>;
  /** The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses. */
  billingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
  customerNumber?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address. */
  defaultBillingAddress?: InputMaybe<Scalars['Int']['input']>;
  /** The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address. */
  defaultShippingAddress?: InputMaybe<Scalars['Int']['input']>;
  email: Scalars['String']['input'];
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  salutation?: InputMaybe<Scalars['String']['input']>;
  /** The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses. */
  shippingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
  vatId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerTitleSet = MessagePayload & {
  __typename?: 'CustomerTitleSet';
  title?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type CustomerUpdateAction = {
  addAddress?: InputMaybe<AddCustomerAddress>;
  addBillingAddressId?: InputMaybe<AddCustomerBillingAddressId>;
  addShippingAddressId?: InputMaybe<AddCustomerShippingAddressId>;
  addStore?: InputMaybe<AddCustomerStore>;
  changeAddress?: InputMaybe<ChangeCustomerAddress>;
  changeEmail?: InputMaybe<ChangeCustomerEmail>;
  removeAddress?: InputMaybe<RemoveCustomerAddress>;
  removeBillingAddressId?: InputMaybe<RemoveCustomerBillingAddressId>;
  removeShippingAddressId?: InputMaybe<RemoveCustomerShippingAddressId>;
  removeStore?: InputMaybe<RemoveCustomerStore>;
  setAddressCustomField?: InputMaybe<SetCustomerAddressCustomField>;
  setAddressCustomType?: InputMaybe<SetCustomerAddressCustomType>;
  setAuthenticationMode?: InputMaybe<SetCustomerAuthenticationMode>;
  setCompanyName?: InputMaybe<SetCustomerCompanyName>;
  setCustomField?: InputMaybe<SetCustomerCustomField>;
  setCustomType?: InputMaybe<SetCustomerCustomType>;
  setCustomerGroup?: InputMaybe<SetCustomerGroup>;
  setCustomerNumber?: InputMaybe<SetCustomerNumber>;
  setDateOfBirth?: InputMaybe<SetCustomerDateOfBirth>;
  setDefaultBillingAddress?: InputMaybe<SetCustomerDefaultBillingAddress>;
  setDefaultShippingAddress?: InputMaybe<SetCustomerDefaultShippingAddress>;
  setExternalId?: InputMaybe<SetCustomerExternalId>;
  setFirstName?: InputMaybe<SetCustomerFirstName>;
  setKey?: InputMaybe<SetCustomerKey>;
  setLastName?: InputMaybe<SetCustomerLastName>;
  setLocale?: InputMaybe<SetCustomerLocale>;
  setMiddleName?: InputMaybe<SetCustomerMiddleName>;
  setSalutation?: InputMaybe<SetCustomerSalutation>;
  setStores?: InputMaybe<SetCustomerStores>;
  setTitle?: InputMaybe<SetCustomerTitle>;
  setVatId?: InputMaybe<SetCustomerVatId>;
};

export type DateAttribute = Attribute & {
  __typename?: 'DateAttribute';
  name: Scalars['String']['output'];
  value: Scalars['Date']['output'];
};

export type DateAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'DateAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type DateField = CustomField & {
  __typename?: 'DateField';
  name: Scalars['String']['output'];
  value: Scalars['Date']['output'];
};

export type DateTimeAttribute = Attribute & {
  __typename?: 'DateTimeAttribute';
  name: Scalars['String']['output'];
  value: Scalars['DateTime']['output'];
};

export type DateTimeAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'DateTimeAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type DateTimeField = CustomField & {
  __typename?: 'DateTimeField';
  name: Scalars['String']['output'];
  value: Scalars['DateTime']['output'];
};

export type DateTimeType = FieldType & {
  __typename?: 'DateTimeType';
  name: Scalars['String']['output'];
};

export type DateType = FieldType & {
  __typename?: 'DateType';
  name: Scalars['String']['output'];
};

export type Delivery = {
  __typename?: 'Delivery';
  address?: Maybe<Address>;
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  items: Array<DeliveryItem>;
  key?: Maybe<Scalars['String']['output']>;
  parcels: Array<Parcel>;
};

export type DeliveryAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'DeliveryAdded';
  delivery: Delivery;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type DeliveryAddressSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'DeliveryAddressSet';
  address?: Maybe<Address>;
  deliveryId: Scalars['String']['output'];
  oldAddress?: Maybe<Address>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type DeliveryDraft = {
  address?: InputMaybe<AddressInput>;
  custom?: InputMaybe<CustomFieldsDraft>;
  items: Array<DeliveryItemDraftType>;
  key?: InputMaybe<Scalars['String']['input']>;
  parcels: Array<ParcelDraft>;
};

export type DeliveryItem = {
  __typename?: 'DeliveryItem';
  id: Scalars['String']['output'];
  quantity: Scalars['Long']['output'];
};

export type DeliveryItemDraftType = {
  id: Scalars['String']['input'];
  quantity: Scalars['Long']['input'];
};

export type DeliveryItemsUpdated = MessagePayload & OrderMessagePayload & {
  __typename?: 'DeliveryItemsUpdated';
  deliveryId: Scalars['String']['output'];
  items: Array<DeliveryItem>;
  oldItems: Array<DeliveryItem>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type DeliveryRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'DeliveryRemoved';
  delivery: Delivery;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type Destination = {
  type: Scalars['String']['output'];
};

export type DestinationInput = {
  AzureServiceBus?: InputMaybe<AzureServiceBusDestinationInput>;
  ConfluentCloud?: InputMaybe<ConfluentCloudDestinationInput>;
  EventBridge?: InputMaybe<EventBridgeDestinationInput>;
  EventGrid?: InputMaybe<EventGridDestinationInput>;
  GoogleCloudPubSub?: InputMaybe<GoogleCloudPubSubDestinationInput>;
  SNS?: InputMaybe<SnsDestinationInput>;
  SQS?: InputMaybe<SqsDestinationInput>;
};

export type Dimensions = {
  __typename?: 'Dimensions';
  height: Scalars['Int']['output'];
  width: Scalars['Int']['output'];
};

export type DimensionsInput = {
  height: Scalars['Int']['input'];
  width: Scalars['Int']['input'];
};

export type DimensionsProductSearch = {
  __typename?: 'DimensionsProductSearch';
  height: Scalars['Int']['output'];
  width: Scalars['Int']['output'];
};

export type DirectDiscount = {
  __typename?: 'DirectDiscount';
  id: Scalars['String']['output'];
  target?: Maybe<CartDiscountTarget>;
  value: CartDiscountValue;
};

export type DirectDiscountDraft = {
  target?: InputMaybe<CartDiscountTargetInput>;
  value: CartDiscountValueInput;
};

export type DirectDiscountDraftOutput = {
  __typename?: 'DirectDiscountDraftOutput';
  target?: Maybe<CartDiscountTarget>;
  value: CartDiscountValue;
};

/** With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart. */
export type DiscountCode = ReferenceExpandable & Versioned & {
  __typename?: 'DiscountCode';
  /** How many times this discount code was applied (only applications that were part of a successful checkout are considered) */
  applicationCount: Scalars['Long']['output'];
  applicationVersion?: Maybe<Scalars['Long']['output']>;
  cartDiscountRefs: Array<Reference>;
  cartDiscounts: Array<CartDiscount>;
  cartPredicate?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  groups: Array<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  isActive: Scalars['Boolean']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  maxApplications?: Maybe<Scalars['Long']['output']>;
  maxApplicationsPerCustomer?: Maybe<Scalars['Long']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  referenceRefs: Array<Reference>;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['Long']['output'];
};


/** With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart. */
export type DiscountCodeDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/** With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart. */
export type DiscountCodeNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type DiscountCodeDraft = {
  cartDiscounts: Array<ReferenceInput>;
  cartPredicate?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  groups?: InputMaybe<Array<Scalars['String']['input']>>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  maxApplications?: InputMaybe<Scalars['Long']['input']>;
  maxApplicationsPerCustomer?: InputMaybe<Scalars['Long']['input']>;
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type DiscountCodeInfo = {
  __typename?: 'DiscountCodeInfo';
  discountCode?: Maybe<DiscountCode>;
  discountCodeRef: Reference;
  state?: Maybe<DiscountCodeState>;
};

export type DiscountCodeQueryResult = {
  __typename?: 'DiscountCodeQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<DiscountCode>;
  total: Scalars['Long']['output'];
};

export enum DiscountCodeState {
  /** The discount code is active and none of the discounts were applied because the discount application was stopped by one discount that has the StackingMode of StopAfterThisDiscount defined */
  ApplicationStoppedByPreviousDiscount = 'ApplicationStoppedByPreviousDiscount',
  /** The discount code is active and it contains at least one active and valid CartDiscount. But its cart predicate does not match the cart or none of the contained active discount’s cart predicates match the cart */
  DoesNotMatchCart = 'DoesNotMatchCart',
  /** The discount code is active and it contains at least one active and valid CartDiscount. The discount code cartPredicate matches the cart and at least one of the contained active discount’s cart predicates matches the cart. */
  MatchesCart = 'MatchesCart',
  /** maxApplications or maxApplicationsPerCustomer for discountCode has been reached. */
  MaxApplicationReached = 'MaxApplicationReached',
  /** The discount code is not active or it does not contain any active cart discounts. */
  NotActive = 'NotActive',
  /** The discount code is not valid or it does not contain any valid cart discounts. Validity is determined based on the validFrom and validUntil dates */
  NotValid = 'NotValid'
}

export type DiscountCodeUpdateAction = {
  changeCartDiscounts?: InputMaybe<ChangeDiscountCodeCartDiscounts>;
  changeGroups?: InputMaybe<ChangeDiscountCodeGroups>;
  changeIsActive?: InputMaybe<ChangeDiscountCodeIsActive>;
  setCartPredicate?: InputMaybe<SetDiscountCodeCartPredicate>;
  setCustomField?: InputMaybe<SetDiscountCodeCustomField>;
  setCustomType?: InputMaybe<SetDiscountCodeCustomType>;
  setDescription?: InputMaybe<SetDiscountCodeDescription>;
  setMaxApplications?: InputMaybe<SetDiscountCodeMaxApplications>;
  setMaxApplicationsPerCustomer?: InputMaybe<SetDiscountCodeMaxApplicationsPerCustomer>;
  setName?: InputMaybe<SetDiscountCodeName>;
  setValidFrom?: InputMaybe<SetDiscountCodeValidFrom>;
  setValidFromAndUntil?: InputMaybe<SetDiscountCodeValidFromAndUntil>;
  setValidUntil?: InputMaybe<SetDiscountCodeValidUntil>;
};

export type DiscountedLineItemPortion = {
  __typename?: 'DiscountedLineItemPortion';
  discount?: Maybe<CartDiscount>;
  discountRef: Reference;
  discountedAmount: BaseMoney;
};

export type DiscountedLineItemPortionDraft = {
  discount: ReferenceInput;
  discountedAmount: BaseMoneyInput;
};

export type DiscountedLineItemPrice = {
  __typename?: 'DiscountedLineItemPrice';
  includedDiscounts: Array<DiscountedLineItemPortion>;
  value: BaseMoney;
};

export type DiscountedLineItemPriceDraft = {
  includedDiscounts?: InputMaybe<Array<DiscountedLineItemPortionDraft>>;
  value: BaseMoneyInput;
};

export type DiscountedLineItemPriceForQuantity = {
  __typename?: 'DiscountedLineItemPriceForQuantity';
  discountedPrice: DiscountedLineItemPrice;
  quantity: Scalars['Long']['output'];
};

export type DiscountedProductPriceValue = {
  __typename?: 'DiscountedProductPriceValue';
  discount?: Maybe<ProductDiscount>;
  discountRef: Reference;
  value: BaseMoney;
};

export type DiscountedProductPriceValueInput = {
  discount: ResourceIdentifierInput;
  value: BaseMoneyInput;
};

export type DiscountedProductSearchPriceValue = {
  __typename?: 'DiscountedProductSearchPriceValue';
  discount?: Maybe<ProductDiscount>;
  discountRef: Reference;
  value: BaseMoney;
};

export type EnumAttribute = Attribute & {
  __typename?: 'EnumAttribute';
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type EnumAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'EnumAttributeDefinitionType';
  name: Scalars['String']['output'];
  values: PlainEnumValueResult;
};


export type EnumAttributeDefinitionTypeValuesArgs = {
  excludeKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  includeKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type EnumField = CustomField & {
  __typename?: 'EnumField';
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type EnumType = FieldType & {
  __typename?: 'EnumType';
  name: Scalars['String']['output'];
  values: Array<EnumValue>;
};

export type EnumTypeDraft = {
  values: Array<PlainEnumValueDraft>;
};

export type EnumValue = {
  __typename?: 'EnumValue';
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
};

export type EnumValueInput = {
  key: Scalars['String']['input'];
  label: Scalars['String']['input'];
};

export type EventBridgeDestination = Destination & {
  __typename?: 'EventBridgeDestination';
  accountId: Scalars['String']['output'];
  region: Scalars['String']['output'];
  source: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type EventBridgeDestinationInput = {
  accountId: Scalars['String']['input'];
  region: Scalars['String']['input'];
};

export type EventGridDestination = Destination & {
  __typename?: 'EventGridDestination';
  accessKey: Scalars['String']['output'];
  type: Scalars['String']['output'];
  uri: Scalars['String']['output'];
};

export type EventGridDestinationInput = {
  accessKey: Scalars['String']['input'];
  uri: Scalars['String']['input'];
};

export type ExcludeProductSelectionProduct = {
  product: ResourceIdentifierInput;
  variantExclusion?: InputMaybe<ProductVariantExclusionDraft>;
};

export type ExistsFilterInput = {
  path: Scalars['String']['input'];
};

export type Extension = ReferenceExpandable & Versioned & {
  __typename?: 'Extension';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  destination: ExtensionDestination;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  timeoutInMs?: Maybe<Scalars['Int']['output']>;
  triggers: Array<Trigger>;
  version: Scalars['Long']['output'];
};

export type ExtensionDestination = {
  type: Scalars['String']['output'];
};

export type ExtensionDestinationInput = {
  AWSLambda?: InputMaybe<AwsLambdaDestinationInput>;
  GoogleCloudFunction?: InputMaybe<GoogleCloudFunctionDestinationInput>;
  HTTP?: InputMaybe<HttpDestinationInput>;
};

export type ExtensionDraft = {
  destination: ExtensionDestinationInput;
  key?: InputMaybe<Scalars['String']['input']>;
  timeoutInMs?: InputMaybe<Scalars['Int']['input']>;
  triggers: Array<TriggerInput>;
};

export type ExtensionLimitsProjection = {
  __typename?: 'ExtensionLimitsProjection';
  timeoutInMs: Limit;
};

export type ExtensionQueryResult = {
  __typename?: 'ExtensionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Extension>;
  total: Scalars['Long']['output'];
};

export type ExtensionUpdateAction = {
  changeDestination?: InputMaybe<ChangeExtensionDestination>;
  changeTriggers?: InputMaybe<ChangeExtensionTriggers>;
  setKey?: InputMaybe<SetExtensionKey>;
  setTimeoutInMs?: InputMaybe<SetExtensionTimeoutInMs>;
};

export type ExternalDiscountValue = ProductDiscountValue & {
  __typename?: 'ExternalDiscountValue';
  type: Scalars['String']['output'];
};

export type ExternalDiscountValueInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type ExternalLineItemTotalPrice = {
  __typename?: 'ExternalLineItemTotalPrice';
  price: BaseMoney;
  totalPrice: Money;
};

export type ExternalLineItemTotalPriceDraft = {
  price: BaseMoneyInput;
  totalPrice: MoneyInput;
};

export type ExternalOAuth = {
  __typename?: 'ExternalOAuth';
  authorizationHeader: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type ExternalOAuthDraft = {
  authorizationHeader: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export type ExternalTaxAmountDraft = {
  taxRate: ExternalTaxRateDraft;
  totalGross: MoneyInput;
};

export type ExternalTaxAmountDraftOutput = {
  __typename?: 'ExternalTaxAmountDraftOutput';
  taxRate: ExternalTaxRateDraftOutput;
  totalGross: Money;
};

export type ExternalTaxRateDraft = {
  amount: Scalars['Float']['input'];
  country: Scalars['Country']['input'];
  includedInPrice?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  state?: InputMaybe<Scalars['String']['input']>;
  subRates?: InputMaybe<Array<SubRateDraft>>;
};

export type ExternalTaxRateDraftOutput = {
  __typename?: 'ExternalTaxRateDraftOutput';
  amount?: Maybe<Scalars['Float']['output']>;
  country: Scalars['Country']['output'];
  includedInPrice: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  subRates: Array<SubRate>;
};

export type FacetResult = {
  type: Scalars['String']['output'];
};

export type FacetResultValue = {
  __typename?: 'FacetResultValue';
  facet: Scalars['String']['output'];
  value: FacetResult;
};

/** Field definitions describe custom fields and allow you to define some meta-information associated with the field. */
export type FieldDefinition = {
  __typename?: 'FieldDefinition';
  inputHint: TextInputHint;
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
  name: Scalars['String']['output'];
  required: Scalars['Boolean']['output'];
  type: FieldType;
};


/** Field definitions describe custom fields and allow you to define some meta-information associated with the field. */
export type FieldDefinitionLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type FieldDefinitionInput = {
  inputHint: TextInputHint;
  label: Array<LocalizedStringItemInputType>;
  name: Scalars['String']['input'];
  required: Scalars['Boolean']['input'];
  type: FieldTypeInput;
};

export type FieldType = {
  name: Scalars['String']['output'];
};

export type FieldTypeEnumTypeDraft = {
  values: Array<EnumValueInput>;
};

export type FieldTypeInput = {
  Boolean?: InputMaybe<SimpleFieldTypeDraft>;
  Date?: InputMaybe<SimpleFieldTypeDraft>;
  DateTime?: InputMaybe<SimpleFieldTypeDraft>;
  Enum?: InputMaybe<FieldTypeEnumTypeDraft>;
  LocalizedEnum?: InputMaybe<FieldTypeLocalizedEnumTypeDraft>;
  LocalizedString?: InputMaybe<SimpleFieldTypeDraft>;
  Money?: InputMaybe<SimpleFieldTypeDraft>;
  Number?: InputMaybe<SimpleFieldTypeDraft>;
  Reference?: InputMaybe<FieldTypeReferenceTypeDraft>;
  Set?: InputMaybe<FieldTypeSetTypeDraft>;
  String?: InputMaybe<SimpleFieldTypeDraft>;
  Time?: InputMaybe<SimpleFieldTypeDraft>;
};

export type FieldTypeLocalizedEnumTypeDraft = {
  values: Array<LocalizedEnumValueInput>;
};

export type FieldTypeReferenceTypeDraft = {
  referenceTypeId: Scalars['String']['input'];
};

export type FieldTypeSetElementTypeDraft = {
  Boolean?: InputMaybe<SimpleFieldTypeDraft>;
  Date?: InputMaybe<SimpleFieldTypeDraft>;
  DateTime?: InputMaybe<SimpleFieldTypeDraft>;
  Enum?: InputMaybe<FieldTypeEnumTypeDraft>;
  LocalizedEnum?: InputMaybe<FieldTypeLocalizedEnumTypeDraft>;
  LocalizedString?: InputMaybe<SimpleFieldTypeDraft>;
  Money?: InputMaybe<SimpleFieldTypeDraft>;
  Number?: InputMaybe<SimpleFieldTypeDraft>;
  Reference?: InputMaybe<FieldTypeReferenceTypeDraft>;
  String?: InputMaybe<SimpleFieldTypeDraft>;
  Time?: InputMaybe<SimpleFieldTypeDraft>;
};

export type FieldTypeSetTypeDraft = {
  elementType: FieldTypeSetElementTypeDraft;
};

export type FixedPriceDiscountValue = CartDiscountValue & {
  __typename?: 'FixedPriceDiscountValue';
  money: Array<BaseMoney>;
  type: Scalars['String']['output'];
};

export type FixedPriceDiscountValueInput = {
  money: Array<CartDiscountValueBaseMoneyInput>;
};

export type FreezeCart = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type Geometry = {
  type: Scalars['String']['output'];
};

export type GeometryInput = {
  coordinates?: InputMaybe<Array<Scalars['Float']['input']>>;
  type: Scalars['String']['input'];
};

export type GiftLineItemValue = CartDiscountValue & {
  __typename?: 'GiftLineItemValue';
  distributionChannelRef?: Maybe<ChannelReferenceIdentifier>;
  productRef: ProductReferenceIdentifier;
  supplyChannelRef?: Maybe<ChannelReferenceIdentifier>;
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type GiftLineItemValueInput = {
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  product: ResourceIdentifierInput;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId: Scalars['Int']['input'];
};

export type GoogleCloudFunctionDestination = ExtensionDestination & {
  __typename?: 'GoogleCloudFunctionDestination';
  type: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type GoogleCloudFunctionDestinationInput = {
  url: Scalars['String']['input'];
};

export type GoogleCloudPubSubDestination = Destination & {
  __typename?: 'GoogleCloudPubSubDestination';
  projectId: Scalars['String']['output'];
  topic: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type GoogleCloudPubSubDestinationInput = {
  projectId: Scalars['String']['input'];
  topic: Scalars['String']['input'];
};

export type HighPrecisionMoney = BaseMoney & {
  __typename?: 'HighPrecisionMoney';
  centAmount: Scalars['Long']['output'];
  currencyCode: Scalars['Currency']['output'];
  fractionDigits: Scalars['Int']['output'];
  preciseAmount: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type HighPrecisionMoneyInput = {
  centAmount?: InputMaybe<Scalars['Long']['input']>;
  currencyCode: Scalars['Currency']['input'];
  fractionDigits: Scalars['Int']['input'];
  preciseAmount: Scalars['Long']['input'];
};

export type HttpDestination = ExtensionDestination & {
  __typename?: 'HttpDestination';
  authentication?: Maybe<HttpDestinationAuthentication>;
  type: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type HttpDestinationAuthentication = {
  type: Scalars['String']['output'];
};

export type HttpDestinationAuthenticationInput = {
  AuthorizationHeader?: InputMaybe<AuthorizationHeaderInput>;
  AzureFunctions?: InputMaybe<AzureFunctionsAuthenticationInput>;
};

export type HttpDestinationInput = {
  authentication?: InputMaybe<HttpDestinationAuthenticationInput>;
  url: Scalars['String']['input'];
};

export type Image = {
  __typename?: 'Image';
  dimensions: Dimensions;
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type ImageInput = {
  dimensions: DimensionsInput;
  label?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['String']['input'];
};

export type ImageProductSearch = {
  __typename?: 'ImageProductSearch';
  dimensions: DimensionsProductSearch;
  label?: Maybe<Scalars['String']['output']>;
  url: Scalars['String']['output'];
};

export type ImportOrderCustomLineItemState = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  state: Array<ItemStateDraftType>;
};

export type ImportOrderDraft = {
  billingAddress?: InputMaybe<AddressInput>;
  completedAt?: InputMaybe<Scalars['DateTime']['input']>;
  country?: InputMaybe<Scalars['Country']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customLineItems?: Array<CustomLineItemImportDraft>;
  customerEmail?: InputMaybe<Scalars['String']['input']>;
  customerGroup?: InputMaybe<ReferenceInput>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  inventoryMode?: InputMaybe<InventoryMode>;
  itemShippingAddresses?: InputMaybe<Array<AddressInput>>;
  lineItems?: Array<LineItemImportDraft>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
  orderState?: InputMaybe<OrderState>;
  origin?: InputMaybe<CartOrigin>;
  paymentInfo?: InputMaybe<ReferenceInput>;
  paymentState?: InputMaybe<PaymentState>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']['input']>;
  shipmentState?: InputMaybe<ShipmentState>;
  shippingAddress?: InputMaybe<AddressInput>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  shippingInfo?: InputMaybe<ShippingInfoImportDraft>;
  state?: InputMaybe<ReferenceInput>;
  store?: InputMaybe<ReferenceInput>;
  taxCalculationMode?: InputMaybe<TaxCalculationMode>;
  taxedPrice?: InputMaybe<TaxedPriceDraft>;
  totalPrice: MoneyInput;
};

export type ImportOrderLineItemState = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  state: Array<ItemStateDraftType>;
};

export type ImportStagedOrderCustomLineItemState = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  state: Array<ItemStateDraftType>;
};

export type ImportStagedOrderCustomLineItemStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ImportStagedOrderCustomLineItemStateOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  state: Scalars['Set']['output'];
  type: Scalars['String']['output'];
};

export type ImportStagedOrderLineItemState = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  state: Array<ItemStateDraftType>;
};

export type ImportStagedOrderLineItemStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'ImportStagedOrderLineItemStateOutput';
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  state: Scalars['Set']['output'];
  type: Scalars['String']['output'];
};

export type InStore = CartDiscountQueryInterface & CartQueryInterface & CustomerActiveCartInterface & CustomerQueryInterface & MeFieldInterface & OrderQueryInterface & ShippingMethodsByCartInterface & {
  __typename?: 'InStore';
  cart?: Maybe<Cart>;
  cartDiscount?: Maybe<CartDiscount>;
  cartDiscounts: CartDiscountQueryResult;
  carts: CartQueryResult;
  customer?: Maybe<Customer>;
  customerActiveCart?: Maybe<Cart>;
  customers: CustomerQueryResult;
  /**
   * This field can only be used with an access token created with the password flow or with an anonymous session.
   *
   * It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
   */
  me: InStoreMe;
  order?: Maybe<Order>;
  orders: OrderQueryResult;
  product?: Maybe<Product>;
  productSelectionAssignments: ProductAssignmentQueryResult;
  shippingMethodsByCart: Array<ShippingMethod>;
  shoppingList?: Maybe<ShoppingList>;
  shoppingLists: ShoppingListQueryResult;
};


export type InStoreCartArgs = {
  id: Scalars['String']['input'];
};


export type InStoreCartDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreCartDiscountsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreCustomerArgs = {
  emailToken?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  passwordToken?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreCustomerActiveCartArgs = {
  customerId: Scalars['String']['input'];
};


export type InStoreCustomersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreProductArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  localeProjection?: InputMaybe<Array<Scalars['Locale']['input']>>;
  projectExpandedProducts?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  variantKey?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreProductSelectionAssignmentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreShippingMethodsByCartArgs = {
  id: Scalars['String']['input'];
};


export type InStoreShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type InStoreMe = ActiveCartInterface & CartQueryInterface & MeQueryInterface & OrderQueryInterface & ShoppingListQueryInterface & {
  __typename?: 'InStoreMe';
  activeCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  cart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  carts: CartQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  customer?: Maybe<Customer>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  order?: Maybe<Order>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  orders: OrderQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  shoppingList?: Maybe<ShoppingList>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  shoppingLists: ShoppingListQueryResult;
};


export type InStoreMeCartArgs = {
  id: Scalars['String']['input'];
};


export type InStoreMeCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreMeOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreMeOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreMeShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type InStoreMeShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type InheritedAssociate = {
  __typename?: 'InheritedAssociate';
  associateRoleAssignments: Array<InheritedAssociateRoleAssignment>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type InheritedAssociateRoleAssignment = {
  __typename?: 'InheritedAssociateRoleAssignment';
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRole: AssociateRole;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRoleRef: KeyReference;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  source: BusinessUnit;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  sourceRef: KeyReference;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type InheritedStore = {
  __typename?: 'InheritedStore';
  store?: Maybe<Store>;
  storeRef: KeyReference;
};

export type Initiator = {
  __typename?: 'Initiator';
  anonymousId?: Maybe<Scalars['String']['output']>;
  associateRef?: Maybe<Reference>;
  clientId?: Maybe<Scalars['String']['output']>;
  customerRef?: Maybe<Reference>;
  externalUserId?: Maybe<Scalars['String']['output']>;
  isPlatformClient?: Maybe<Scalars['Boolean']['output']>;
  userRef?: Maybe<Reference>;
};

export type InterfaceInteractionsRaw = {
  __typename?: 'InterfaceInteractionsRaw';
  fields: Array<RawCustomField>;
  type?: Maybe<TypeDefinition>;
  typeRef: Reference;
};


export type InterfaceInteractionsRawFieldsArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type InterfaceInteractionsRawResult = {
  __typename?: 'InterfaceInteractionsRawResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<InterfaceInteractionsRaw>;
  total: Scalars['Int']['output'];
};

/** Inventory allows you to track stock quantity per SKU and optionally per supply channel */
export type InventoryEntry = ReferenceExpandable & Versioned & {
  __typename?: 'InventoryEntry';
  availableQuantity: Scalars['Long']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  expectedDelivery?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  quantityOnStock: Scalars['Long']['output'];
  restockableInDays?: Maybe<Scalars['Int']['output']>;
  sku: Scalars['String']['output'];
  supplyChannel?: Maybe<Channel>;
  supplyChannelRef?: Maybe<Reference>;
  version: Scalars['Long']['output'];
};

export type InventoryEntryCreated = MessagePayload & {
  __typename?: 'InventoryEntryCreated';
  inventoryEntry: InventoryEntry;
  type: Scalars['String']['output'];
};

export type InventoryEntryDeleted = MessagePayload & {
  __typename?: 'InventoryEntryDeleted';
  sku: Scalars['String']['output'];
  supplyChannel?: Maybe<Channel>;
  supplyChannelRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type InventoryEntryDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  expectedDelivery?: InputMaybe<Scalars['DateTime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  quantityOnStock: Scalars['Long']['input'];
  restockableInDays?: InputMaybe<Scalars['Int']['input']>;
  sku: Scalars['String']['input'];
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
};

export type InventoryEntryQuantitySet = MessagePayload & {
  __typename?: 'InventoryEntryQuantitySet';
  newAvailableQuantity: Scalars['Long']['output'];
  newQuantityOnStock: Scalars['Long']['output'];
  oldAvailableQuantity: Scalars['Long']['output'];
  oldQuantityOnStock: Scalars['Long']['output'];
  supplyChannel?: Maybe<Channel>;
  supplyChannelRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type InventoryEntryQueryResult = {
  __typename?: 'InventoryEntryQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<InventoryEntry>;
  total: Scalars['Long']['output'];
};

export type InventoryEntryUpdateAction = {
  addQuantity?: InputMaybe<AddInventoryEntryQuantity>;
  changeQuantity?: InputMaybe<ChangeInventoryEntryQuantity>;
  removeQuantity?: InputMaybe<RemoveInventoryEntryQuantity>;
  setCustomField?: InputMaybe<SetInventoryEntryCustomField>;
  setCustomType?: InputMaybe<SetInventoryEntryCustomType>;
  setExpectedDelivery?: InputMaybe<SetInventoryEntryExpectedDelivery>;
  setRestockableInDays?: InputMaybe<SetInventoryEntryRestockableInDays>;
  setSupplyChannel?: InputMaybe<SetInventoryEntrySupplyChannel>;
};

export enum InventoryMode {
  /**
   * Adding items to cart and ordering is independent of inventory. No inventory checks or modifications.
   * This is the default mode for a new cart.
   */
  None = 'None',
  /**
   * Creating an order will fail with an OutOfStock error if an unavailable line item exists. Line items in the cart
   * are only reserved for the duration of the ordering transaction.
   */
  ReserveOnOrder = 'ReserveOnOrder',
  /**
   * Orders are tracked on inventory. That means, ordering a LineItem will decrement the available quantity on the
   * respective InventoryEntry. Creating an order will succeed even if the line item’s available quantity is zero or
   * negative. But creating an order will fail with an OutOfStock error if no matching inventory entry exists for a
   * line item.
   */
  TrackOnly = 'TrackOnly'
}

export type ItemShippingDetails = {
  __typename?: 'ItemShippingDetails';
  targets: Array<ItemShippingTarget>;
  valid: Scalars['Boolean']['output'];
};

export type ItemShippingDetailsDraft = {
  targets: Array<ShippingTargetDraft>;
};

export type ItemShippingDetailsDraftOutput = {
  __typename?: 'ItemShippingDetailsDraftOutput';
  targets: Array<ItemShippingTarget>;
};

export type ItemShippingDetailsDraftType = {
  targets: Array<ShippingTargetDraftType>;
};

export type ItemShippingTarget = {
  __typename?: 'ItemShippingTarget';
  addressKey: Scalars['String']['output'];
  quantity: Scalars['Long']['output'];
  shippingMethodKey?: Maybe<Scalars['String']['output']>;
};

export type ItemState = {
  __typename?: 'ItemState';
  quantity: Scalars['Long']['output'];
  state?: Maybe<State>;
  stateRef: Reference;
};

export type ItemStateDraftType = {
  quantity: Scalars['Long']['input'];
  state: ReferenceInput;
};

export type KeyReference = {
  __typename?: 'KeyReference';
  key: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

export type Limit = {
  __typename?: 'Limit';
  limit?: Maybe<Scalars['Long']['output']>;
};

export type LimitWithCurrent = {
  current?: Maybe<Scalars['Long']['output']>;
  limit?: Maybe<Scalars['Long']['output']>;
};

/**
 * A line item is a snapshot of a product variant at the time it was added to the cart.
 *
 * Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
 * The relation to the Product is kept but the line item will not automatically update if the product variant changes.
 * On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
 * It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
 * non-existent product and the productSlug is left empty.
 *
 * Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
 */
export type LineItem = {
  __typename?: 'LineItem';
  addedAt?: Maybe<Scalars['DateTime']['output']>;
  custom?: Maybe<CustomFieldsType>;
  discountedPricePerQuantity: Array<DiscountedLineItemPriceForQuantity>;
  distributionChannel?: Maybe<Channel>;
  distributionChannelRef?: Maybe<Reference>;
  id: Scalars['String']['output'];
  inventoryMode?: Maybe<InventoryMode>;
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt?: Maybe<Scalars['DateTime']['output']>;
  lineItemMode: LineItemMode;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  perMethodTaxRate: Array<MethodTaxRate>;
  price: ProductPrice;
  priceMode: LineItemPriceMode;
  productId: Scalars['String']['output'];
  productKey?: Maybe<Scalars['String']['output']>;
  productSlug?: Maybe<Scalars['String']['output']>;
  productSlugAllLocales?: Maybe<Array<LocalizedString>>;
  productType?: Maybe<ProductTypeDefinition>;
  productTypeRef?: Maybe<Reference>;
  quantity: Scalars['Long']['output'];
  shippingDetails?: Maybe<ItemShippingDetails>;
  state: Array<ItemState>;
  supplyChannel?: Maybe<Channel>;
  supplyChannelRef?: Maybe<Reference>;
  taxRate?: Maybe<TaxRate>;
  taxedPrice?: Maybe<TaxedItemPrice>;
  taxedPricePortions: Array<MethodTaxedPrice>;
  totalPrice?: Maybe<Money>;
  variant?: Maybe<ProductVariant>;
};


/**
 * A line item is a snapshot of a product variant at the time it was added to the cart.
 *
 * Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
 * The relation to the Product is kept but the line item will not automatically update if the product variant changes.
 * On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
 * It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
 * non-existent product and the productSlug is left empty.
 *
 * Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
 */
export type LineItemNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/**
 * A line item is a snapshot of a product variant at the time it was added to the cart.
 *
 * Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
 * The relation to the Product is kept but the line item will not automatically update if the product variant changes.
 * On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
 * It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
 * non-existent product and the productSlug is left empty.
 *
 * Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
 */
export type LineItemProductSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type LineItemDraft = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  inventoryMode?: InputMaybe<InventoryMode>;
  key?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  sku?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type LineItemDraftOutput = {
  __typename?: 'LineItemDraftOutput';
  addedAt?: Maybe<Scalars['DateTime']['output']>;
  custom?: Maybe<CustomFieldsCommand>;
  distributionChannelResId?: Maybe<ResourceIdentifier>;
  externalPrice?: Maybe<BaseMoney>;
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  externalTotalPrice?: Maybe<ExternalLineItemTotalPrice>;
  inventoryMode?: Maybe<InventoryMode>;
  key?: Maybe<Scalars['String']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Long']['output']>;
  shippingDetails?: Maybe<ItemShippingDetailsDraftOutput>;
  sku?: Maybe<Scalars['String']['output']>;
  supplyChannelResId?: Maybe<ResourceIdentifier>;
  variantId?: Maybe<Scalars['Int']['output']>;
};

export type LineItemImportDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
  price: ProductPriceDataInput;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  state?: InputMaybe<Array<ItemStateDraftType>>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  taxRate?: InputMaybe<TaxRateInput>;
  variant: ProductVariantImportDraft;
};

export enum LineItemMode {
  /**
   * The line item was added automatically, because a discount has added a free gift to the cart.
   * The quantity can not be increased, and it won’t be merged when the same product variant is added.
   * If the gift is removed, an entry is added to the "refusedGifts" array and the discount won’t be applied again
   * to the cart. The price can not be changed externally.
   * All other updates, such as the ones related to custom fields, can be used.
   */
  GiftLineItem = 'GiftLineItem',
  /**
   * The line item was added during cart creation or with the update action addLineItem. Its quantity can be
   * changed without restrictions.
   */
  Standard = 'Standard'
}

export enum LineItemPriceMode {
  /** The line item price was set externally. Cart discounts can apply to line items with this price mode. All update actions that change the quantity of a line item with this price mode require the externalPrice field to be given. */
  ExternalPrice = 'ExternalPrice',
  /** The line item price with the total was set externally. */
  ExternalTotal = 'ExternalTotal',
  /** The price is selected form the product variant. This is the default mode. */
  Platform = 'Platform'
}

export type LineItemReturnItem = ReturnItem & {
  __typename?: 'LineItemReturnItem';
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lineItemId: Scalars['String']['output'];
  paymentState: ReturnPaymentState;
  quantity: Scalars['Long']['output'];
  shipmentState: ReturnShipmentState;
  type: Scalars['String']['output'];
};

export type LineItemStateTransition = MessagePayload & OrderMessagePayload & {
  __typename?: 'LineItemStateTransition';
  fromState?: Maybe<State>;
  fromStateRef: Reference;
  lineItemId: Scalars['String']['output'];
  lineItemKey?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Long']['output'];
  toState?: Maybe<State>;
  toStateRef: Reference;
  transitionDate: Scalars['DateTime']['output'];
  type: Scalars['String']['output'];
};

export type LineItemsTarget = CartDiscountTarget & {
  __typename?: 'LineItemsTarget';
  predicate: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type LineItemsTargetInput = {
  predicate: Scalars['String']['input'];
};

export type LocalizableEnumAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'LocalizableEnumAttributeDefinitionType';
  name: Scalars['String']['output'];
  values: LocalizableEnumValueTypeResult;
};


export type LocalizableEnumAttributeDefinitionTypeValuesArgs = {
  excludeKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  includeKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type LocalizableEnumTypeDraft = {
  values: Array<LocalizedEnumValueDraft>;
};

export type LocalizableEnumValueType = {
  __typename?: 'LocalizableEnumValueType';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
};


export type LocalizableEnumValueTypeLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type LocalizableEnumValueTypeResult = {
  __typename?: 'LocalizableEnumValueTypeResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<LocalizableEnumValueType>;
  total: Scalars['Int']['output'];
};

export type LocalizableTextAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'LocalizableTextAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type LocalizedEnumAttribute = Attribute & {
  __typename?: 'LocalizedEnumAttribute';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};


export type LocalizedEnumAttributeLabelArgs = {
  locale: Scalars['Locale']['input'];
};

export type LocalizedEnumField = CustomField & {
  __typename?: 'LocalizedEnumField';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};


export type LocalizedEnumFieldLabelArgs = {
  locale: Scalars['Locale']['input'];
};

export type LocalizedEnumType = FieldType & {
  __typename?: 'LocalizedEnumType';
  name: Scalars['String']['output'];
  values: Array<LocalizedEnumValue>;
};

export type LocalizedEnumValue = {
  __typename?: 'LocalizedEnumValue';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
};


export type LocalizedEnumValueLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type LocalizedEnumValueDraft = {
  key: Scalars['String']['input'];
  label: Array<LocalizedStringItemInputType>;
};

export type LocalizedEnumValueInput = {
  key: Scalars['String']['input'];
  label: Array<LocalizedStringItemInputType>;
};

export type LocalizedString = {
  __typename?: 'LocalizedString';
  locale: Scalars['Locale']['output'];
  value: Scalars['String']['output'];
};

export type LocalizedStringAttribute = Attribute & {
  __typename?: 'LocalizedStringAttribute';
  name: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};


export type LocalizedStringAttributeValueArgs = {
  locale: Scalars['Locale']['input'];
};

export type LocalizedStringField = CustomField & {
  __typename?: 'LocalizedStringField';
  name: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};


export type LocalizedStringFieldValueArgs = {
  locale: Scalars['Locale']['input'];
};

export type LocalizedStringItemInputType = {
  locale: Scalars['Locale']['input'];
  value: Scalars['String']['input'];
};

export type LocalizedStringType = FieldType & {
  __typename?: 'LocalizedStringType';
  name: Scalars['String']['output'];
};

export type LocalizedText = {
  locale: Scalars['Locale']['input'];
  text: Scalars['String']['input'];
};

export type Location = {
  __typename?: 'Location';
  country: Scalars['Country']['output'];
  state?: Maybe<Scalars['String']['output']>;
};

export type Me = ActiveCartInterface & CartQueryInterface & MeQueryInterface & OrderQueryInterface & ShoppingListQueryInterface & {
  __typename?: 'Me';
  activeCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnit?: Maybe<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnits: BusinessUnitQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  cart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  carts: CartQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  customer?: Maybe<Customer>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  order?: Maybe<Order>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  orders: OrderQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  payment?: Maybe<MyPayment>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  payments: MyPaymentQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quote?: Maybe<Quote>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quoteRequest?: Maybe<QuoteRequest>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quoteRequests: QuoteRequestQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  quotes: QuoteQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  shoppingList?: Maybe<ShoppingList>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  shoppingLists: ShoppingListQueryResult;
};


export type MeBusinessUnitArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type MeBusinessUnitsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeCartArgs = {
  id: Scalars['String']['input'];
};


export type MeCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


export type MeOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MePaymentArgs = {
  id: Scalars['String']['input'];
};


export type MePaymentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type MeQuoteRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type MeQuoteRequestsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeQuotesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type MeShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

/** The me field gives access to the data that is specific to the customer or anonymous session linked to the access token. */
export type MeFieldInterface = {
  me: MeQueryInterface;
};

export type MeQueryInterface = {
  activeCart?: Maybe<Cart>;
  cart?: Maybe<Cart>;
  carts: CartQueryResult;
  order?: Maybe<Order>;
  orders: OrderQueryResult;
  shoppingList?: Maybe<ShoppingList>;
  shoppingLists: ShoppingListQueryResult;
};


export type MeQueryInterfaceCartArgs = {
  id: Scalars['String']['input'];
};


export type MeQueryInterfaceCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeQueryInterfaceOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


export type MeQueryInterfaceOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type MeQueryInterfaceShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type MeQueryInterfaceShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type Message = ReferenceExpandable & Versioned & {
  __typename?: 'Message';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  payload: MessagePayload;
  resourceRef: Reference;
  resourceVersion: Scalars['Long']['output'];
  sequenceNumber: Scalars['Long']['output'];
  type: Scalars['String']['output'];
  userProvidedIdentifiers?: Maybe<UserProvidedIdentifiers>;
  version: Scalars['Long']['output'];
};

export type MessagePayload = {
  type: Scalars['String']['output'];
};

export type MessageQueryResult = {
  __typename?: 'MessageQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Message>;
  total: Scalars['Long']['output'];
};

export type MessageSubscription = {
  __typename?: 'MessageSubscription';
  resourceTypeId: Scalars['String']['output'];
  types: Array<Scalars['String']['output']>;
};

export type MessageSubscriptionInput = {
  resourceTypeId: Scalars['String']['input'];
  types?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type MessagesConfiguration = {
  __typename?: 'MessagesConfiguration';
  deleteDaysAfterCreation?: Maybe<Scalars['Int']['output']>;
  enabled: Scalars['Boolean']['output'];
};

export type MessagesConfigurationDraft = {
  deleteDaysAfterCreation: Scalars['Int']['input'];
  enabled: Scalars['Boolean']['input'];
};

export type MethodTaxRate = {
  __typename?: 'MethodTaxRate';
  shippingMethodKey: Scalars['String']['output'];
  taxRate?: Maybe<TaxRate>;
};

export type MethodTaxedPrice = {
  __typename?: 'MethodTaxedPrice';
  shippingMethodKey: Scalars['String']['output'];
  taxedPrice?: Maybe<TaxedItemPrice>;
};

export type MissingFilterInput = {
  path: Scalars['String']['input'];
};

export type Money = BaseMoney & {
  __typename?: 'Money';
  centAmount: Scalars['Long']['output'];
  currencyCode: Scalars['Currency']['output'];
  /** For the `Money` it equals to the default number of fraction digits used with the currency. */
  fractionDigits: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type MoneyAttribute = Attribute & {
  __typename?: 'MoneyAttribute';
  centAmount: Scalars['Long']['output'];
  currencyCode: Scalars['Currency']['output'];
  name: Scalars['String']['output'];
};

export type MoneyAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'MoneyAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type MoneyDraft = {
  centAmount: Scalars['Long']['input'];
  currencyCode: Scalars['Currency']['input'];
};

export type MoneyField = CustomField & {
  __typename?: 'MoneyField';
  centAmount: Scalars['Long']['output'];
  currencyCode: Scalars['Currency']['output'];
  name: Scalars['String']['output'];
};

export type MoneyInput = {
  centAmount: Scalars['Long']['input'];
  currencyCode: Scalars['Currency']['input'];
};

export type MoneyType = FieldType & {
  __typename?: 'MoneyType';
  name: Scalars['String']['output'];
};

export type MoveProductImageToPosition = {
  imageUrl: Scalars['String']['input'];
  position: Scalars['Int']['input'];
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type MultiBuyCustomLineItemsTarget = CartDiscountTarget & {
  __typename?: 'MultiBuyCustomLineItemsTarget';
  discountedQuantity: Scalars['Long']['output'];
  maxOccurrence?: Maybe<Scalars['Int']['output']>;
  predicate: Scalars['String']['output'];
  selectionMode: SelectionMode;
  triggerQuantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type MultiBuyCustomLineItemsTargetInput = {
  discountedQuantity: Scalars['Long']['input'];
  maxOccurrence?: InputMaybe<Scalars['Int']['input']>;
  predicate: Scalars['String']['input'];
  selectionMode?: InputMaybe<SelectionMode>;
  triggerQuantity: Scalars['Long']['input'];
};

export type MultiBuyLineItemsTarget = CartDiscountTarget & {
  __typename?: 'MultiBuyLineItemsTarget';
  discountedQuantity: Scalars['Long']['output'];
  maxOccurrence?: Maybe<Scalars['Int']['output']>;
  predicate: Scalars['String']['output'];
  selectionMode: SelectionMode;
  triggerQuantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type MultiBuyLineItemsTargetInput = {
  discountedQuantity: Scalars['Long']['input'];
  maxOccurrence?: InputMaybe<Scalars['Int']['input']>;
  predicate: Scalars['String']['input'];
  selectionMode?: InputMaybe<SelectionMode>;
  triggerQuantity: Scalars['Long']['input'];
};

export type Mutation = {
  __typename?: 'Mutation';
  createApiClient?: Maybe<ApiClientWithSecret>;
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  createApprovalRule?: Maybe<ApprovalRule>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createAssociateRole?: Maybe<AssociateRole>;
  createAttributeGroup?: Maybe<AttributeGroup>;
  createBusinessUnit?: Maybe<BusinessUnit>;
  createCart?: Maybe<Cart>;
  createCartDiscount?: Maybe<CartDiscount>;
  createCategory?: Maybe<Category>;
  createChannel?: Maybe<Channel>;
  createCustomerGroup?: Maybe<CustomerGroup>;
  createDiscountCode?: Maybe<DiscountCode>;
  createExtension?: Maybe<Extension>;
  createInventoryEntry?: Maybe<InventoryEntry>;
  createMyBusinessUnit?: Maybe<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createMyCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createMyOrderFromCart?: Maybe<Order>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createMyOrderFromQuote?: Maybe<Order>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createMyPayment?: Maybe<MyPayment>;
  createMyQuoteRequest?: Maybe<QuoteRequest>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  createMyShoppingList?: Maybe<ShoppingList>;
  createOrUpdateCustomObject?: Maybe<CustomObject>;
  createOrderEdit?: Maybe<OrderEdit>;
  createOrderFromCart?: Maybe<Order>;
  createOrderFromQuote?: Maybe<Order>;
  createPayment?: Maybe<Payment>;
  createProduct?: Maybe<Product>;
  createProductDiscount?: Maybe<ProductDiscount>;
  createProductSelection?: Maybe<ProductSelection>;
  createProductType?: Maybe<ProductTypeDefinition>;
  createQuote?: Maybe<Quote>;
  createQuoteRequest?: Maybe<QuoteRequest>;
  createReview?: Maybe<Review>;
  createShippingMethod?: Maybe<ShippingMethod>;
  createShoppingList?: Maybe<ShoppingList>;
  createStagedQuote?: Maybe<StagedQuote>;
  createStandalonePrice?: Maybe<StandalonePrice>;
  createState?: Maybe<State>;
  createStore?: Maybe<Store>;
  createSubscription?: Maybe<CommercetoolsSubscription>;
  createTaxCategory?: Maybe<TaxCategory>;
  createTypeDefinition?: Maybe<TypeDefinition>;
  createZone?: Maybe<Zone>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  customerChangeMyPassword?: Maybe<Customer>;
  customerChangePassword?: Maybe<Customer>;
  /** Verifies customer's email using a token. */
  customerConfirmEmail?: Maybe<Customer>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  customerConfirmMyEmail?: Maybe<Customer>;
  customerCreateEmailVerificationToken: CustomerEmailToken;
  /** The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes. */
  customerCreatePasswordResetToken?: Maybe<CustomerPasswordToken>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  customerResetMyPassword?: Maybe<Customer>;
  /**
   * The following workflow can be used to reset the customer’s password:
   *
   * 1. Create a password reset token and send it embedded in a link to the customer.
   * 2. When the customer clicks on the link, you may optionally retrieve customer by password token.
   * 3. When the customer entered new password, use reset customer’s password to reset the password.
   */
  customerResetPassword?: Maybe<Customer>;
  /**
   * Retrieves the authenticated customer (a customer that matches the given email/password pair).
   *
   * There may be carts and orders created before the sign in that should be assigned to the customer account. With the `anonymousCartId`, a single anonymous cart can be assigned. With the `anonymousId`, all orders and carts that have this `anonymousId` set will be assigned to the customer.
   * If both `anonymousCartId` and `anonymousId` are given, the anonymous cart must have the `anonymousId`.
   *
   * Additionally, there might also exist one or more active customer carts from an earlier session. On customer sign in there are several ways how to proceed with this cart and the cart referenced by the `anonymousCartId`.
   *
   * * If the customer does not have a cart yet, the anonymous cart becomes the customer's cart.
   * * If the customer already has one or more carts, the content of the anonymous cart will be copied to the customer's active cart that has been modified most recently.
   *
   *   In this case the `CartState` of the anonymous cart gets changed to `Merged` while the customer's cart remains the `Active` cart.
   *
   *   If a `LineItem` in the anonymous cart matches an existing line item, or a `CustomLineItem` matches an existing custom line item in the customer's cart, the maximum quantity of both line items is used as the new quantity.
   *
   *   `ItemShippingDetails` are copied from the item with the highest quantity.
   *
   *   If `itemShippingAddresses` are different in the two carts, the resulting cart contains the addresses of both the customer cart and the anonymous cart.
   *
   *   Note, that it is not possible to merge carts that differ in their currency (set during creation of the cart).
   *
   * If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
   */
  customerSignIn: CustomerSignInResult;
  /**
   * BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
   *
   * Retrieves the authenticated customer (a customer that matches the given email/password pair).
   *
   * If used with an access token for Anonymous Sessions, all orders and carts belonging to the `anonymousId` will be assigned to the newly created customer.
   *
   * * If the customer does not have a cart yet, the anonymous cart that was modified most recently becomes the customer's cart.
   * * If the customer already has a cart, the most recently modified anonymous cart will be handled according to the `AnonymousCartSignInMode`.
   *
   * If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
   */
  customerSignMeIn: CustomerSignInResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer. */
  customerSignMeUp: CustomerSignInResult;
  /** Creates a customer. If an anonymous cart is given then the cart is assigned to the created customer and the version number of the Cart will increase. If the id of an anonymous session is given, all carts and orders will be assigned to the created customer. */
  customerSignUp: CustomerSignInResult;
  deleteApiClient?: Maybe<ApiClientWithoutSecret>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  deleteAssociateRole?: Maybe<AssociateRole>;
  deleteAttributeGroup?: Maybe<AttributeGroup>;
  deleteBusinessUnit?: Maybe<BusinessUnit>;
  deleteCart?: Maybe<Cart>;
  deleteCartDiscount?: Maybe<CartDiscount>;
  deleteCategory?: Maybe<Category>;
  deleteChannel?: Maybe<Channel>;
  deleteCustomObject?: Maybe<CustomObject>;
  deleteCustomer?: Maybe<Customer>;
  deleteCustomerGroup?: Maybe<CustomerGroup>;
  deleteDiscountCode?: Maybe<DiscountCode>;
  deleteExtension?: Maybe<Extension>;
  deleteInventoryEntry?: Maybe<InventoryEntry>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  deleteMyCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  deleteMyCustomer?: Maybe<Customer>;
  deleteMyPayment?: Maybe<MyPayment>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  deleteMyShoppingList?: Maybe<ShoppingList>;
  deleteOrder?: Maybe<Order>;
  deleteOrderEdit?: Maybe<OrderEdit>;
  deletePayment?: Maybe<Payment>;
  deleteProduct?: Maybe<Product>;
  deleteProductDiscount?: Maybe<ProductDiscount>;
  deleteProductSelection?: Maybe<ProductSelection>;
  deleteProductType?: Maybe<ProductTypeDefinition>;
  deleteQuote?: Maybe<Quote>;
  deleteQuoteRequest?: Maybe<QuoteRequest>;
  deleteReview?: Maybe<Review>;
  deleteShippingMethod?: Maybe<ShippingMethod>;
  deleteShoppingList?: Maybe<ShoppingList>;
  deleteStagedQuote?: Maybe<StagedQuote>;
  deleteStandalonePrice?: Maybe<StandalonePrice>;
  deleteState?: Maybe<State>;
  deleteStore?: Maybe<Store>;
  deleteSubscription?: Maybe<CommercetoolsSubscription>;
  deleteTaxCategory?: Maybe<TaxCategory>;
  deleteTypeDefinition?: Maybe<TypeDefinition>;
  deleteZone?: Maybe<Zone>;
  importOrder?: Maybe<Order>;
  replicateCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  replicateMyCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta Signs up a new customer and associates it with the business unit. */
  signUpInMyBusinessUnit: CustomerSignInResult;
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  updateApprovalFlow?: Maybe<ApprovalFlow>;
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  updateApprovalRule?: Maybe<ApprovalRule>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  updateAssociateRole?: Maybe<AssociateRole>;
  updateAttributeGroup?: Maybe<AttributeGroup>;
  updateBusinessUnit?: Maybe<BusinessUnit>;
  updateCart?: Maybe<Cart>;
  updateCartDiscount?: Maybe<CartDiscount>;
  updateCategory?: Maybe<Category>;
  updateChannel?: Maybe<Channel>;
  updateCustomer?: Maybe<Customer>;
  updateCustomerGroup?: Maybe<CustomerGroup>;
  updateDiscountCode?: Maybe<DiscountCode>;
  updateExtension?: Maybe<Extension>;
  updateInventoryEntry?: Maybe<InventoryEntry>;
  updateMyBusinessUnit?: Maybe<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  updateMyCart?: Maybe<Cart>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  updateMyCustomer?: Maybe<Customer>;
  updateMyPayment?: Maybe<MyPayment>;
  updateMyQuote?: Maybe<Quote>;
  updateMyQuoteRequest?: Maybe<QuoteRequest>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  updateMyShoppingList?: Maybe<ShoppingList>;
  updateOrder?: Maybe<Order>;
  updateOrderEdit?: Maybe<OrderEdit>;
  updatePayment?: Maybe<Payment>;
  updateProduct?: Maybe<Product>;
  updateProductDiscount?: Maybe<ProductDiscount>;
  updateProductSelection?: Maybe<ProductSelection>;
  updateProductType?: Maybe<ProductTypeDefinition>;
  updateProject?: Maybe<ProjectProjection>;
  updateQuote?: Maybe<Quote>;
  updateQuoteRequest?: Maybe<QuoteRequest>;
  updateReview?: Maybe<Review>;
  updateShippingMethod?: Maybe<ShippingMethod>;
  updateShoppingList?: Maybe<ShoppingList>;
  updateStagedQuote?: Maybe<StagedQuote>;
  updateStandalonePrice?: Maybe<StandalonePrice>;
  updateState?: Maybe<State>;
  updateStore?: Maybe<Store>;
  updateSubscription?: Maybe<CommercetoolsSubscription>;
  updateTaxCategory?: Maybe<TaxCategory>;
  updateTypeDefinition?: Maybe<TypeDefinition>;
  updateZone?: Maybe<Zone>;
};


export type MutationCreateApiClientArgs = {
  draft: CreateApiClient;
};


export type MutationCreateApprovalRuleArgs = {
  asAssociate: AsAssociateArgument;
  draft: ApprovalRuleDraft;
};


export type MutationCreateAssociateRoleArgs = {
  draft: AssociateRoleDraft;
};


export type MutationCreateAttributeGroupArgs = {
  draft: AttributeGroupDraft;
};


export type MutationCreateBusinessUnitArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  draft: BusinessUnitDraft;
};


export type MutationCreateCartArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  draft: CartDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateCartDiscountArgs = {
  draft: CartDiscountDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateCategoryArgs = {
  draft: CategoryDraft;
};


export type MutationCreateChannelArgs = {
  draft: ChannelDraft;
};


export type MutationCreateCustomerGroupArgs = {
  draft: CustomerGroupDraft;
};


export type MutationCreateDiscountCodeArgs = {
  draft: DiscountCodeDraft;
};


export type MutationCreateExtensionArgs = {
  draft: ExtensionDraft;
};


export type MutationCreateInventoryEntryArgs = {
  draft: InventoryEntryDraft;
};


export type MutationCreateMyBusinessUnitArgs = {
  draft: MyBusinessUnitDraft;
};


export type MutationCreateMyCartArgs = {
  draft: MyCartDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateMyOrderFromCartArgs = {
  draft: OrderMyCartCommand;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateMyOrderFromQuoteArgs = {
  draft: OrderMyQuoteCommand;
};


export type MutationCreateMyPaymentArgs = {
  draft: MyPaymentDraft;
};


export type MutationCreateMyQuoteRequestArgs = {
  draft: MyQuoteRequestDraft;
};


export type MutationCreateMyShoppingListArgs = {
  draft: MyShoppingListDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateOrUpdateCustomObjectArgs = {
  draft: CustomObjectDraft;
};


export type MutationCreateOrderEditArgs = {
  draft: OrderEditDraft;
};


export type MutationCreateOrderFromCartArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  draft: OrderCartCommand;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateOrderFromQuoteArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  draft: OrderQuoteCommand;
};


export type MutationCreatePaymentArgs = {
  draft: PaymentDraft;
};


export type MutationCreateProductArgs = {
  draft: ProductDraft;
};


export type MutationCreateProductDiscountArgs = {
  draft: ProductDiscountDraft;
};


export type MutationCreateProductSelectionArgs = {
  draft: CreateProductSelectionDraft;
};


export type MutationCreateProductTypeArgs = {
  draft: ProductTypeDraft;
};


export type MutationCreateQuoteArgs = {
  draft: QuoteDraft;
};


export type MutationCreateQuoteRequestArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  draft: QuoteRequestDraft;
};


export type MutationCreateReviewArgs = {
  draft: ReviewDraft;
};


export type MutationCreateShippingMethodArgs = {
  draft: ShippingMethodDraft;
};


export type MutationCreateShoppingListArgs = {
  draft: ShoppingListDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCreateStagedQuoteArgs = {
  draft: StagedQuoteDraft;
};


export type MutationCreateStandalonePriceArgs = {
  draft: CreateStandalonePrice;
};


export type MutationCreateStateArgs = {
  draft: StateDraft;
};


export type MutationCreateStoreArgs = {
  draft: CreateStore;
};


export type MutationCreateSubscriptionArgs = {
  draft: SubscriptionDraft;
};


export type MutationCreateTaxCategoryArgs = {
  draft: TaxCategoryDraft;
};


export type MutationCreateTypeDefinitionArgs = {
  draft: TypeDefinitionDraft;
};


export type MutationCreateZoneArgs = {
  draft: CreateZone;
};


export type MutationCustomerChangeMyPasswordArgs = {
  currentPassword: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationCustomerChangePasswordArgs = {
  currentPassword: Scalars['String']['input'];
  id: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationCustomerConfirmEmailArgs = {
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  tokenValue: Scalars['String']['input'];
  version?: InputMaybe<Scalars['Long']['input']>;
};


export type MutationCustomerConfirmMyEmailArgs = {
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  tokenValue: Scalars['String']['input'];
};


export type MutationCustomerCreateEmailVerificationTokenArgs = {
  id: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  ttlMinutes: Scalars['Int']['input'];
  version?: InputMaybe<Scalars['Long']['input']>;
};


export type MutationCustomerCreatePasswordResetTokenArgs = {
  email: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  ttlMinutes?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationCustomerResetMyPasswordArgs = {
  newPassword: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  tokenValue: Scalars['String']['input'];
};


export type MutationCustomerResetPasswordArgs = {
  newPassword: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  tokenValue: Scalars['String']['input'];
  version?: InputMaybe<Scalars['Long']['input']>;
};


export type MutationCustomerSignInArgs = {
  draft: CustomerSignInDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCustomerSignMeInArgs = {
  draft: CustomerSignMeInDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCustomerSignMeUpArgs = {
  draft: CustomerSignMeUpDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationCustomerSignUpArgs = {
  draft: CustomerSignUpDraft;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationDeleteApiClientArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteAssociateRoleArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteAttributeGroupArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteBusinessUnitArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteCartArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteCartDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteCategoryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteChannelArgs = {
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationDeleteCustomObjectArgs = {
  container?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version?: InputMaybe<Scalars['Long']['input']>;
};


export type MutationDeleteCustomerArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteCustomerGroupArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteDiscountCodeArgs = {
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationDeleteExtensionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteInventoryEntryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteMyCartArgs = {
  id: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteMyCustomerArgs = {
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteMyPaymentArgs = {
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationDeleteMyShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteOrderEditArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeletePaymentArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteProductArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteProductDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteProductSelectionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteProductTypeArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteQuoteRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteReviewArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteShippingMethodArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteStagedQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  personalDataErasure?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteStandalonePriceArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteStateArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteStoreArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteSubscriptionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteTaxCategoryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteTypeDefinitionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationDeleteZoneArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationImportOrderArgs = {
  draft: ImportOrderDraft;
};


export type MutationReplicateCartArgs = {
  asAssociate?: InputMaybe<AsAssociateArgument>;
  key?: InputMaybe<Scalars['String']['input']>;
  reference: ReferenceInput;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
};


export type MutationReplicateMyCartArgs = {
  reference: ReferenceInput;
};


export type MutationSignUpInMyBusinessUnitArgs = {
  draft: SignUpInMyBusinessUnitDraft;
};


export type MutationUpdateApprovalFlowArgs = {
  actions: Array<ApprovalFlowUpdateAction>;
  asAssociate: AsAssociateArgument;
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationUpdateApprovalRuleArgs = {
  actions: Array<ApprovalRuleUpdateAction>;
  asAssociate: AsAssociateArgument;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateAssociateRoleArgs = {
  actions: Array<AssociateRoleUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateAttributeGroupArgs = {
  actions: Array<AttributeGroupUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateBusinessUnitArgs = {
  actions: Array<BusinessUnitUpdateAction>;
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateCartArgs = {
  actions: Array<CartUpdateAction>;
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateCartDiscountArgs = {
  actions: Array<CartDiscountUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateCategoryArgs = {
  actions: Array<CategoryUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateChannelArgs = {
  actions: Array<ChannelUpdateAction>;
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationUpdateCustomerArgs = {
  actions: Array<CustomerUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateCustomerGroupArgs = {
  actions: Array<CustomerGroupUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateDiscountCodeArgs = {
  actions: Array<DiscountCodeUpdateAction>;
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationUpdateExtensionArgs = {
  actions: Array<ExtensionUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateInventoryEntryArgs = {
  actions: Array<InventoryEntryUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyBusinessUnitArgs = {
  actions: Array<MyBusinessUnitUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyCartArgs = {
  actions: Array<MyCartUpdateAction>;
  id: Scalars['String']['input'];
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyCustomerArgs = {
  actions: Array<MyCustomerUpdateAction>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyPaymentArgs = {
  actions: Array<MyPaymentUpdateAction>;
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyQuoteArgs = {
  actions: Array<MyQuoteUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyQuoteRequestArgs = {
  actions: Array<MyQuoteRequestUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateMyShoppingListArgs = {
  actions: Array<MyShoppingListUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateOrderArgs = {
  actions: Array<OrderUpdateAction>;
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateOrderEditArgs = {
  actions: Array<OrderEditUpdateAction>;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdatePaymentArgs = {
  actions: Array<PaymentUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateProductArgs = {
  actions: Array<ProductUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateProductDiscountArgs = {
  actions: Array<ProductDiscountUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateProductSelectionArgs = {
  actions: Array<ProductSelectionUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateProductTypeArgs = {
  actions: Array<ProductTypeUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateProjectArgs = {
  actions: Array<ProjectSettingsUpdateAction>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateQuoteArgs = {
  actions: Array<QuoteUpdateAction>;
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateQuoteRequestArgs = {
  actions: Array<QuoteRequestUpdateAction>;
  asAssociate?: InputMaybe<AsAssociateArgument>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateReviewArgs = {
  actions: Array<ReviewUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateShippingMethodArgs = {
  actions: Array<ShippingMethodUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateShoppingListArgs = {
  actions: Array<ShoppingListUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  storeKey?: InputMaybe<Scalars['KeyReferenceInput']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateStagedQuoteArgs = {
  actions: Array<StagedQuoteUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateStandalonePriceArgs = {
  actions: Array<StandalonePriceUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateStateArgs = {
  actions: Array<StateUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateStoreArgs = {
  actions: Array<StoreUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateSubscriptionArgs = {
  actions: Array<SubscriptionUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateTaxCategoryArgs = {
  actions: Array<TaxCategoryUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateTypeDefinitionArgs = {
  actions: Array<TypeUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};


export type MutationUpdateZoneArgs = {
  actions: Array<ZoneUpdateAction>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  version: Scalars['Long']['input'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type MyBusinessUnitDraft = {
  addresses?: InputMaybe<Array<AddressInput>>;
  /** The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses. */
  billingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  /** The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address. */
  defaultBillingAddress?: InputMaybe<Scalars['Int']['input']>;
  /** The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address. */
  defaultShippingAddress?: InputMaybe<Scalars['Int']['input']>;
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  parentUnit?: InputMaybe<ResourceIdentifierInput>;
  /** The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses. */
  shippingAddresses?: InputMaybe<Array<Scalars['Int']['input']>>;
  storeMode?: InputMaybe<Scalars['String']['input']>;
  unitType: BusinessUnitType;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type MyBusinessUnitUpdateAction = {
  addAddress?: InputMaybe<AddMyBusinessUnitAddress>;
  addBillingAddressId?: InputMaybe<AddMyBusinessUnitBillingAddressId>;
  addShippingAddressId?: InputMaybe<AddMyBusinessUnitShippingAddressId>;
  changeAddress?: InputMaybe<ChangeMyBusinessUnitAddress>;
  changeAssociate?: InputMaybe<ChangeMyBusinessUnitAssociate>;
  changeName?: InputMaybe<ChangeMyBusinessUnitName>;
  changeParentUnit?: InputMaybe<ChangeMyBusinessUnitParentUnit>;
  removeAddress?: InputMaybe<RemoveMyBusinessUnitAddress>;
  removeAssociate?: InputMaybe<RemoveMyBusinessUnitAssociate>;
  removeBillingAddressId?: InputMaybe<RemoveMyBusinessUnitBillingAddressId>;
  removeShippingAddressId?: InputMaybe<RemoveMyBusinessUnitShippingAddressId>;
  setAddressCustomField?: InputMaybe<SetMyBusinessUnitAddressCustomField>;
  setAddressCustomType?: InputMaybe<SetMyBusinessUnitAddressCustomType>;
  setContactEmail?: InputMaybe<SetMyBusinessUnitContactEmail>;
  setCustomField?: InputMaybe<SetMyBusinessUnitCustomField>;
  setCustomType?: InputMaybe<SetMyBusinessUnitCustomType>;
  setDefaultBillingAddress?: InputMaybe<SetMyBusinessUnitDefaultBillingAddress>;
  setDefaultShippingAddress?: InputMaybe<SetMyBusinessUnitDefaultShippingAddress>;
};

export type MyCartDraft = {
  billingAddress?: InputMaybe<AddressInput>;
  businessUnit?: InputMaybe<ResourceIdentifierInput>;
  country?: InputMaybe<Scalars['Country']['input']>;
  currency: Scalars['Currency']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  customShipping?: InputMaybe<Array<CustomShippingDraft>>;
  customerEmail?: InputMaybe<Scalars['String']['input']>;
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
  discountCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  inventoryMode?: InputMaybe<InventoryMode>;
  itemShippingAddresses?: InputMaybe<Array<AddressInput>>;
  lineItems?: InputMaybe<Array<MyLineItemDraft>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  shipping?: InputMaybe<Array<ShippingDraft>>;
  shippingAddress?: InputMaybe<AddressInput>;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
  shippingMode?: InputMaybe<ShippingMode>;
  store?: InputMaybe<ResourceIdentifierInput>;
  taxMode?: InputMaybe<TaxMode>;
};

export type MyCartUpdateAction = {
  addDiscountCode?: InputMaybe<AddCartDiscountCode>;
  addItemShippingAddress?: InputMaybe<AddCartItemShippingAddress>;
  addLineItem?: InputMaybe<AddMyCartLineItem>;
  addPayment?: InputMaybe<AddCartPayment>;
  addShoppingList?: InputMaybe<AddCartShoppingList>;
  applyDeltaToLineItemShippingDetailsTargets?: InputMaybe<ApplyCartDeltaToLineItemShippingDetailsTargets>;
  changeLineItemQuantity?: InputMaybe<ChangeCartLineItemQuantity>;
  changeTaxMode?: InputMaybe<ChangeMyCartTaxMode>;
  recalculate?: InputMaybe<RecalculateCart>;
  removeDiscountCode?: InputMaybe<RemoveCartDiscountCode>;
  removeItemShippingAddress?: InputMaybe<RemoveCartItemShippingAddress>;
  removeLineItem?: InputMaybe<RemoveCartLineItem>;
  removePayment?: InputMaybe<RemoveCartPayment>;
  setBillingAddress?: InputMaybe<SetCartBillingAddress>;
  setBillingAddressCustomField?: InputMaybe<SetCartBillingAddressCustomField>;
  setBillingAddressCustomType?: InputMaybe<SetCartBillingAddressCustomType>;
  setBusinessUnit?: InputMaybe<SetCartBusinessUnit>;
  setCountry?: InputMaybe<SetCartCountry>;
  setCustomField?: InputMaybe<SetCartCustomField>;
  setCustomType?: InputMaybe<SetCartCustomType>;
  setCustomerEmail?: InputMaybe<SetCartCustomerEmail>;
  setDeleteDaysAfterLastModification?: InputMaybe<SetCartDeleteDaysAfterLastModification>;
  setItemShippingAddressCustomField?: InputMaybe<SetCartItemShippingAddressCustomField>;
  setItemShippingAddressCustomType?: InputMaybe<SetCartItemShippingAddressCustomType>;
  setLineItemCustomField?: InputMaybe<SetCartLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetCartLineItemCustomType>;
  setLineItemDistributionChannel?: InputMaybe<SetCartLineItemDistributionChannel>;
  setLineItemShippingDetails?: InputMaybe<SetCartLineItemShippingDetails>;
  setLineItemSupplyChannel?: InputMaybe<SetCartLineItemSupplyChannel>;
  setLocale?: InputMaybe<SetCartLocale>;
  setShippingAddress?: InputMaybe<SetCartShippingAddress>;
  setShippingAddressCustomField?: InputMaybe<SetCartShippingAddressCustomField>;
  setShippingAddressCustomType?: InputMaybe<SetCartShippingAddressCustomType>;
  setShippingCustomField?: InputMaybe<SetCartShippingCustomField>;
  setShippingCustomType?: InputMaybe<SetCartShippingCustomType>;
  setShippingMethod?: InputMaybe<SetMyCartShippingMethod>;
  updateItemShippingAddress?: InputMaybe<UpdateCartItemShippingAddress>;
};

export type MyCustomerUpdateAction = {
  addAddress?: InputMaybe<AddCustomerAddress>;
  addBillingAddressId?: InputMaybe<AddCustomerBillingAddressId>;
  addShippingAddressId?: InputMaybe<AddCustomerShippingAddressId>;
  changeAddress?: InputMaybe<ChangeCustomerAddress>;
  changeEmail?: InputMaybe<ChangeCustomerEmail>;
  removeAddress?: InputMaybe<RemoveCustomerAddress>;
  removeBillingAddressId?: InputMaybe<RemoveCustomerBillingAddressId>;
  removeShippingAddressId?: InputMaybe<RemoveCustomerShippingAddressId>;
  setAddressCustomField?: InputMaybe<SetCustomerAddressCustomField>;
  setAddressCustomType?: InputMaybe<SetCustomerAddressCustomType>;
  setCompanyName?: InputMaybe<SetCustomerCompanyName>;
  setCustomField?: InputMaybe<SetCustomerCustomField>;
  setCustomType?: InputMaybe<SetCustomerCustomType>;
  setDateOfBirth?: InputMaybe<SetCustomerDateOfBirth>;
  setDefaultBillingAddress?: InputMaybe<SetCustomerDefaultBillingAddress>;
  setDefaultShippingAddress?: InputMaybe<SetCustomerDefaultShippingAddress>;
  setFirstName?: InputMaybe<SetCustomerFirstName>;
  setLastName?: InputMaybe<SetCustomerLastName>;
  setLocale?: InputMaybe<SetCustomerLocale>;
  setMiddleName?: InputMaybe<SetCustomerMiddleName>;
  setSalutation?: InputMaybe<SetCustomerSalutation>;
  setTitle?: InputMaybe<SetCustomerTitle>;
  setVatId?: InputMaybe<SetCustomerVatId>;
};

export type MyLineItemDraft = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
  sku?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * My Payments endpoint provides access to payments scoped to a specific user.
 * [documentation](https://docs.commercetools.com/api/projects/me-payments#mypayment)
 */
export type MyPayment = {
  __typename?: 'MyPayment';
  amountPlanned: Money;
  anonymousId?: Maybe<Scalars['String']['output']>;
  custom?: Maybe<CustomFieldsType>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  id: Scalars['String']['output'];
  paymentMethodInfo: PaymentMethodInfo;
  transactions: Array<Transaction>;
  version: Scalars['Long']['output'];
};

export type MyPaymentDraft = {
  amountPlanned: MoneyInput;
  custom?: InputMaybe<CustomFieldsDraft>;
  paymentMethodInfo?: InputMaybe<PaymentMethodInfoInput>;
  transaction?: InputMaybe<MyTransactionDraft>;
};

export type MyPaymentQueryResult = {
  __typename?: 'MyPaymentQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<MyPayment>;
  total: Scalars['Long']['output'];
};

export type MyPaymentUpdateAction = {
  addTransaction?: InputMaybe<AddMyPaymentTransaction>;
  changeAmountPlanned?: InputMaybe<ChangePaymentAmountPlanned>;
  setCustomField?: InputMaybe<SetPaymentCustomField>;
  setMethodInfoInterface?: InputMaybe<SetPaymentMethodInfoInterface>;
  setMethodInfoMethod?: InputMaybe<SetPaymentMethodInfoMethod>;
  setMethodInfoName?: InputMaybe<SetPaymentMethodInfoName>;
};

export type MyQuoteRequestDraft = {
  cartId: Scalars['String']['input'];
  cartVersion: Scalars['Long']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
};

export type MyQuoteRequestUpdateAction = {
  cancelQuoteRequest?: InputMaybe<CancelQuoteRequest>;
  setCustomField?: InputMaybe<SetMyQuoteRequestCustomField>;
  setCustomType?: InputMaybe<SetMyQuoteRequestCustomType>;
};

export enum MyQuoteState {
  Accepted = 'Accepted',
  Declined = 'Declined',
  Failed = 'Failed'
}

export type MyQuoteUpdateAction = {
  changeMyQuoteState?: InputMaybe<ChangeMyQuoteMyQuoteState>;
  requestQuoteRenegotiation?: InputMaybe<RequestQuoteRenegotiation>;
  setCustomField?: InputMaybe<SetQuoteCustomField>;
  setCustomType?: InputMaybe<SetQuoteCustomType>;
};

export type MyShoppingListDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  lineItems?: InputMaybe<Array<ShoppingListLineItemDraft>>;
  name: Array<LocalizedStringItemInputType>;
  textLineItems?: InputMaybe<Array<TextLineItemDraft>>;
};

export type MyShoppingListUpdateAction = {
  addLineItem?: InputMaybe<AddShoppingListLineItem>;
  addTextLineItem?: InputMaybe<AddShoppingListTextLineItem>;
  changeLineItemQuantity?: InputMaybe<ChangeShoppingListLineItemQuantity>;
  changeLineItemsOrder?: InputMaybe<ChangeShoppingListLineItemsOrder>;
  changeName?: InputMaybe<ChangeShoppingListName>;
  changeTextLineItemName?: InputMaybe<ChangeShoppingListTextLineItemName>;
  changeTextLineItemQuantity?: InputMaybe<ChangeShoppingListTextLineItemQuantity>;
  changeTextLineItemsOrder?: InputMaybe<ChangeShoppingListTextLineItemsOrder>;
  removeLineItem?: InputMaybe<RemoveShoppingListLineItem>;
  removeTextLineItem?: InputMaybe<RemoveShoppingListTextLineItem>;
  setCustomField?: InputMaybe<SetShoppingListCustomField>;
  setCustomType?: InputMaybe<SetShoppingListCustomType>;
  setDeleteDaysAfterLastModification?: InputMaybe<SetShoppingListDeleteDaysAfterLastModification>;
  setDescription?: InputMaybe<SetShoppingListDescription>;
  setLineItemCustomField?: InputMaybe<SetShoppingListLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetShoppingListLineItemCustomType>;
  setStore?: InputMaybe<SetShoppingListStore>;
  setTextLineItemCustomField?: InputMaybe<SetShoppingListTextLineItemCustomField>;
  setTextLineItemCustomType?: InputMaybe<SetShoppingListTextLineItemCustomType>;
  setTextLineItemDescription?: InputMaybe<SetShoppingListTextLineItemDescription>;
};

export type MyTransactionDraft = {
  amount: MoneyInput;
  custom?: InputMaybe<CustomFieldsDraft>;
  interactionId?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['DateTime']['input']>;
  type: TransactionType;
};

export type NestedAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'NestedAttributeDefinitionType';
  name: Scalars['String']['output'];
  typeRef: Reference;
};

export type NotProcessed = OrderEditResult & {
  __typename?: 'NotProcessed';
  type: Scalars['String']['output'];
};

export type NotificationFormat = {
  type: Scalars['String']['output'];
};

export type NumberAttribute = Attribute & {
  __typename?: 'NumberAttribute';
  name: Scalars['String']['output'];
  value: Scalars['BigDecimal']['output'];
};

export type NumberAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'NumberAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type NumberField = CustomField & {
  __typename?: 'NumberField';
  name: Scalars['String']['output'];
  value: Scalars['BigDecimal']['output'];
};

export type NumberType = FieldType & {
  __typename?: 'NumberType';
  name: Scalars['String']['output'];
};

/**
 * An order can be created from a cart, usually after a checkout process has been completed.
 * [documentation](https://docs.commercetools.com/api/projects/orders)
 */
export type Order = ReferenceExpandable & Versioned & {
  __typename?: 'Order';
  anonymousId?: Maybe<Scalars['String']['output']>;
  billingAddress?: Maybe<Address>;
  businessUnit?: Maybe<BusinessUnit>;
  businessUnitRef?: Maybe<KeyReference>;
  cart?: Maybe<Cart>;
  cartRef?: Maybe<Reference>;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  country?: Maybe<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customLineItems: Array<CustomLineItem>;
  customer?: Maybe<Customer>;
  customerEmail?: Maybe<Scalars['String']['output']>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  customerId?: Maybe<Scalars['String']['output']>;
  directDiscounts: Array<DirectDiscount>;
  discountCodes: Array<DiscountCodeInfo>;
  id: Scalars['String']['output'];
  inventoryMode: InventoryMode;
  itemShippingAddresses: Array<Address>;
  /** @deprecated An internal field that should not be used in customer logic */
  lastMessageSequenceNumber: Scalars['Long']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lineItems: Array<LineItem>;
  locale?: Maybe<Scalars['Locale']['output']>;
  orderNumber?: Maybe<Scalars['String']['output']>;
  orderState: OrderState;
  origin: CartOrigin;
  paymentInfo?: Maybe<PaymentInfo>;
  paymentState?: Maybe<PaymentState>;
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  quote?: Maybe<Quote>;
  quoteRef?: Maybe<Reference>;
  refusedGifts: Array<CartDiscount>;
  refusedGiftsRefs: Array<Reference>;
  returnInfo: Array<ReturnInfo>;
  shipmentState?: Maybe<ShipmentState>;
  shipping: Array<Shipping>;
  shippingAddress?: Maybe<Address>;
  shippingCustomFields?: Maybe<CustomFieldsType>;
  shippingInfo?: Maybe<ShippingInfo>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  shippingMode: ShippingMode;
  shippingRateInput?: Maybe<ShippingRateInput>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  syncInfo: Array<SyncInfo>;
  taxCalculationMode: TaxCalculationMode;
  taxMode: TaxMode;
  taxRoundingMode: RoundingMode;
  taxedPrice?: Maybe<TaxedPrice>;
  taxedShippingPrice?: Maybe<TaxedPrice>;
  totalPrice: Money;
  version: Scalars['Long']['output'];
};


/**
 * An order can be created from a cart, usually after a checkout process has been completed.
 * [documentation](https://docs.commercetools.com/api/projects/orders)
 */
export type OrderLineItemsArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type OrderBillingAddressSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderBillingAddressSet';
  address?: Maybe<Address>;
  oldAddress?: Maybe<Address>;
  type: Scalars['String']['output'];
};

export type OrderCartCommand = {
  cart?: InputMaybe<ResourceIdentifierInput>;
  custom?: InputMaybe<CustomFieldsDraft>;
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
  orderState?: InputMaybe<OrderState>;
  paymentState?: InputMaybe<PaymentState>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']['input']>;
  shipmentState?: InputMaybe<ShipmentState>;
  state?: InputMaybe<ReferenceInput>;
  version: Scalars['Long']['input'];
};

export type OrderCreated = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCreated';
  order: Order;
  type: Scalars['String']['output'];
};

export type OrderCustomFieldAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomFieldAdded';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value: Scalars['Json']['output'];
};

export type OrderCustomFieldChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomFieldChanged';
  name: Scalars['String']['output'];
  previousValue?: Maybe<Scalars['Json']['output']>;
  type: Scalars['String']['output'];
  value: Scalars['Json']['output'];
};

export type OrderCustomFieldRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomFieldRemoved';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type OrderCustomLineItemAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomLineItemAdded';
  customLineItem: CustomLineItem;
  type: Scalars['String']['output'];
};

export type OrderCustomLineItemDiscountSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomLineItemDiscountSet';
  customLineItemId: Scalars['String']['output'];
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  discountedPricePerQuantity: Array<DiscountedLineItemPriceForQuantity>;
  taxedPrice?: Maybe<TaxedItemPrice>;
  type: Scalars['String']['output'];
};

export type OrderCustomLineItemQuantityChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomLineItemQuantityChanged';
  customLineItemId: Scalars['String']['output'];
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  oldQuantity?: Maybe<Scalars['Long']['output']>;
  quantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type OrderCustomLineItemRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomLineItemRemoved';
  customLineItem?: Maybe<CustomLineItem>;
  customLineItemId: Scalars['String']['output'];
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type OrderCustomTypeRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomTypeRemoved';
  previousTypeId?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type OrderCustomTypeSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomTypeSet';
  customFields: CustomFieldsType;
  previousTypeId?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type OrderCustomerEmailSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomerEmailSet';
  email?: Maybe<Scalars['String']['output']>;
  oldEmail?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type OrderCustomerGroupSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomerGroupSet';
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  oldCustomerGroup?: Maybe<CustomerGroup>;
  oldCustomerGroupRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type OrderCustomerSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderCustomerSet';
  customer?: Maybe<Customer>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  customerRef?: Maybe<Reference>;
  oldCustomer?: Maybe<Customer>;
  oldCustomerGroup?: Maybe<CustomerGroup>;
  oldCustomerGroupRef?: Maybe<Reference>;
  oldCustomerRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type OrderDeleted = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderDeleted';
  order?: Maybe<Order>;
  type: Scalars['String']['output'];
};

export type OrderDiscountCodeAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderDiscountCodeAdded';
  discountCode?: Maybe<DiscountCode>;
  discountCodeRef: Reference;
  type: Scalars['String']['output'];
};

export type OrderDiscountCodeRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderDiscountCodeRemoved';
  discountCode?: Maybe<DiscountCode>;
  discountCodeRef: Reference;
  type: Scalars['String']['output'];
};

export type OrderDiscountCodeStateSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderDiscountCodeStateSet';
  discountCode?: Maybe<DiscountCode>;
  discountCodeRef: Reference;
  oldState?: Maybe<DiscountCodeState>;
  state: DiscountCodeState;
  type: Scalars['String']['output'];
};

export type OrderEdit = Versioned & {
  __typename?: 'OrderEdit';
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  resource?: Maybe<Order>;
  resourceRef: Reference;
  result: OrderEditResult;
  stagedActions: Array<StagedOrderUpdateActionOutput>;
  version: Scalars['Long']['output'];
};

export type OrderEditApplied = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderEditApplied';
  edit?: Maybe<OrderEdit>;
  editRef: Reference;
  result: Applied;
  type: Scalars['String']['output'];
};

export type OrderEditDraft = {
  comment?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  resource: ReferenceInput;
  stagedActions: Array<StagedOrderUpdateAction>;
};

export type OrderEditLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'OrderEditLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type OrderEditLimitsProjection = {
  __typename?: 'OrderEditLimitsProjection';
  total: OrderEditLimitWithCurrent;
};

export type OrderEditQueryResult = {
  __typename?: 'OrderEditQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<OrderEdit>;
  total: Scalars['Long']['output'];
};

export type OrderEditResult = {
  type: Scalars['String']['output'];
};

export type OrderEditUpdateAction = {
  addStagedAction?: InputMaybe<AddOrderEditStagedAction>;
  setComment?: InputMaybe<SetOrderEditComment>;
  setCustomField?: InputMaybe<SetOrderEditCustomField>;
  setCustomType?: InputMaybe<SetOrderEditCustomType>;
  setKey?: InputMaybe<SetOrderEditKey>;
  setStagedActions?: InputMaybe<SetOrderEditStagedActions>;
};

export type OrderExcerpt = {
  __typename?: 'OrderExcerpt';
  taxedPrice?: Maybe<TaxedPrice>;
  totalPrice: Money;
  version?: Maybe<Scalars['Long']['output']>;
};

export type OrderImported = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderImported';
  order: Order;
  type: Scalars['String']['output'];
};

export type OrderLineItemAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderLineItemAdded';
  addedQuantity: Scalars['Long']['output'];
  lineItem: LineItem;
  type: Scalars['String']['output'];
};

export type OrderLineItemDiscountSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderLineItemDiscountSet';
  discountedPricePerQuantity: Array<DiscountedLineItemPriceForQuantity>;
  lineItemId: Scalars['String']['output'];
  lineItemKey?: Maybe<Scalars['String']['output']>;
  taxedPrice?: Maybe<TaxedItemPrice>;
  taxedPricePortions: Array<MethodTaxedPrice>;
  totalPrice: Money;
  type: Scalars['String']['output'];
};

export type OrderLineItemDistributionChannelSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderLineItemDistributionChannelSet';
  distributionChannel?: Maybe<Channel>;
  distributionChannelRef?: Maybe<Reference>;
  lineItemId: Scalars['String']['output'];
  lineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type OrderLineItemRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderLineItemRemoved';
  lineItemId: Scalars['String']['output'];
  lineItemKey?: Maybe<Scalars['String']['output']>;
  newPrice?: Maybe<ProductPrice>;
  newQuantity: Scalars['Long']['output'];
  newShippingDetails?: Maybe<ItemShippingDetails>;
  newState: Scalars['Set']['output'];
  newTaxedPrice?: Maybe<TaxedItemPrice>;
  newTotalPrice: Money;
  removedQuantity: Scalars['Long']['output'];
  type: Scalars['String']['output'];
};

export type OrderMessagePayload = {
  type: Scalars['String']['output'];
};

export type OrderMyCartCommand = {
  id: Scalars['String']['input'];
  version: Scalars['Long']['input'];
};

export type OrderMyQuoteCommand = {
  id: Scalars['String']['input'];
  quoteStateToAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  version: Scalars['Long']['input'];
};

export type OrderPaymentAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderPaymentAdded';
  paymentRef: Reference;
  type: Scalars['String']['output'];
};

export type OrderPaymentRemoved = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderPaymentRemoved';
  paymentRef: Reference;
  removedPaymentInfo: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

export type OrderPaymentStateChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderPaymentStateChanged';
  oldPaymentState?: Maybe<PaymentState>;
  paymentState: PaymentState;
  type: Scalars['String']['output'];
};

/** Fields to access orders. Includes direct access to a single order and searching for orders. */
export type OrderQueryInterface = {
  order?: Maybe<Order>;
  orders: OrderQueryResult;
};


/** Fields to access orders. Includes direct access to a single order and searching for orders. */
export type OrderQueryInterfaceOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access orders. Includes direct access to a single order and searching for orders. */
export type OrderQueryInterfaceOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type OrderQueryResult = {
  __typename?: 'OrderQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Order>;
  total: Scalars['Long']['output'];
};

export type OrderQuoteCommand = {
  custom?: InputMaybe<CustomFieldsDraft>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
  orderState?: InputMaybe<OrderState>;
  paymentState?: InputMaybe<PaymentState>;
  quote?: InputMaybe<ResourceIdentifierInput>;
  quoteStateToAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  shipmentState?: InputMaybe<ShipmentState>;
  state?: InputMaybe<ReferenceInput>;
  version: Scalars['Long']['input'];
};

export type OrderReturnShipmentStateChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderReturnShipmentStateChanged';
  returnItemId: Scalars['String']['output'];
  returnShipmentState: ReturnShipmentState;
  type: Scalars['String']['output'];
};

export type OrderSearchConfiguration = {
  __typename?: 'OrderSearchConfiguration';
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  status: OrderSearchStatus;
};

export enum OrderSearchStatus {
  Activated = 'Activated',
  Deactivated = 'Deactivated'
}

export type OrderShipmentStateChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderShipmentStateChanged';
  oldShipmentState?: Maybe<ShipmentState>;
  shipmentState: ShipmentState;
  type: Scalars['String']['output'];
};

export type OrderShippingAddressSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderShippingAddressSet';
  address?: Maybe<Address>;
  oldAddress?: Maybe<Address>;
  type: Scalars['String']['output'];
};

export type OrderShippingInfoSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderShippingInfoSet';
  oldShippingInfo?: Maybe<ShippingInfo>;
  shippingInfo?: Maybe<ShippingInfo>;
  type: Scalars['String']['output'];
};

export type OrderShippingRateInputSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderShippingRateInputSet';
  oldShippingRateInput?: Maybe<ShippingRateInput>;
  shippingRateInput?: Maybe<ShippingRateInput>;
  type: Scalars['String']['output'];
};

export enum OrderState {
  Cancelled = 'Cancelled',
  Complete = 'Complete',
  Confirmed = 'Confirmed',
  Open = 'Open'
}

export type OrderStateChanged = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderStateChanged';
  oldOrderState?: Maybe<OrderState>;
  orderId: Scalars['String']['output'];
  orderState: OrderState;
  type: Scalars['String']['output'];
};

export type OrderStateTransition = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderStateTransition';
  force: Scalars['Boolean']['output'];
  oldState?: Maybe<State>;
  oldStateRef?: Maybe<Reference>;
  state?: Maybe<State>;
  stateRef: Reference;
  type: Scalars['String']['output'];
};

export type OrderStoreSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'OrderStoreSet';
  oldStore?: Maybe<Store>;
  oldStoreRef?: Maybe<KeyReference>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  type: Scalars['String']['output'];
};

export type OrderUpdateAction = {
  addDelivery?: InputMaybe<AddOrderDelivery>;
  addItemShippingAddress?: InputMaybe<AddOrderItemShippingAddress>;
  addParcelToDelivery?: InputMaybe<AddOrderParcelToDelivery>;
  addPayment?: InputMaybe<AddOrderPayment>;
  addReturnInfo?: InputMaybe<AddOrderReturnInfo>;
  changeOrderState?: InputMaybe<ChangeOrderState>;
  changePaymentState?: InputMaybe<ChangeOrderPaymentState>;
  changeShipmentState?: InputMaybe<ChangeOrderShipmentState>;
  importCustomLineItemState?: InputMaybe<ImportOrderCustomLineItemState>;
  importLineItemState?: InputMaybe<ImportOrderLineItemState>;
  removeDelivery?: InputMaybe<RemoveOrderDelivery>;
  removeItemShippingAddress?: InputMaybe<RemoveOrderItemShippingAddress>;
  removeParcelFromDelivery?: InputMaybe<RemoveOrderParcelFromDelivery>;
  removePayment?: InputMaybe<RemoveOrderPayment>;
  setBillingAddress?: InputMaybe<SetOrderBillingAddress>;
  setBillingAddressCustomField?: InputMaybe<SetOrderBillingAddressCustomField>;
  setBillingAddressCustomType?: InputMaybe<SetOrderBillingAddressCustomType>;
  setCustomField?: InputMaybe<SetOrderCustomField>;
  setCustomLineItemCustomField?: InputMaybe<SetOrderCustomLineItemCustomField>;
  setCustomLineItemCustomType?: InputMaybe<SetOrderCustomLineItemCustomType>;
  setCustomLineItemShippingDetails?: InputMaybe<SetOrderCustomLineItemShippingDetails>;
  setCustomType?: InputMaybe<SetOrderCustomType>;
  setCustomerEmail?: InputMaybe<SetOrderCustomerEmail>;
  setCustomerId?: InputMaybe<SetOrderCustomerId>;
  setDeliveryAddress?: InputMaybe<SetOrderDeliveryAddress>;
  setDeliveryAddressCustomField?: InputMaybe<SetOrderDeliveryAddressCustomField>;
  setDeliveryAddressCustomType?: InputMaybe<SetOrderDeliveryAddressCustomType>;
  setDeliveryCustomField?: InputMaybe<SetOrderDeliveryCustomField>;
  setDeliveryCustomType?: InputMaybe<SetOrderDeliveryCustomType>;
  setDeliveryItems?: InputMaybe<SetOrderDeliveryItems>;
  setItemShippingAddressCustomField?: InputMaybe<SetOrderItemShippingAddressCustomField>;
  setItemShippingAddressCustomType?: InputMaybe<SetOrderItemShippingAddressCustomType>;
  setLineItemCustomField?: InputMaybe<SetOrderLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetOrderLineItemCustomType>;
  setLineItemShippingDetails?: InputMaybe<SetOrderLineItemShippingDetails>;
  setLocale?: InputMaybe<SetOrderLocale>;
  setOrderNumber?: InputMaybe<SetOrderNumber>;
  setParcelCustomField?: InputMaybe<SetOrderParcelCustomField>;
  setParcelCustomType?: InputMaybe<SetOrderParcelCustomType>;
  setParcelItems?: InputMaybe<SetOrderParcelItems>;
  setParcelMeasurements?: InputMaybe<SetOrderParcelMeasurements>;
  setParcelTrackingData?: InputMaybe<SetOrderParcelTrackingData>;
  setPurchaseOrderNumber?: InputMaybe<SetOrderPurchaseOrderNumber>;
  setReturnInfo?: InputMaybe<SetOrderReturnInfo>;
  setReturnItemCustomField?: InputMaybe<SetOrderReturnItemCustomField>;
  setReturnItemCustomType?: InputMaybe<SetOrderReturnItemCustomType>;
  setReturnPaymentState?: InputMaybe<SetOrderReturnPaymentState>;
  setReturnShipmentState?: InputMaybe<SetOrderReturnShipmentState>;
  setShippingAddress?: InputMaybe<SetOrderShippingAddress>;
  setShippingAddressCustomField?: InputMaybe<SetOrderShippingAddressCustomField>;
  setShippingAddressCustomType?: InputMaybe<SetOrderShippingAddressCustomType>;
  setShippingCustomField?: InputMaybe<SetOrderShippingCustomField>;
  setShippingCustomType?: InputMaybe<SetOrderShippingCustomType>;
  setStore?: InputMaybe<SetOrderStore>;
  transitionCustomLineItemState?: InputMaybe<TransitionOrderCustomLineItemState>;
  transitionLineItemState?: InputMaybe<TransitionOrderLineItemState>;
  transitionState?: InputMaybe<TransitionOrderState>;
  updateItemShippingAddress?: InputMaybe<UpdateOrderItemShippingAddress>;
  updateSyncInfo?: InputMaybe<UpdateOrderSyncInfo>;
};

export type Parcel = {
  __typename?: 'Parcel';
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  items: Array<DeliveryItem>;
  key?: Maybe<Scalars['String']['output']>;
  measurements?: Maybe<ParcelMeasurements>;
  trackingData?: Maybe<TrackingData>;
};

export type ParcelAddedToDelivery = MessagePayload & OrderMessagePayload & {
  __typename?: 'ParcelAddedToDelivery';
  delivery: Delivery;
  parcel: Parcel;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ParcelData = {
  __typename?: 'ParcelData';
  custom?: Maybe<CustomFieldsCommand>;
  items: Array<DeliveryItem>;
  key?: Maybe<Scalars['String']['output']>;
  measurements?: Maybe<ParcelMeasurements>;
  trackingData?: Maybe<TrackingData>;
};

export type ParcelDataDraftType = {
  custom?: InputMaybe<CustomFieldsDraft>;
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type ParcelDraft = {
  createdAt: Scalars['DateTime']['input'];
  custom?: InputMaybe<CustomFieldsDraft>;
  id: Scalars['String']['input'];
  items?: InputMaybe<Array<DeliveryItemDraftType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type ParcelItemsUpdated = MessagePayload & OrderMessagePayload & {
  __typename?: 'ParcelItemsUpdated';
  deliveryId: Scalars['String']['output'];
  items: Array<DeliveryItem>;
  oldItems: Array<DeliveryItem>;
  parcelId: Scalars['String']['output'];
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ParcelMeasurements = {
  __typename?: 'ParcelMeasurements';
  heightInMillimeter?: Maybe<Scalars['Int']['output']>;
  lengthInMillimeter?: Maybe<Scalars['Int']['output']>;
  weightInGram?: Maybe<Scalars['Int']['output']>;
  widthInMillimeter?: Maybe<Scalars['Int']['output']>;
};

export type ParcelMeasurementsDraftType = {
  heightInMillimeter?: InputMaybe<Scalars['Int']['input']>;
  lengthInMillimeter?: InputMaybe<Scalars['Int']['input']>;
  weightInGram?: InputMaybe<Scalars['Int']['input']>;
  widthInMillimeter?: InputMaybe<Scalars['Int']['input']>;
};

export type ParcelMeasurementsUpdated = MessagePayload & OrderMessagePayload & {
  __typename?: 'ParcelMeasurementsUpdated';
  deliveryId: Scalars['String']['output'];
  measurements?: Maybe<ParcelMeasurements>;
  parcelId: Scalars['String']['output'];
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ParcelRemovedFromDelivery = MessagePayload & OrderMessagePayload & {
  __typename?: 'ParcelRemovedFromDelivery';
  deliveryId: Scalars['String']['output'];
  parcel: Parcel;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ParcelTrackingDataUpdated = MessagePayload & OrderMessagePayload & {
  __typename?: 'ParcelTrackingDataUpdated';
  deliveryId: Scalars['String']['output'];
  parcelId: Scalars['String']['output'];
  shippingKey?: Maybe<Scalars['String']['output']>;
  trackingData?: Maybe<TrackingData>;
  type: Scalars['String']['output'];
};

/**
 * Payments hold information about the current state of receiving and/or refunding money.
 * [documentation](https://docs.commercetools.com/api/projects/payments)
 */
export type Payment = Versioned & {
  __typename?: 'Payment';
  amountPlanned: Money;
  anonymousId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  id: Scalars['String']['output'];
  interfaceId?: Maybe<Scalars['String']['output']>;
  interfaceInteractionsRaw: InterfaceInteractionsRawResult;
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  paymentMethodInfo: PaymentMethodInfo;
  paymentStatus: PaymentStatus;
  transactions: Array<Transaction>;
  version: Scalars['Long']['output'];
};


/**
 * Payments hold information about the current state of receiving and/or refunding money.
 * [documentation](https://docs.commercetools.com/api/projects/payments)
 */
export type PaymentInterfaceInteractionsRawArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type PaymentCreated = MessagePayload & {
  __typename?: 'PaymentCreated';
  payment: Payment;
  type: Scalars['String']['output'];
};

export type PaymentDraft = {
  amountPlanned: MoneyInput;
  anonymousId?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customer?: InputMaybe<ResourceIdentifierInput>;
  interfaceId?: InputMaybe<Scalars['String']['input']>;
  interfaceInteractions?: InputMaybe<Array<CustomFieldsDraft>>;
  key?: InputMaybe<Scalars['String']['input']>;
  paymentMethodInfo?: InputMaybe<PaymentMethodInfoInput>;
  paymentStatus?: InputMaybe<PaymentStatusInput>;
  transactions?: InputMaybe<Array<TransactionDraft>>;
};

export type PaymentInfo = {
  __typename?: 'PaymentInfo';
  paymentRefs: Array<Reference>;
  payments: Array<Payment>;
};

export type PaymentInteractionAdded = MessagePayload & {
  __typename?: 'PaymentInteractionAdded';
  interaction: CustomFieldsType;
  type: Scalars['String']['output'];
};

export type PaymentMethodInfo = {
  __typename?: 'PaymentMethodInfo';
  method?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  paymentInterface?: Maybe<Scalars['String']['output']>;
};


export type PaymentMethodInfoNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type PaymentMethodInfoInput = {
  method?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
  paymentInterface?: InputMaybe<Scalars['String']['input']>;
};

export type PaymentQueryResult = {
  __typename?: 'PaymentQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Payment>;
  total: Scalars['Long']['output'];
};

export enum PaymentState {
  BalanceDue = 'BalanceDue',
  CreditOwed = 'CreditOwed',
  Failed = 'Failed',
  Paid = 'Paid',
  Pending = 'Pending'
}

export type PaymentStatus = {
  __typename?: 'PaymentStatus';
  interfaceCode?: Maybe<Scalars['String']['output']>;
  interfaceText?: Maybe<Scalars['String']['output']>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
};

export type PaymentStatusInput = {
  interfaceCode?: InputMaybe<Scalars['String']['input']>;
  interfaceText?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<ResourceIdentifierInput>;
};

export type PaymentStatusInterfaceCodeSet = MessagePayload & {
  __typename?: 'PaymentStatusInterfaceCodeSet';
  interfaceCode?: Maybe<Scalars['String']['output']>;
  paymentId: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type PaymentStatusStateTransition = MessagePayload & {
  __typename?: 'PaymentStatusStateTransition';
  force: Scalars['Boolean']['output'];
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type PaymentTransactionAdded = MessagePayload & {
  __typename?: 'PaymentTransactionAdded';
  transaction: Transaction;
  type: Scalars['String']['output'];
};

export type PaymentTransactionStateChanged = MessagePayload & {
  __typename?: 'PaymentTransactionStateChanged';
  state: TransactionState;
  transactionId: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type PaymentUpdateAction = {
  addInterfaceInteraction?: InputMaybe<AddPaymentInterfaceInteraction>;
  addTransaction?: InputMaybe<AddPaymentTransaction>;
  changeAmountPlanned?: InputMaybe<ChangePaymentAmountPlanned>;
  changeTransactionInteractionId?: InputMaybe<ChangePaymentTransactionInteractionId>;
  changeTransactionState?: InputMaybe<ChangePaymentTransactionState>;
  changeTransactionTimestamp?: InputMaybe<ChangePaymentTransactionTimestamp>;
  setAmountPaid?: InputMaybe<SetPaymentAmountPaid>;
  setAmountRefunded?: InputMaybe<SetPaymentAmountRefunded>;
  setAnonymousId?: InputMaybe<SetPaymentAnonymousId>;
  setAuthorization?: InputMaybe<SetPaymentAuthorization>;
  setCustomField?: InputMaybe<SetPaymentCustomField>;
  setCustomType?: InputMaybe<SetPaymentCustomType>;
  setCustomer?: InputMaybe<SetPaymentCustomer>;
  setExternalId?: InputMaybe<SetPaymentExternalId>;
  setInterfaceId?: InputMaybe<SetPaymentInterfaceId>;
  setKey?: InputMaybe<SetPaymentKey>;
  setMethodInfoInterface?: InputMaybe<SetPaymentMethodInfoInterface>;
  setMethodInfoMethod?: InputMaybe<SetPaymentMethodInfoMethod>;
  setMethodInfoName?: InputMaybe<SetPaymentMethodInfoName>;
  setStatusInterfaceCode?: InputMaybe<SetPaymentStatusInterfaceCode>;
  setStatusInterfaceText?: InputMaybe<SetPaymentStatusInterfaceText>;
  setTransactionCustomField?: InputMaybe<SetPaymentTransactionCustomField>;
  setTransactionCustomType?: InputMaybe<SetPaymentTransactionCustomType>;
  transitionState?: InputMaybe<TransitionPaymentState>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export enum Permission {
  AcceptMyQuotes = 'AcceptMyQuotes',
  AcceptOthersQuotes = 'AcceptOthersQuotes',
  AddChildUnits = 'AddChildUnits',
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  CreateApprovalRules = 'CreateApprovalRules',
  CreateMyCarts = 'CreateMyCarts',
  CreateMyOrdersFromMyCarts = 'CreateMyOrdersFromMyCarts',
  CreateMyOrdersFromMyQuotes = 'CreateMyOrdersFromMyQuotes',
  CreateMyQuoteRequestsFromMyCarts = 'CreateMyQuoteRequestsFromMyCarts',
  CreateOrdersFromOthersCarts = 'CreateOrdersFromOthersCarts',
  CreateOrdersFromOthersQuotes = 'CreateOrdersFromOthersQuotes',
  CreateOthersCarts = 'CreateOthersCarts',
  CreateQuoteRequestsFromOthersCarts = 'CreateQuoteRequestsFromOthersCarts',
  DeclineMyQuotes = 'DeclineMyQuotes',
  DeclineOthersQuotes = 'DeclineOthersQuotes',
  DeleteMyCarts = 'DeleteMyCarts',
  DeleteOthersCarts = 'DeleteOthersCarts',
  ReassignMyQuotes = 'ReassignMyQuotes',
  ReassignOthersQuotes = 'ReassignOthersQuotes',
  RenegotiateMyQuotes = 'RenegotiateMyQuotes',
  RenegotiateOthersQuotes = 'RenegotiateOthersQuotes',
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  UpdateApprovalFlows = 'UpdateApprovalFlows',
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  UpdateApprovalRules = 'UpdateApprovalRules',
  UpdateAssociates = 'UpdateAssociates',
  UpdateBusinessUnitDetails = 'UpdateBusinessUnitDetails',
  UpdateMyCarts = 'UpdateMyCarts',
  UpdateMyOrders = 'UpdateMyOrders',
  UpdateMyQuoteRequests = 'UpdateMyQuoteRequests',
  UpdateOthersCarts = 'UpdateOthersCarts',
  UpdateOthersOrders = 'UpdateOthersOrders',
  UpdateOthersQuoteRequests = 'UpdateOthersQuoteRequests',
  UpdateParentUnit = 'UpdateParentUnit',
  ViewMyCarts = 'ViewMyCarts',
  ViewMyOrders = 'ViewMyOrders',
  ViewMyQuoteRequests = 'ViewMyQuoteRequests',
  ViewMyQuotes = 'ViewMyQuotes',
  ViewOthersCarts = 'ViewOthersCarts',
  ViewOthersOrders = 'ViewOthersOrders',
  ViewOthersQuoteRequests = 'ViewOthersQuoteRequests',
  ViewOthersQuotes = 'ViewOthersQuotes'
}

export type PlainEnumValue = {
  __typename?: 'PlainEnumValue';
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
};

export type PlainEnumValueDraft = {
  key: Scalars['String']['input'];
  label: Scalars['String']['input'];
};

export type PlainEnumValueResult = {
  __typename?: 'PlainEnumValueResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<PlainEnumValue>;
  total: Scalars['Int']['output'];
};

export type PlatformFormat = NotificationFormat & {
  __typename?: 'PlatformFormat';
  type: Scalars['String']['output'];
};

export type PlatformFormatInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type Point = Geometry & {
  __typename?: 'Point';
  coordinates: Array<Scalars['Float']['output']>;
  type: Scalars['String']['output'];
};

export type PreviewFailure = OrderEditResult & {
  __typename?: 'PreviewFailure';
  errors: Array<Scalars['Json']['output']>;
  type: Scalars['String']['output'];
};

export type PreviewSuccess = OrderEditResult & {
  __typename?: 'PreviewSuccess';
  messagePayloads: Array<OrderMessagePayload>;
  preview: Order;
  type: Scalars['String']['output'];
};

export type PriceFunction = {
  __typename?: 'PriceFunction';
  currencyCode: Scalars['Currency']['output'];
  function: Scalars['String']['output'];
};

export type PriceFunctionDraft = {
  currencyCode: Scalars['Currency']['input'];
  function: Scalars['String']['input'];
};

/**
 * This mode determines which type of Prices the system uses for
 * Product Price Selection as well as for LineItem Price selection
 */
export enum PriceMode {
  /** The system looks up prices from the `prices` field of the ProductVariant inside a Product. */
  Embedded = 'Embedded',
  /** The system looks up prices from Standalone Prices, stored separately from Products. */
  Standalone = 'Standalone'
}

export type PriceSelectorInput = {
  channel?: InputMaybe<ReferenceInput>;
  country?: InputMaybe<Scalars['Country']['input']>;
  currency: Scalars['Currency']['input'];
  customerGroup?: InputMaybe<ReferenceInput>;
  date?: InputMaybe<Scalars['DateTime']['input']>;
};

export type Product = ReferenceExpandable & ReviewTarget & Versioned & {
  __typename?: 'Product';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  masterData: ProductCatalogData;
  priceMode?: Maybe<PriceMode>;
  productSelectionRefs: SelectionOfProductQueryResult;
  productType?: Maybe<ProductTypeDefinition>;
  productTypeRef: Reference;
  reviewRatingStatistics?: Maybe<ReviewRatingStatistics>;
  skus: Array<Scalars['String']['output']>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  version: Scalars['Long']['output'];
};


export type ProductProductSelectionRefsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type ProductAddedToCategory = MessagePayload & {
  __typename?: 'ProductAddedToCategory';
  category: ReferenceId;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

export type ProductAssignment = {
  __typename?: 'ProductAssignment';
  product?: Maybe<Product>;
  productRef: Reference;
  productSelection?: Maybe<ProductSelection>;
  productSelectionRef: Reference;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  variantExclusion?: Maybe<ProductVariantExclusion>;
  variantSelection?: Maybe<ProductVariantSelection>;
};

export type ProductAssignmentQueryResult = {
  __typename?: 'ProductAssignmentQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ProductAssignment>;
  total: Scalars['Long']['output'];
};

/**
 * An input object used to define a ProductAttribute.
 *
 * The value should be passed in a form of escaped JSON.
 *
 *
 * Examples for `value`:
 *
 * * FieldType `String`: `"\"This is a string\""`
 * * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
 * * FieldType `Number`: `"4"`
 * * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
 * * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
 */
export type ProductAttributeInput = {
  name: Scalars['String']['input'];
  /**
   * The value should be passed in a form of escaped JSON.
   *
   *
   * Examples for `value`:
   *
   * * FieldType `String`: `"\"This is a string\""`
   * * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
   * * FieldType `Number`: `"4"`
   * * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
   * * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
   */
  value: Scalars['String']['input'];
};

export type ProductCatalogData = {
  __typename?: 'ProductCatalogData';
  current?: Maybe<ProductData>;
  hasStagedChanges: Scalars['Boolean']['output'];
  published: Scalars['Boolean']['output'];
  staged?: Maybe<ProductData>;
};

export type ProductCreated = MessagePayload & {
  __typename?: 'ProductCreated';
  productProjection: ProductProjectionMessagePayload;
  type: Scalars['String']['output'];
};

export type ProductData = {
  __typename?: 'ProductData';
  allVariants: Array<ProductVariant>;
  categories: Array<Category>;
  categoriesRef: Array<Reference>;
  categoryOrderHint?: Maybe<Scalars['String']['output']>;
  categoryOrderHints: Array<CategoryOrderHint>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  masterVariant: ProductVariant;
  metaDescription?: Maybe<Scalars['String']['output']>;
  metaDescriptionAllLocales?: Maybe<Array<LocalizedString>>;
  metaKeywords?: Maybe<Scalars['String']['output']>;
  metaKeywordsAllLocales?: Maybe<Array<LocalizedString>>;
  metaTitle?: Maybe<Scalars['String']['output']>;
  metaTitleAllLocales?: Maybe<Array<LocalizedString>>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  searchKeyword?: Maybe<Array<SearchKeyword>>;
  searchKeywords: Array<SearchKeywords>;
  skus: Array<Scalars['String']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  variant?: Maybe<ProductVariant>;
  variants: Array<ProductVariant>;
};


export type ProductDataAllVariantsArgs = {
  hasImages?: InputMaybe<Scalars['Boolean']['input']>;
  isOnStock?: InputMaybe<Scalars['Boolean']['input']>;
  skus?: InputMaybe<Array<Scalars['String']['input']>>;
  stockChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type ProductDataCategoryOrderHintArgs = {
  categoryId: Scalars['String']['input'];
};


export type ProductDataDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataMetaDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataMetaKeywordsArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataMetaTitleArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataSearchKeywordArgs = {
  locale: Scalars['Locale']['input'];
};


export type ProductDataSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductDataVariantArgs = {
  key?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
};


export type ProductDataVariantsArgs = {
  hasImages?: InputMaybe<Scalars['Boolean']['input']>;
  isOnStock?: InputMaybe<Scalars['Boolean']['input']>;
  skus?: InputMaybe<Array<Scalars['String']['input']>>;
  stockChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ProductDeleted = MessagePayload & {
  __typename?: 'ProductDeleted';
  currentProjection?: Maybe<ProductProjectionMessagePayload>;
  removedImageUrls: Scalars['Set']['output'];
  type: Scalars['String']['output'];
};

/**
 *
 * A product price can be discounted in two ways:
 *
 * * with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.
 *   A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10€ off). If more than one product discount matches a price, the discount sort order determines which one will be applied.
 * * with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.
 *
 * The discounted price is stored in the discounted field of the Product Price.
 *
 * Note that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.
 *
 * The maximum number of ProductDiscounts that can be active at the same time is **200**.
 *
 */
export type ProductDiscount = ReferenceExpandable & Versioned & {
  __typename?: 'ProductDiscount';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  isActive: Scalars['Boolean']['output'];
  isValid: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  predicate: Scalars['String']['output'];
  referenceRefs: Array<Reference>;
  sortOrder: Scalars['String']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: ProductDiscountValue;
  version: Scalars['Long']['output'];
};


/**
 *
 * A product price can be discounted in two ways:
 *
 * * with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.
 *   A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10€ off). If more than one product discount matches a price, the discount sort order determines which one will be applied.
 * * with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.
 *
 * The discounted price is stored in the discounted field of the Product Price.
 *
 * Note that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.
 *
 * The maximum number of ProductDiscounts that can be active at the same time is **200**.
 *
 */
export type ProductDiscountDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/**
 *
 * A product price can be discounted in two ways:
 *
 * * with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.
 *   A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10€ off). If more than one product discount matches a price, the discount sort order determines which one will be applied.
 * * with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.
 *
 * The discounted price is stored in the discounted field of the Product Price.
 *
 * Note that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.
 *
 * The maximum number of ProductDiscounts that can be active at the same time is **200**.
 *
 */
export type ProductDiscountNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ProductDiscountDraft = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Array<LocalizedStringItemInputType>;
  predicate: Scalars['String']['input'];
  sortOrder: Scalars['String']['input'];
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
  value: ProductDiscountValueInput;
};

export type ProductDiscountLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'ProductDiscountLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type ProductDiscountLimitsProjection = {
  __typename?: 'ProductDiscountLimitsProjection';
  totalActive: ProductDiscountLimitWithCurrent;
};

export type ProductDiscountQueryResult = {
  __typename?: 'ProductDiscountQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ProductDiscount>;
  total: Scalars['Long']['output'];
};

export type ProductDiscountUpdateAction = {
  changeIsActive?: InputMaybe<ChangeProductDiscountIsActive>;
  changeName?: InputMaybe<ChangeProductDiscountName>;
  changePredicate?: InputMaybe<ChangeProductDiscountPredicate>;
  changeSortOrder?: InputMaybe<ChangeProductDiscountSortOrder>;
  changeValue?: InputMaybe<ChangeProductDiscountValue>;
  setDescription?: InputMaybe<SetProductDiscountDescription>;
  setKey?: InputMaybe<SetProductDiscountKey>;
  setValidFrom?: InputMaybe<SetProductDiscountValidFrom>;
  setValidFromAndUntil?: InputMaybe<SetProductDiscountValidFromAndUntil>;
  setValidUntil?: InputMaybe<SetProductDiscountValidUntil>;
};

export type ProductDiscountValue = {
  type: Scalars['String']['output'];
};

export type ProductDiscountValueInput = {
  absolute?: InputMaybe<AbsoluteDiscountValueInput>;
  external?: InputMaybe<ExternalDiscountValueInput>;
  relative?: InputMaybe<RelativeDiscountValueInput>;
};

export type ProductDraft = {
  categories?: InputMaybe<Array<ResourceIdentifierInput>>;
  categoryOrderHints?: InputMaybe<Array<CategoryOrderHintInput>>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  masterVariant?: InputMaybe<ProductVariantInput>;
  metaDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaKeywords?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaTitle?: InputMaybe<Array<LocalizedStringItemInputType>>;
  name: Array<LocalizedStringItemInputType>;
  priceMode?: InputMaybe<PriceMode>;
  productType: ResourceIdentifierInput;
  publish?: InputMaybe<Scalars['Boolean']['input']>;
  searchKeywords?: InputMaybe<Array<SearchKeywordInput>>;
  slug: Array<LocalizedStringItemInputType>;
  state?: InputMaybe<ResourceIdentifierInput>;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
  variants?: InputMaybe<Array<ProductVariantInput>>;
};

export type ProductImageAdded = MessagePayload & {
  __typename?: 'ProductImageAdded';
  image: Image;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductLimitsProjection = {
  __typename?: 'ProductLimitsProjection';
  pricesPerVariant: Limit;
  variants: Limit;
};

export type ProductOfSelection = {
  __typename?: 'ProductOfSelection';
  product?: Maybe<Product>;
  productRef: Reference;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  variantExclusion?: Maybe<ProductVariantExclusion>;
  variantSelection?: Maybe<ProductVariantSelection>;
};

export type ProductOfSelectionQueryResult = {
  __typename?: 'ProductOfSelectionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ProductOfSelection>;
  total: Scalars['Long']['output'];
};

export type ProductPrice = {
  __typename?: 'ProductPrice';
  channel?: Maybe<Channel>;
  channelRef?: Maybe<Reference>;
  country?: Maybe<Scalars['Country']['output']>;
  custom?: Maybe<CustomFieldsType>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  discounted?: Maybe<DiscountedProductPriceValue>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  tiers?: Maybe<Array<ProductPriceTier>>;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: BaseMoney;
};

export type ProductPriceAdded = MessagePayload & {
  __typename?: 'ProductPriceAdded';
  price: ProductPrice;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductPriceChanged = MessagePayload & {
  __typename?: 'ProductPriceChanged';
  newPrice: ProductPrice;
  oldPrice: ProductPrice;
  oldStagedPrice?: Maybe<ProductPrice>;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductPriceDataInput = {
  channel?: InputMaybe<ResourceIdentifierInput>;
  country?: InputMaybe<Scalars['Country']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customerGroup?: InputMaybe<ReferenceInput>;
  discounted?: InputMaybe<DiscountedProductPriceValueInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  tiers?: InputMaybe<Array<ProductPriceTierInput>>;
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
  value: BaseMoneyInput;
};

export type ProductPriceDiscountUpdateMessagePayload = {
  __typename?: 'ProductPriceDiscountUpdateMessagePayload';
  discounted?: Maybe<DiscountedProductPriceValue>;
  priceId: Scalars['String']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  staged: Scalars['Boolean']['output'];
  variantId: Scalars['Int']['output'];
  variantKey?: Maybe<Scalars['String']['output']>;
};

export type ProductPriceDiscountsSet = MessagePayload & {
  __typename?: 'ProductPriceDiscountsSet';
  type: Scalars['String']['output'];
  updatedPrices: Array<ProductPriceDiscountUpdateMessagePayload>;
};

export type ProductPriceExternalDiscountSet = MessagePayload & {
  __typename?: 'ProductPriceExternalDiscountSet';
  discounted?: Maybe<DiscountedProductPriceValue>;
  priceId: Scalars['String']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
  variantKey?: Maybe<Scalars['String']['output']>;
};

export type ProductPriceKeySet = MessagePayload & {
  __typename?: 'ProductPriceKeySet';
  key?: Maybe<Scalars['String']['output']>;
  oldKey?: Maybe<Scalars['String']['output']>;
  priceId?: Maybe<Scalars['String']['output']>;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductPriceModeSet = MessagePayload & {
  __typename?: 'ProductPriceModeSet';
  to?: Maybe<PriceMode>;
  type: Scalars['String']['output'];
};

export type ProductPriceRemoved = MessagePayload & {
  __typename?: 'ProductPriceRemoved';
  price: ProductPrice;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductPriceSearch = {
  __typename?: 'ProductPriceSearch';
  channel?: Maybe<Channel>;
  channelRef?: Maybe<Reference>;
  country?: Maybe<Scalars['Country']['output']>;
  custom?: Maybe<CustomFieldsType>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  discounted?: Maybe<DiscountedProductSearchPriceValue>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  tiers?: Maybe<Array<ProductSearchPriceTier>>;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: BaseMoney;
};

export type ProductPriceTier = {
  __typename?: 'ProductPriceTier';
  minimumQuantity: Scalars['Int']['output'];
  value: BaseMoney;
};

export type ProductPriceTierInput = {
  minimumQuantity: Scalars['Int']['input'];
  value: BaseMoneyInput;
};

export type ProductPricesSet = MessagePayload & {
  __typename?: 'ProductPricesSet';
  prices: Array<ProductPrice>;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variantId: Scalars['Int']['output'];
};

export type ProductProjection = {
  __typename?: 'ProductProjection';
  categories: Array<Category>;
  categoriesRef: Array<Reference>;
  categoryOrderHints: Array<CategoryOrderHintProductSearch>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  hasStagedChanges: Scalars['Boolean']['output'];
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  masterVariant: ProductSearchVariant;
  metaDescription?: Maybe<Scalars['String']['output']>;
  metaDescriptionAllLocales?: Maybe<Array<LocalizedString>>;
  metaKeywords?: Maybe<Scalars['String']['output']>;
  metaKeywordsAllLocales?: Maybe<Array<LocalizedString>>;
  metaTitle?: Maybe<Scalars['String']['output']>;
  metaTitleAllLocales?: Maybe<Array<LocalizedString>>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  productType?: Maybe<ProductTypeDefinition>;
  productTypeRef: Reference;
  published: Scalars['Boolean']['output'];
  reviewRatingStatistics?: Maybe<ReviewRatingStatistics>;
  searchKeywords: Array<SearchKeywordsProductSearch>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  variants: Array<ProductSearchVariant>;
  version: Scalars['Long']['output'];
};


export type ProductProjectionDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMetaDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMetaKeywordsArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMetaTitleArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ProductProjectionMessagePayload = {
  __typename?: 'ProductProjectionMessagePayload';
  categories: Array<Category>;
  categoriesRef: Array<Reference>;
  categoryOrderHints: Array<CategoryOrderHint>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  hasStagedChanges: Scalars['Boolean']['output'];
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  masterVariant: ProductVariant;
  metaDescription?: Maybe<Scalars['String']['output']>;
  metaDescriptionAllLocales?: Maybe<Array<LocalizedString>>;
  metaKeywords?: Maybe<Scalars['String']['output']>;
  metaKeywordsAllLocales?: Maybe<Array<LocalizedString>>;
  metaTitle?: Maybe<Scalars['String']['output']>;
  metaTitleAllLocales?: Maybe<Array<LocalizedString>>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  productType?: Maybe<ProductTypeDefinition>;
  productTypeRef: Reference;
  published: Scalars['Boolean']['output'];
  reviewRatingStatistics?: Maybe<ReviewRatingStatistics>;
  searchKeywords: Array<SearchKeywords>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  variants: Array<ProductVariant>;
  version: Scalars['Long']['output'];
};


export type ProductProjectionMessagePayloadDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMessagePayloadMetaDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMessagePayloadMetaKeywordsArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMessagePayloadMetaTitleArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMessagePayloadNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductProjectionMessagePayloadSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ProductProjectionSearchResult = {
  __typename?: 'ProductProjectionSearchResult';
  count: Scalars['Int']['output'];
  facets: Array<FacetResultValue>;
  offset: Scalars['Int']['output'];
  results: Array<ProductProjection>;
  total: Scalars['Int']['output'];
};

export type ProductPublished = MessagePayload & {
  __typename?: 'ProductPublished';
  productProjection: ProductProjectionMessagePayload;
  removedImageUrls: Array<Scalars['String']['output']>;
  scope: PublishScope;
  type: Scalars['String']['output'];
};

export type ProductQueryResult = {
  __typename?: 'ProductQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Product>;
  total: Scalars['Long']['output'];
};

export type ProductReferenceIdentifier = {
  __typename?: 'ProductReferenceIdentifier';
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  typeId: Scalars['String']['output'];
};

export type ProductRemovedFromCategory = MessagePayload & {
  __typename?: 'ProductRemovedFromCategory';
  category: ReferenceId;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

export type ProductRevertedStagedChanges = MessagePayload & {
  __typename?: 'ProductRevertedStagedChanges';
  removedImageUrls: Scalars['Set']['output'];
  type: Scalars['String']['output'];
};

export type ProductSearchPriceTier = {
  __typename?: 'ProductSearchPriceTier';
  minimumQuantity: Scalars['Int']['output'];
  value: BaseMoney;
};

export type ProductSearchVariant = {
  __typename?: 'ProductSearchVariant';
  assets: Array<Asset>;
  /** This field contains raw attributes data */
  attributesRaw: Array<RawProductSearchAttribute>;
  availability?: Maybe<ProductSearchVariantAvailabilityWithChannels>;
  id: Scalars['Int']['output'];
  images: Array<ImageProductSearch>;
  isMatchingVariant?: Maybe<Scalars['Boolean']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  /** Returns a single price based on the price selection rules. */
  price?: Maybe<ProductPriceSearch>;
  prices?: Maybe<Array<ProductPriceSearch>>;
  scopedPrice?: Maybe<ScopedPrice>;
  scopedPriceDiscounted?: Maybe<Scalars['Boolean']['output']>;
  sku?: Maybe<Scalars['String']['output']>;
};


export type ProductSearchVariantAttributesRawArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type ProductSearchVariantPriceArgs = {
  channelId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['Country']['input']>;
  currency: Scalars['Currency']['input'];
  customerGroupId?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Product variant availabilities */
export type ProductSearchVariantAvailabilitiesResult = {
  __typename?: 'ProductSearchVariantAvailabilitiesResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<ProductSearchVariantAvailabilityWithChannel>;
  total: Scalars['Int']['output'];
};

/** Product variant availability */
export type ProductSearchVariantAvailability = {
  __typename?: 'ProductSearchVariantAvailability';
  availableQuantity?: Maybe<Scalars['Long']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isOnStock: Scalars['Boolean']['output'];
  restockableInDays?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Long']['output']>;
};

export type ProductSearchVariantAvailabilityWithChannel = {
  __typename?: 'ProductSearchVariantAvailabilityWithChannel';
  availability: ProductSearchVariantAvailability;
  channel?: Maybe<Channel>;
  channelRef: Reference;
};

export type ProductSearchVariantAvailabilityWithChannels = {
  __typename?: 'ProductSearchVariantAvailabilityWithChannels';
  channels: ProductSearchVariantAvailabilitiesResult;
  noChannel?: Maybe<ProductSearchVariantAvailability>;
};


export type ProductSearchVariantAvailabilityWithChannelsChannelsArgs = {
  excludeChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  includeChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ProductSelection = Versioned & {
  __typename?: 'ProductSelection';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  mode: ProductSelectionMode;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  productCount: Scalars['Int']['output'];
  productRefs: ProductOfSelectionQueryResult;
  version: Scalars['Long']['output'];
};


export type ProductSelectionNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductSelectionProductRefsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type ProductSelectionCreated = MessagePayload & {
  __typename?: 'ProductSelectionCreated';
  productSelection: ProductSelection;
  type: Scalars['String']['output'];
};

export type ProductSelectionDeleted = MessagePayload & {
  __typename?: 'ProductSelectionDeleted';
  type: Scalars['String']['output'];
};

export enum ProductSelectionMode {
  /** Mode of Product Selection used to include a specific list of individual Products */
  Individual = 'Individual',
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta. Mode of Product Selection used to exclude a specific list of individual Products */
  IndividualExclusion = 'IndividualExclusion'
}

export type ProductSelectionProductAdded = MessagePayload & {
  __typename?: 'ProductSelectionProductAdded';
  product?: Maybe<Product>;
  productRef: Reference;
  type: Scalars['String']['output'];
  variantSelection?: Maybe<ProductVariantSelection>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type ProductSelectionProductExcluded = MessagePayload & {
  __typename?: 'ProductSelectionProductExcluded';
  product?: Maybe<Product>;
  productRef: Reference;
  type: Scalars['String']['output'];
  variantExclusion?: Maybe<ProductVariantExclusion>;
};

export type ProductSelectionProductRemoved = MessagePayload & {
  __typename?: 'ProductSelectionProductRemoved';
  product?: Maybe<Product>;
  productRef: Reference;
  type: Scalars['String']['output'];
};

/** Fields to access product selection assignments. */
export type ProductSelectionQueryInterface = {
  productSelectionAssignments: ProductAssignmentQueryResult;
};


/** Fields to access product selection assignments. */
export type ProductSelectionQueryInterfaceProductSelectionAssignmentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type ProductSelectionQueryResult = {
  __typename?: 'ProductSelectionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ProductSelection>;
  total: Scalars['Long']['output'];
};

export type ProductSelectionSetting = {
  __typename?: 'ProductSelectionSetting';
  active: Scalars['Boolean']['output'];
  productSelection?: Maybe<ProductSelection>;
  productSelectionRef: Reference;
};

export type ProductSelectionSettingDraft = {
  active: Scalars['Boolean']['input'];
  productSelection: ResourceIdentifierInput;
};

export type ProductSelectionSettingInActionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  productSelection: ResourceIdentifierInput;
};

export type ProductSelectionUpdateAction = {
  addProduct?: InputMaybe<AddProductSelectionProduct>;
  changeName?: InputMaybe<ChangeProductSelectionName>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  excludeProduct?: InputMaybe<ExcludeProductSelectionProduct>;
  removeProduct?: InputMaybe<RemoveProductSelectionProduct>;
  setCustomField?: InputMaybe<SetProductSelectionCustomField>;
  setCustomType?: InputMaybe<SetProductSelectionCustomType>;
  setKey?: InputMaybe<SetProductSelectionKey>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  setVariantExclusion?: InputMaybe<SetProductSelectionVariantExclusion>;
  setVariantSelection?: InputMaybe<SetProductSelectionVariantSelection>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type ProductSelectionVariantExclusionChanged = MessagePayload & {
  __typename?: 'ProductSelectionVariantExclusionChanged';
  newVariantExclusion?: Maybe<ProductVariantExclusion>;
  oldVariantExclusion?: Maybe<ProductVariantExclusion>;
  product?: Maybe<Product>;
  productRef: Reference;
  type: Scalars['String']['output'];
};

export type ProductSelectionVariantSelectionChanged = MessagePayload & {
  __typename?: 'ProductSelectionVariantSelectionChanged';
  newVariantSelection?: Maybe<ProductVariantSelection>;
  oldVariantSelection?: Maybe<ProductVariantSelection>;
  product?: Maybe<Product>;
  productRef: Reference;
  type: Scalars['String']['output'];
};

export type ProductSlugChanged = MessagePayload & {
  __typename?: 'ProductSlugChanged';
  oldSlug?: Maybe<Scalars['String']['output']>;
  oldSlugAllLocales?: Maybe<Array<LocalizedString>>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales: Array<LocalizedString>;
  type: Scalars['String']['output'];
};


export type ProductSlugChangedOldSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ProductSlugChangedSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ProductStateTransition = MessagePayload & {
  __typename?: 'ProductStateTransition';
  force: Scalars['Boolean']['output'];
  state?: Maybe<State>;
  stateRef: Reference;
  type: Scalars['String']['output'];
};

export type ProductTypeDefinition = ReferenceExpandable & Versioned & {
  __typename?: 'ProductTypeDefinition';
  attributeDefinitions: AttributeDefinitionResult;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description: Scalars['String']['output'];
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};


export type ProductTypeDefinitionAttributeDefinitionsArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ProductTypeDefinitionQueryResult = {
  __typename?: 'ProductTypeDefinitionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ProductTypeDefinition>;
  total: Scalars['Long']['output'];
};

export type ProductTypeDraft = {
  attributeDefinitions?: InputMaybe<Array<AttributeDefinitionDraft>>;
  description: Scalars['String']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

export type ProductTypeLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'ProductTypeLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type ProductTypeLimitsProjection = {
  __typename?: 'ProductTypeLimitsProjection';
  total: ProductTypeLimitWithCurrent;
};

export type ProductTypeUpdateAction = {
  addAttributeDefinition?: InputMaybe<AddAttributeDefinition>;
  addLocalizedEnumValue?: InputMaybe<AddLocalizedEnumValue>;
  addPlainEnumValue?: InputMaybe<AddPlainEnumValue>;
  changeAttributeName?: InputMaybe<ChangeAttributeName>;
  changeAttributeOrder?: InputMaybe<ChangeAttributeOrder>;
  changeAttributeOrderByName?: InputMaybe<ChangeAttributeOrderByName>;
  changeDescription?: InputMaybe<ChangeDescription>;
  changeEnumKey?: InputMaybe<ChangeEnumKey>;
  changeInputHint?: InputMaybe<ChangeInputHint>;
  changeIsSearchable?: InputMaybe<ChangeIsSearchable>;
  changeLabel?: InputMaybe<ChangeLabel>;
  changeLocalizedEnumValueLabel?: InputMaybe<ChangeLocalizedEnumValueLabel>;
  changeLocalizedEnumValueOrder?: InputMaybe<ChangeLocalizedEnumValueOrder>;
  changeName?: InputMaybe<ChangeName>;
  changePlainEnumValueLabel?: InputMaybe<ChangePlainEnumValueLabel>;
  changePlainEnumValueOrder?: InputMaybe<ChangePlainEnumValueOrder>;
  removeAttributeDefinition?: InputMaybe<RemoveAttributeDefinition>;
  removeEnumValues?: InputMaybe<RemoveEnumValues>;
  setInputTip?: InputMaybe<SetInputTip>;
  setKey?: InputMaybe<SetKey>;
};

export type ProductUnpublished = MessagePayload & {
  __typename?: 'ProductUnpublished';
  type: Scalars['String']['output'];
};

export type ProductUpdateAction = {
  addAsset?: InputMaybe<AddProductAsset>;
  addExternalImage?: InputMaybe<AddProductExternalImage>;
  addPrice?: InputMaybe<AddProductPrice>;
  addToCategory?: InputMaybe<AddProductToCategory>;
  addVariant?: InputMaybe<AddProductVariant>;
  changeAssetName?: InputMaybe<ChangeProductAssetName>;
  changeAssetOrder?: InputMaybe<ChangeProductAssetOrder>;
  changeImageLabel?: InputMaybe<ChangeProductImageLabel>;
  changeMasterVariant?: InputMaybe<ChangeProductMasterVariant>;
  changeName?: InputMaybe<ChangeProductName>;
  changePrice?: InputMaybe<ChangeProductPrice>;
  changeSlug?: InputMaybe<ChangeProductSlug>;
  moveImageToPosition?: InputMaybe<MoveProductImageToPosition>;
  publish?: InputMaybe<PublishProduct>;
  removeAsset?: InputMaybe<RemoveProductAsset>;
  removeFromCategory?: InputMaybe<RemoveProductFromCategory>;
  removeImage?: InputMaybe<RemoveProductImage>;
  removePrice?: InputMaybe<RemoveProductPrice>;
  removeVariant?: InputMaybe<RemoveProductVariant>;
  revertStagedChanges?: InputMaybe<RevertStagedChanges>;
  revertStagedVariantChanges?: InputMaybe<RevertStagedVariantChanges>;
  setAssetCustomField?: InputMaybe<SetProductAssetCustomField>;
  setAssetCustomType?: InputMaybe<SetProductAssetCustomType>;
  setAssetDescription?: InputMaybe<SetProductAssetDescription>;
  setAssetKey?: InputMaybe<SetProductAssetKey>;
  setAssetSources?: InputMaybe<SetProductAssetSources>;
  setAssetTags?: InputMaybe<SetProductAssetTags>;
  setAttribute?: InputMaybe<SetProductAttribute>;
  setAttributeInAllVariants?: InputMaybe<SetProductAttributeInAllVariants>;
  setCategoryOrderHint?: InputMaybe<SetProductCategoryOrderHint>;
  setDescription?: InputMaybe<SetProductDescription>;
  setDiscountedPrice?: InputMaybe<SetProductDiscountedPrice>;
  setImageLabel?: InputMaybe<SetProductImageLabel>;
  setKey?: InputMaybe<SetProductKey>;
  setMetaAttributes?: InputMaybe<SetProductMetaAttributes>;
  setMetaDescription?: InputMaybe<SetProductMetaDescription>;
  setMetaKeywords?: InputMaybe<SetProductMetaKeywords>;
  setMetaTitle?: InputMaybe<SetProductMetaTitle>;
  setPriceKey?: InputMaybe<SetProductPriceKey>;
  setPriceMode?: InputMaybe<SetProductPriceMode>;
  setPrices?: InputMaybe<SetProductPrices>;
  setProductPriceCustomField?: InputMaybe<SetProductPriceCustomField>;
  setProductPriceCustomType?: InputMaybe<SetProductPriceCustomType>;
  setProductVariantKey?: InputMaybe<SetProductVariantKey>;
  setSearchKeywords?: InputMaybe<SetSearchKeywords>;
  setSku?: InputMaybe<SetProductSku>;
  setTaxCategory?: InputMaybe<SetProductTaxCategory>;
  transitionState?: InputMaybe<TransitionProductState>;
  unpublish?: InputMaybe<UnpublishProduct>;
};

export type ProductVariant = {
  __typename?: 'ProductVariant';
  assets: Array<Asset>;
  /** This field contains raw attributes data */
  attributesRaw: Array<RawProductAttribute>;
  availability?: Maybe<ProductVariantAvailabilityWithChannels>;
  id: Scalars['Int']['output'];
  images: Array<Image>;
  key?: Maybe<Scalars['String']['output']>;
  /** Returns a single price based on the price selection rules. */
  price?: Maybe<ProductPrice>;
  prices?: Maybe<Array<ProductPrice>>;
  sku?: Maybe<Scalars['String']['output']>;
};


export type ProductVariantAttributesRawArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type ProductVariantPriceArgs = {
  channelId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['Country']['input']>;
  currency: Scalars['Currency']['input'];
  customerGroupId?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantAdded = MessagePayload & {
  __typename?: 'ProductVariantAdded';
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  variant: ProductVariant;
};

/** Product variant availabilities */
export type ProductVariantAvailabilitiesResult = {
  __typename?: 'ProductVariantAvailabilitiesResult';
  limit?: Maybe<Scalars['Int']['output']>;
  offset?: Maybe<Scalars['Int']['output']>;
  results: Array<ProductVariantAvailabilityWithChannel>;
  total: Scalars['Int']['output'];
};

/** Product variant availability */
export type ProductVariantAvailability = {
  __typename?: 'ProductVariantAvailability';
  availableQuantity?: Maybe<Scalars['Long']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isOnStock: Scalars['Boolean']['output'];
  restockableInDays?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Long']['output']>;
};

export type ProductVariantAvailabilityWithChannel = {
  __typename?: 'ProductVariantAvailabilityWithChannel';
  availability: ProductVariantAvailability;
  channel?: Maybe<Channel>;
  channelRef: Reference;
};

export type ProductVariantAvailabilityWithChannels = {
  __typename?: 'ProductVariantAvailabilityWithChannels';
  channels: ProductVariantAvailabilitiesResult;
  noChannel?: Maybe<ProductVariantAvailability>;
};


export type ProductVariantAvailabilityWithChannelsChannelsArgs = {
  excludeChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  includeChannelIds?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export type ProductVariantDeleted = MessagePayload & {
  __typename?: 'ProductVariantDeleted';
  removedImageUrls: Scalars['Set']['output'];
  staged?: Maybe<Scalars['Boolean']['output']>;
  type: Scalars['String']['output'];
  variant?: Maybe<ProductVariant>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type ProductVariantExclusion = {
  __typename?: 'ProductVariantExclusion';
  skus: Array<Scalars['String']['output']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type ProductVariantExclusionDraft = {
  skus?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ProductVariantImportDraft = {
  attributes?: InputMaybe<Array<ProductAttributeInput>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  images?: InputMaybe<Array<ImageInput>>;
  prices?: InputMaybe<Array<ProductPriceDataInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

export type ProductVariantInput = {
  assets?: InputMaybe<Array<AssetDraftInput>>;
  attributes?: InputMaybe<Array<ProductAttributeInput>>;
  images?: InputMaybe<Array<ImageInput>>;
  key?: InputMaybe<Scalars['String']['input']>;
  prices?: InputMaybe<Array<ProductPriceDataInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
};

export type ProductVariantSelection = {
  skus: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ProductVariantSelectionDraft = {
  includeAllExcept?: InputMaybe<Array<Scalars['String']['input']>>;
  includeOnly?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ProductVariantSelectionIncludeAllExcept = ProductVariantSelection & {
  __typename?: 'ProductVariantSelectionIncludeAllExcept';
  skus: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type ProductVariantSelectionIncludeOnly = ProductVariantSelection & {
  __typename?: 'ProductVariantSelectionIncludeOnly';
  skus: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

/** Contains information about the limits of your project. */
export type ProjectCustomLimitsProjection = {
  __typename?: 'ProjectCustomLimitsProjection';
  attributeGroups: AttributeGroupLimitsProjection;
  cartDiscounts: CartDiscountLimitsProjection;
  carts: CartLimitsProjection;
  category: CategoryLimitsProjection;
  customObjects: CustomObjectLimitsProjection;
  customerGroups: CustomerGroupLimitsProjection;
  customers: CustomerLimitsProjection;
  extensions: ExtensionLimitsProjection;
  orderEdits: OrderEditLimitsProjection;
  productDiscounts: ProductDiscountLimitsProjection;
  productType: ProductTypeLimitsProjection;
  products: ProductLimitsProjection;
  query: QueryLimitsProjection;
  refreshTokens: RefreshTokenLimitsProjection;
  search: SearchLimitsProjection;
  shippingMethods: ShippingMethodLimitsProjection;
  shoppingLists: ShoppingListLimitsProjection;
  stores: StoreLimitsProjection;
  subscriptions: SubscriptionsLimitsProjection;
  taxCategories: TaxCategoryLimitsProjection;
  zones: ZoneLimitsProjection;
};

/** Project contains information about project. */
export type ProjectProjection = {
  __typename?: 'ProjectProjection';
  businessUnits?: Maybe<BusinessUnitConfiguration>;
  carts: CartsConfiguration;
  countries: Array<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  currencies: Array<Scalars['Currency']['output']>;
  externalOAuth?: Maybe<ExternalOAuth>;
  key: Scalars['String']['output'];
  languages: Array<Scalars['Locale']['output']>;
  lastModifiedAt?: Maybe<Scalars['DateTime']['output']>;
  lastModifiedBy?: Maybe<Initiator>;
  messages: MessagesConfiguration;
  name: Scalars['String']['output'];
  searchIndexing?: Maybe<SearchIndexingConfiguration>;
  shippingRateInputType?: Maybe<ShippingRateInputType>;
  shoppingLists: ShoppingListsConfiguration;
  trialUntil?: Maybe<Scalars['YearMonth']['output']>;
  version: Scalars['Long']['output'];
};

export type ProjectSettingsUpdateAction = {
  changeCartsConfiguration?: InputMaybe<ChangeProjectSettingsCartsConfiguration>;
  changeCountries?: InputMaybe<ChangeProjectSettingsCountries>;
  changeCountryTaxRateFallbackEnabled?: InputMaybe<ChangeProjectSettingsCountryTaxRateFallbackEnabled>;
  changeCurrencies?: InputMaybe<ChangeProjectSettingsCurrencies>;
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  changeCustomerSearchStatus?: InputMaybe<ChangeProjectSettingsCustomerSearchStatus>;
  changeLanguages?: InputMaybe<ChangeProjectSettingsLanguages>;
  changeMessagesConfiguration?: InputMaybe<ChangeProjectSettingsMessagesConfiguration>;
  changeMessagesEnabled?: InputMaybe<ChangeProjectSettingsMessagesEnabled>;
  changeMyBusinessUnitStatusOnCreation?: InputMaybe<ChangeProjectSettingsMyBusinessUnitStatusOnCreation>;
  changeName?: InputMaybe<ChangeProjectSettingsName>;
  changeOrderSearchStatus?: InputMaybe<ChangeProjectSettingsOrderSearchStatus>;
  changeProductSearchIndexingEnabled?: InputMaybe<ChangeProjectSettingsProductSearchIndexingEnabled>;
  changeShoppingListsConfiguration?: InputMaybe<ChangeProjectSettingsShoppingListsConfiguration>;
  changeStandalonePriceSearchIndexingEnabled?: InputMaybe<ChangeProjectSettingsStandalonePriceSearchIndexingEnabled>;
  setExternalOAuth?: InputMaybe<SetProjectSettingsExternalOAuth>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  setMyBusinessUnitAssociateRoleOnCreation?: InputMaybe<SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation>;
  setShippingRateInputType?: InputMaybe<SetProjectSettingsShippingRateInputType>;
};

export type PublishProduct = {
  scope?: InputMaybe<PublishScope>;
};

export enum PublishScope {
  /** Publishes the complete staged projection */
  All = 'All',
  /** Publishes only prices on the staged projection */
  Prices = 'Prices'
}

export type PurchaseOrderNumberSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'PurchaseOrderNumberSet';
  oldPurchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type Query = CartQueryInterface & CustomerActiveCartInterface & CustomerQueryInterface & MeFieldInterface & OrderQueryInterface & ProductSelectionQueryInterface & ShippingMethodsByCartInterface & ShoppingListQueryInterface & {
  __typename?: 'Query';
  apiClient?: Maybe<ApiClientWithoutSecret>;
  apiClients: ApiClientWithoutSecretQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  asAssociate: AsAssociate;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRole?: Maybe<AssociateRole>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  associateRoles: AssociateRoleQueryResult;
  attributeGroup?: Maybe<AttributeGroup>;
  attributeGroups: AttributeGroupQueryResult;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnit?: Maybe<BusinessUnit>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  businessUnits: BusinessUnitQueryResult;
  cart?: Maybe<Cart>;
  cartDiscount?: Maybe<CartDiscount>;
  cartDiscounts: CartDiscountQueryResult;
  carts: CartQueryResult;
  categories: CategoryQueryResult;
  category?: Maybe<Category>;
  /** Autocomplete the categories based on category fields like name, description, etc. */
  categoryAutocomplete: CategorySearchResult;
  /** Search the categories using full-text search, filtering and sorting */
  categorySearch: CategorySearchResult;
  channel?: Maybe<Channel>;
  channels: ChannelQueryResult;
  customObject?: Maybe<CustomObject>;
  customObjects: CustomObjectQueryResult;
  customer?: Maybe<Customer>;
  customerActiveCart?: Maybe<Cart>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroups: CustomerGroupQueryResult;
  customers: CustomerQueryResult;
  discountCode?: Maybe<DiscountCode>;
  discountCodes: DiscountCodeQueryResult;
  extension?: Maybe<Extension>;
  extensions: ExtensionQueryResult;
  /** This field gives access to the resources (such as carts) that are inside the given store. */
  inStore: InStore;
  /** This field gives access to the resources (such as carts) that are inside one of the given stores. */
  inStores: InStore;
  inventoryEntries: InventoryEntryQueryResult;
  inventoryEntry?: Maybe<InventoryEntry>;
  limits: ProjectCustomLimitsProjection;
  /**
   * This field can only be used with an access token created with the password flow or with an anonymous session.
   *
   * It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
   */
  me: Me;
  message?: Maybe<Message>;
  messages: MessageQueryResult;
  mmuCustomersQuery?: Maybe<Customer>;
  order?: Maybe<Order>;
  orderEdit?: Maybe<OrderEdit>;
  orderEdits: OrderEditQueryResult;
  orders: OrderQueryResult;
  payment?: Maybe<Payment>;
  payments: PaymentQueryResult;
  product?: Maybe<Product>;
  productDiscount?: Maybe<ProductDiscount>;
  productDiscounts: ProductDiscountQueryResult;
  productProjectionSearch: ProductProjectionSearchResult;
  productProjectionsSuggest: SuggestResult;
  productSelection?: Maybe<ProductSelection>;
  productSelectionAssignments: ProductAssignmentQueryResult;
  productSelections: ProductSelectionQueryResult;
  productType?: Maybe<ProductTypeDefinition>;
  productTypes: ProductTypeDefinitionQueryResult;
  products: ProductQueryResult;
  project: ProjectProjection;
  quote?: Maybe<Quote>;
  quoteRequest?: Maybe<QuoteRequest>;
  quoteRequests: QuoteRequestQueryResult;
  quotes: QuoteQueryResult;
  review?: Maybe<Review>;
  reviews: ReviewQueryResult;
  shippingMethod?: Maybe<ShippingMethod>;
  shippingMethods: ShippingMethodQueryResult;
  shippingMethodsByCart: Array<ShippingMethod>;
  shippingMethodsByLocation: Array<ShippingMethod>;
  shoppingList?: Maybe<ShoppingList>;
  shoppingLists: ShoppingListQueryResult;
  stagedQuote?: Maybe<StagedQuote>;
  stagedQuotes: StagedQuoteQueryResult;
  /**
   * StandalonePrices are managed and queried through the StandalonePrices API
   * and associated to a ProductVariant through the sku field.
   */
  standalonePrice?: Maybe<StandalonePrice>;
  /**
   * StandalonePrices are managed and queried through the StandalonePrices API
   * and associated to a ProductVariant through the sku field.
   */
  standalonePrices: StandalonePriceQueryResult;
  state?: Maybe<State>;
  states: StateQueryResult;
  store?: Maybe<Store>;
  stores: StoreQueryResult;
  subscription?: Maybe<CommercetoolsSubscription>;
  subscriptions: CommercetoolsSubscriptionQueryResult;
  taxCategories: TaxCategoryQueryResult;
  taxCategory?: Maybe<TaxCategory>;
  typeDefinition?: Maybe<TypeDefinition>;
  typeDefinitions: TypeDefinitionQueryResult;
  zone?: Maybe<Zone>;
  zones: ZoneQueryResult;
};


export type QueryApiClientArgs = {
  id: Scalars['String']['input'];
};


export type QueryApiClientsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAsAssociateArgs = {
  associateId: Scalars['String']['input'];
  businessUnitKey: Scalars['KeyReferenceInput']['input'];
};


export type QueryAssociateRoleArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAssociateRolesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAttributeGroupArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAttributeGroupsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryBusinessUnitArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryBusinessUnitsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCartArgs = {
  id: Scalars['String']['input'];
};


export type QueryCartDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCartDiscountsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCartsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCategoriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCategoryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCategoryAutocompleteArgs = {
  filters?: InputMaybe<Array<Scalars['SearchFilter']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  locale: Scalars['Locale']['input'];
  offset?: InputMaybe<Scalars['Int']['input']>;
  text: Scalars['String']['input'];
};


export type QueryCategorySearchArgs = {
  filters?: InputMaybe<Array<Scalars['SearchFilter']['input']>>;
  fulltext?: InputMaybe<LocalizedText>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  queryFilters?: InputMaybe<Array<Scalars['SearchFilter']['input']>>;
  sorts?: InputMaybe<Array<Scalars['SearchSort']['input']>>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryChannelsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomObjectArgs = {
  container?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomObjectsArgs = {
  container: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomerArgs = {
  emailToken?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  passwordToken?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomerActiveCartArgs = {
  customerId: Scalars['String']['input'];
};


export type QueryCustomerGroupArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomerGroupsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCustomersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryDiscountCodeArgs = {
  id: Scalars['String']['input'];
};


export type QueryDiscountCodesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryExtensionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryExtensionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryInStoreArgs = {
  key: Scalars['KeyReferenceInput']['input'];
};


export type QueryInStoresArgs = {
  keys: Array<Scalars['KeyReferenceInput']['input']>;
};


export type QueryInventoryEntriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryInventoryEntryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMessageArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMessagesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMmuCustomersQueryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOrderArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOrderEditArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOrderEditsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPaymentArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPaymentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  localeProjection?: InputMaybe<Array<Scalars['Locale']['input']>>;
  projectExpandedProducts?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  variantKey?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductDiscountArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductDiscountsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductProjectionSearchArgs = {
  facetFilters?: InputMaybe<Array<SearchFilterInput>>;
  facets?: InputMaybe<Array<SearchFacetInput>>;
  filters?: InputMaybe<Array<SearchFilterInput>>;
  fuzzy?: InputMaybe<Scalars['Boolean']['input']>;
  fuzzyLevel?: InputMaybe<Scalars['Int']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  localeProjection?: InputMaybe<Array<Scalars['Locale']['input']>>;
  markMatchingVariant?: InputMaybe<Scalars['Boolean']['input']>;
  markMatchingVariants?: InputMaybe<Scalars['Boolean']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  priceSelector?: InputMaybe<PriceSelectorInput>;
  projectExpandedProducts?: InputMaybe<Scalars['Boolean']['input']>;
  queryFilters?: InputMaybe<Array<SearchFilterInput>>;
  sorts?: InputMaybe<Array<Scalars['String']['input']>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  storeProjection?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductProjectionsSuggestArgs = {
  fuzzy?: InputMaybe<Scalars['Boolean']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  searchKeywords: Array<SearchKeywordArgument>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryProductSelectionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductSelectionAssignmentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductSelectionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductTypeArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryProductsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  localeProjection?: InputMaybe<Array<Scalars['Locale']['input']>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  projectExpandedProducts?: InputMaybe<Scalars['Boolean']['input']>;
  skus?: InputMaybe<Array<Scalars['String']['input']>>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryQuoteRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryQuoteRequestsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryQuotesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryReviewArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryReviewsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryShippingMethodArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryShippingMethodsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryShippingMethodsByCartArgs = {
  id: Scalars['String']['input'];
};


export type QueryShippingMethodsByLocationArgs = {
  country: Scalars['Country']['input'];
  currency?: InputMaybe<Scalars['Currency']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};


export type QueryShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStagedQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStagedQuotesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStandalonePriceArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStandalonePricesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStateArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStatesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStoreArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryStoresArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySubscriptionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySubscriptionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTaxCategoriesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTaxCategoryArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTypeDefinitionArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTypeDefinitionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};


export type QueryZoneArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


export type QueryZonesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type QueryLimitsProjection = {
  __typename?: 'QueryLimitsProjection';
  offset: Limit;
};

export type Quote = Versioned & {
  __typename?: 'Quote';
  billingAddress?: Maybe<Address>;
  businessUnit?: Maybe<BusinessUnit>;
  businessUnitRef?: Maybe<KeyReference>;
  buyerComment?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customLineItems: Array<CustomLineItem>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  directDiscounts: Array<DirectDiscount>;
  id: Scalars['String']['output'];
  inventoryMode: InventoryMode;
  itemShippingAddresses: Array<Address>;
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lineItems: Array<LineItem>;
  paymentInfo?: Maybe<PaymentInfo>;
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  quoteRequest?: Maybe<QuoteRequest>;
  quoteRequestRef: Reference;
  quoteState: QuoteState;
  sellerComment?: Maybe<Scalars['String']['output']>;
  shippingAddress?: Maybe<Address>;
  shippingInfo?: Maybe<ShippingInfo>;
  shippingRateInput?: Maybe<ShippingRateInput>;
  stagedQuote?: Maybe<StagedQuote>;
  stagedQuoteRef: Reference;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  taxCalculationMode: TaxCalculationMode;
  taxMode: TaxMode;
  taxRoundingMode: RoundingMode;
  taxedPrice?: Maybe<TaxedPrice>;
  totalPrice: Money;
  validTo?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['Long']['output'];
};


export type QuoteLineItemsArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type QuoteDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  stagedQuote?: InputMaybe<ResourceIdentifierInput>;
  stagedQuoteStateToSent?: InputMaybe<Scalars['Boolean']['input']>;
  stagedQuoteVersion?: InputMaybe<Scalars['Long']['input']>;
  state?: InputMaybe<ReferenceInput>;
};

/** Fields to access Quotes. */
export type QuoteQueryInterface = {
  quote?: Maybe<Quote>;
  quotes: QuoteQueryResult;
};


/** Fields to access Quotes. */
export type QuoteQueryInterfaceQuoteArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access Quotes. */
export type QuoteQueryInterfaceQuotesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type QuoteQueryResult = {
  __typename?: 'QuoteQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Quote>;
  total: Scalars['Long']['output'];
};

export type QuoteRequest = Versioned & {
  __typename?: 'QuoteRequest';
  billingAddress?: Maybe<Address>;
  businessUnit?: Maybe<BusinessUnit>;
  businessUnitRef?: Maybe<KeyReference>;
  comment?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customLineItems: Array<CustomLineItem>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  directDiscounts: Array<DirectDiscount>;
  id: Scalars['String']['output'];
  inventoryMode: InventoryMode;
  itemShippingAddresses: Array<Address>;
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lineItems: Array<LineItem>;
  paymentInfo?: Maybe<PaymentInfo>;
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  quoteRequestState: QuoteRequestState;
  shippingAddress?: Maybe<Address>;
  shippingInfo?: Maybe<ShippingInfo>;
  shippingRateInput?: Maybe<ShippingRateInput>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  taxCalculationMode: TaxCalculationMode;
  taxMode: TaxMode;
  taxRoundingMode: RoundingMode;
  taxedPrice?: Maybe<TaxedPrice>;
  totalPrice: Money;
  version: Scalars['Long']['output'];
};


export type QuoteRequestLineItemsArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type QuoteRequestDraft = {
  cart?: InputMaybe<ResourceIdentifierInput>;
  cartVersion?: InputMaybe<Scalars['Long']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderNumber?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<ReferenceInput>;
};

/** Fields to access QuoteRequests. */
export type QuoteRequestQueryInterface = {
  quoteRequest?: Maybe<QuoteRequest>;
  quoteRequests: QuoteRequestQueryResult;
};


/** Fields to access QuoteRequests. */
export type QuoteRequestQueryInterfaceQuoteRequestArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access QuoteRequests. */
export type QuoteRequestQueryInterfaceQuoteRequestsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type QuoteRequestQueryResult = {
  __typename?: 'QuoteRequestQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<QuoteRequest>;
  total: Scalars['Long']['output'];
};

export enum QuoteRequestState {
  Accepted = 'Accepted',
  Cancelled = 'Cancelled',
  Closed = 'Closed',
  Rejected = 'Rejected',
  Submitted = 'Submitted',
  UnderReview = 'UnderReview'
}

export type QuoteRequestUpdateAction = {
  changeCustomer?: InputMaybe<ChangeQuoteRequestCustomer>;
  changeQuoteRequestState?: InputMaybe<ChangeQuoteRequestState>;
  setCustomField?: InputMaybe<SetQuoteRequestCustomField>;
  setCustomType?: InputMaybe<SetQuoteRequestCustomType>;
  transitionState?: InputMaybe<TransitionQuoteRequestState>;
};

export enum QuoteState {
  Accepted = 'Accepted',
  Declined = 'Declined',
  DeclinedForRenegotiation = 'DeclinedForRenegotiation',
  Failed = 'Failed',
  Pending = 'Pending',
  RenegotiationAddressed = 'RenegotiationAddressed',
  Withdrawn = 'Withdrawn'
}

export type QuoteUpdateAction = {
  changeCustomer?: InputMaybe<ChangeQuoteCustomer>;
  changeQuoteState?: InputMaybe<ChangeQuoteState>;
  requestQuoteRenegotiation?: InputMaybe<RequestQuoteRenegotiation>;
  setCustomField?: InputMaybe<SetQuoteCustomField>;
  setCustomType?: InputMaybe<SetQuoteCustomType>;
  transitionState?: InputMaybe<TransitionQuoteState>;
};

export type RangeCount = {
  type: Scalars['String']['output'];
};

export type RangeCountDouble = RangeCount & {
  __typename?: 'RangeCountDouble';
  count: Scalars['Int']['output'];
  from: Scalars['Float']['output'];
  fromStr: Scalars['String']['output'];
  max: Scalars['Float']['output'];
  mean: Scalars['Float']['output'];
  min: Scalars['Float']['output'];
  productCount?: Maybe<Scalars['Int']['output']>;
  to: Scalars['Float']['output'];
  toStr: Scalars['String']['output'];
  total: Scalars['Float']['output'];
  totalCount: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type RangeCountLong = RangeCount & {
  __typename?: 'RangeCountLong';
  count: Scalars['Int']['output'];
  from: Scalars['Long']['output'];
  fromStr: Scalars['String']['output'];
  max: Scalars['Long']['output'];
  mean: Scalars['Float']['output'];
  min: Scalars['Long']['output'];
  productCount?: Maybe<Scalars['Int']['output']>;
  to: Scalars['Long']['output'];
  toStr: Scalars['String']['output'];
  total: Scalars['Long']['output'];
  totalCount: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type RangeElementInput = {
  from: Scalars['String']['input'];
  to: Scalars['String']['input'];
};

export type RangeFacetInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  countProducts?: Scalars['Boolean']['input'];
  path: Scalars['String']['input'];
  ranges: Array<RangeElementInput>;
};

export type RangeFacetResult = FacetResult & {
  __typename?: 'RangeFacetResult';
  dataType: Scalars['String']['output'];
  ranges: Array<RangeCount>;
  type: Scalars['String']['output'];
};

export type RangeFilterInput = {
  path: Scalars['String']['input'];
  ranges: Array<RangeElementInput>;
};

export type RawCustomField = {
  __typename?: 'RawCustomField';
  name: Scalars['String']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResource?: Maybe<ReferenceExpandable>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResourceSet: Array<ReferenceExpandable>;
  value: Scalars['Json']['output'];
};

export type RawProductAttribute = {
  __typename?: 'RawProductAttribute';
  attributeDefinition?: Maybe<AttributeDefinition>;
  name: Scalars['String']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResource?: Maybe<ReferenceExpandable>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResourceSet: Array<ReferenceExpandable>;
  value: Scalars['Json']['output'];
};

export type RawProductSearchAttribute = {
  __typename?: 'RawProductSearchAttribute';
  name: Scalars['String']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResource?: Maybe<ReferenceExpandable>;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  referencedResourceSet: Array<ReferenceExpandable>;
  value: Scalars['Json']['output'];
};

export type RecalculateCart = {
  updateProductData?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RecalculateStagedOrder = {
  updateProductData?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RecalculateStagedOrderOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RecalculateStagedOrderOutput';
  type: Scalars['String']['output'];
  updateProductData: Scalars['Boolean']['output'];
};

export type Reference = {
  __typename?: 'Reference';
  id: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

export type ReferenceAttribute = Attribute & {
  __typename?: 'ReferenceAttribute';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

export type ReferenceAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'ReferenceAttributeDefinitionType';
  name: Scalars['String']['output'];
  referenceTypeId: Scalars['String']['output'];
};

export type ReferenceExpandable = {
  id: Scalars['String']['output'];
};

export type ReferenceField = CustomField & {
  __typename?: 'ReferenceField';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

export type ReferenceId = {
  __typename?: 'ReferenceId';
  id: Scalars['String']['output'];
  typeId: Scalars['String']['output'];
};

export type ReferenceInput = {
  id: Scalars['String']['input'];
  typeId: Scalars['String']['input'];
};

export type ReferenceType = FieldType & {
  __typename?: 'ReferenceType';
  name: Scalars['String']['output'];
  referenceTypeId: Scalars['String']['output'];
};

export type ReferenceTypeDefinitionDraft = {
  referenceTypeId: Scalars['String']['input'];
};

export type RefreshTokenLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'RefreshTokenLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type RefreshTokenLimitsProjection = {
  __typename?: 'RefreshTokenLimitsProjection';
  total: RefreshTokenLimitWithCurrent;
};

export type RejectApprovalFlow = {
  reason?: InputMaybe<Scalars['String']['input']>;
};

export type RelativeDiscountValue = CartDiscountValue & ProductDiscountValue & {
  __typename?: 'RelativeDiscountValue';
  permyriad: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type RelativeDiscountValueInput = {
  permyriad: Scalars['Int']['input'];
};

export type RemoveAssociateRolePermission = {
  permission: Permission;
};

export type RemoveAttributeGroupAttribute = {
  attribute: AttributeReferenceInput;
};

export type RemoveBusinessUnitAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveBusinessUnitAssociate = {
  customer: ResourceIdentifierInput;
};

export type RemoveBusinessUnitBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveBusinessUnitShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveBusinessUnitStore = {
  store: ResourceIdentifierInput;
};

export type RemoveCartCustomLineItem = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveCartDiscountCode = {
  discountCode: ReferenceInput;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type RemoveCartDiscountStore = {
  store: ResourceIdentifierInput;
};

export type RemoveCartItemShippingAddress = {
  addressKey: Scalars['String']['input'];
};

export type RemoveCartLineItem = {
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetailsToRemove?: InputMaybe<ItemShippingDetailsDraft>;
};

export type RemoveCartPayment = {
  payment: ResourceIdentifierInput;
};

export type RemoveCartShippingMethod = {
  shippingKey: Scalars['String']['input'];
};

export type RemoveCategoryAsset = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveChannelRoles = {
  roles: Array<ChannelRole>;
};

export type RemoveCustomerAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveCustomerBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveCustomerShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveCustomerStore = {
  store: ResourceIdentifierInput;
};

export type RemoveInventoryEntryQuantity = {
  quantity: Scalars['Long']['input'];
};

export type RemoveMyBusinessUnitAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveMyBusinessUnitAssociate = {
  customer: ResourceIdentifierInput;
};

export type RemoveMyBusinessUnitBillingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveMyBusinessUnitShippingAddressId = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveOrderDelivery = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveOrderItemShippingAddress = {
  addressKey: Scalars['String']['input'];
};

export type RemoveOrderParcelFromDelivery = {
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveOrderPayment = {
  payment: ResourceIdentifierInput;
};

export type RemoveProductAsset = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type RemoveProductFromCategory = {
  category: ResourceIdentifierInput;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RemoveProductImage = {
  imageUrl: Scalars['String']['input'];
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type RemoveProductPrice = {
  priceId?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RemoveProductSelectionProduct = {
  product: ResourceIdentifierInput;
};

export type RemoveProductVariant = {
  id?: InputMaybe<Scalars['Int']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RemoveShippingMethodShippingRate = {
  shippingRate: ShippingRateDraft;
  zone: ResourceIdentifierInput;
};

export type RemoveShippingMethodZone = {
  zone: ResourceIdentifierInput;
};

export type RemoveShoppingListLineItem = {
  lineItemId: Scalars['String']['input'];
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

export type RemoveShoppingListTextLineItem = {
  quantity?: InputMaybe<Scalars['Int']['input']>;
  textLineItemId: Scalars['String']['input'];
};

export type RemoveStagedChanges = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveStagedOrderCustomLineItem = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveStagedOrderCustomLineItemOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderCustomLineItemOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderDelivery = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveStagedOrderDeliveryOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderDeliveryOutput';
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderDiscountCode = {
  discountCode: ReferenceInput;
};

export type RemoveStagedOrderDiscountCodeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderDiscountCodeOutput';
  discountCode?: Maybe<DiscountCode>;
  discountCodeRef: Reference;
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderItemShippingAddress = {
  addressKey: Scalars['String']['input'];
};

export type RemoveStagedOrderItemShippingAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderItemShippingAddressOutput';
  addressKey: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderLineItem = {
  externalPrice?: InputMaybe<BaseMoneyInput>;
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Long']['input']>;
  shippingDetailsToRemove?: InputMaybe<ItemShippingDetailsDraftType>;
};

export type RemoveStagedOrderLineItemOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderLineItemOutput';
  externalPrice?: Maybe<BaseMoney>;
  externalTotalPrice?: Maybe<ExternalLineItemTotalPrice>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Long']['output']>;
  shippingDetailsToRemove?: Maybe<ItemShippingDetailsDraftOutput>;
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderParcelFromDelivery = {
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type RemoveStagedOrderParcelFromDeliveryOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderParcelFromDeliveryOutput';
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type RemoveStagedOrderPayment = {
  payment: ResourceIdentifierInput;
};

export type RemoveStagedOrderPaymentOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'RemoveStagedOrderPaymentOutput';
  paymentResId: ResourceIdentifier;
  type: Scalars['String']['output'];
};

export type RemoveStandalonePriceTier = {
  minimumQuantity: Scalars['Int']['input'];
};

export type RemoveStateRoles = {
  roles: Array<StateRole>;
};

export type RemoveStoreCountry = {
  country: StoreCountryInput;
};

export type RemoveStoreDistributionChannel = {
  distributionChannel: ResourceIdentifierInput;
};

export type RemoveStoreProductSelection = {
  productSelection: ResourceIdentifierInput;
};

export type RemoveStoreSupplyChannel = {
  supplyChannel: ResourceIdentifierInput;
};

export type RemoveTypeFieldDefinition = {
  fieldName: Scalars['String']['input'];
};

export type RemoveZoneLocation = {
  location: ZoneLocation;
};

export type RequestQuoteRenegotiation = {
  buyerComment?: InputMaybe<Scalars['String']['input']>;
};

export type ResourceIdentifier = {
  __typename?: 'ResourceIdentifier';
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  typeId: Scalars['String']['output'];
};

export type ResourceIdentifierInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  typeId?: InputMaybe<Scalars['String']['input']>;
};

/** Stores information about returns connected to this order. */
export type ReturnInfo = {
  __typename?: 'ReturnInfo';
  items: Array<ReturnItem>;
  returnDate?: Maybe<Scalars['DateTime']['output']>;
  returnTrackingId?: Maybe<Scalars['String']['output']>;
};

export type ReturnInfoAdded = MessagePayload & OrderMessagePayload & {
  __typename?: 'ReturnInfoAdded';
  returnInfo: ReturnInfo;
  type: Scalars['String']['output'];
};

export type ReturnInfoDraftType = {
  items: Array<ReturnItemDraftType>;
  returnDate?: InputMaybe<Scalars['DateTime']['input']>;
  returnTrackingId?: InputMaybe<Scalars['String']['input']>;
};

export type ReturnInfoDraftTypeOutput = {
  __typename?: 'ReturnInfoDraftTypeOutput';
  items: Array<ReturnItemDraftTypeOutput>;
  returnDate?: Maybe<Scalars['DateTime']['output']>;
  returnTrackingId?: Maybe<Scalars['String']['output']>;
};

export type ReturnInfoSet = MessagePayload & OrderMessagePayload & {
  __typename?: 'ReturnInfoSet';
  returnInfo?: Maybe<Array<ReturnInfo>>;
  type: Scalars['String']['output'];
};

export type ReturnItem = {
  comment?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  paymentState: ReturnPaymentState;
  quantity: Scalars['Long']['output'];
  shipmentState: ReturnShipmentState;
  type: Scalars['String']['output'];
};

export type ReturnItemDraftType = {
  comment?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
  shipmentState: ReturnShipmentState;
};

export type ReturnItemDraftTypeOutput = {
  __typename?: 'ReturnItemDraftTypeOutput';
  comment?: Maybe<Scalars['String']['output']>;
  custom?: Maybe<CustomFieldsCommand>;
  customLineItemId?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Long']['output'];
  shipmentState: ReturnShipmentState;
};

export enum ReturnPaymentState {
  Initial = 'Initial',
  NonRefundable = 'NonRefundable',
  NotRefunded = 'NotRefunded',
  Refunded = 'Refunded'
}

export enum ReturnShipmentState {
  Advised = 'Advised',
  BackInStock = 'BackInStock',
  Returned = 'Returned',
  Unusable = 'Unusable'
}

export type RevertStagedChanges = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type RevertStagedVariantChanges = {
  variantId: Scalars['Int']['input'];
};

export type Review = ReferenceExpandable & Versioned & {
  __typename?: 'Review';
  authorName?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  id: Scalars['String']['output'];
  includedInStatistics: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  locale?: Maybe<Scalars['Locale']['output']>;
  rating?: Maybe<Scalars['Int']['output']>;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  target?: Maybe<ReviewTarget>;
  targetRef?: Maybe<Reference>;
  text?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  uniquenessValue?: Maybe<Scalars['String']['output']>;
  version: Scalars['Long']['output'];
};

export type ReviewCreated = MessagePayload & {
  __typename?: 'ReviewCreated';
  review: Review;
  type: Scalars['String']['output'];
};

export type ReviewDraft = {
  authorName?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customer?: InputMaybe<ResourceIdentifierInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
  rating?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<ResourceIdentifierInput>;
  target?: InputMaybe<TargetReferenceInput>;
  text?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  uniquenessValue?: InputMaybe<Scalars['String']['input']>;
};

export type ReviewQueryResult = {
  __typename?: 'ReviewQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Review>;
  total: Scalars['Long']['output'];
};

export type ReviewRatingSet = MessagePayload & {
  __typename?: 'ReviewRatingSet';
  includedInStatistics: Scalars['Boolean']['output'];
  newRating?: Maybe<Scalars['Int']['output']>;
  oldRating?: Maybe<Scalars['Int']['output']>;
  target?: Maybe<ReviewTarget>;
  targetRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type ReviewRatingStatistics = {
  __typename?: 'ReviewRatingStatistics';
  averageRating: Scalars['Float']['output'];
  count: Scalars['Long']['output'];
  highestRating: Scalars['Int']['output'];
  lowestRating: Scalars['Int']['output'];
  ratingsDistribution: Scalars['Json']['output'];
};

export type ReviewStateTransition = MessagePayload & {
  __typename?: 'ReviewStateTransition';
  force: Scalars['Boolean']['output'];
  newIncludedInStatistics: Scalars['Boolean']['output'];
  newState?: Maybe<State>;
  newStateRef: Reference;
  oldIncludedInStatistics: Scalars['Boolean']['output'];
  oldState?: Maybe<State>;
  oldStateRef?: Maybe<Reference>;
  target?: Maybe<ReviewTarget>;
  targetRef?: Maybe<Reference>;
  type: Scalars['String']['output'];
};

export type ReviewTarget = {
  id: Scalars['String']['output'];
};

export type ReviewUpdateAction = {
  setAuthorName?: InputMaybe<SetReviewAuthorName>;
  setCustomField?: InputMaybe<SetReviewCustomField>;
  setCustomType?: InputMaybe<SetReviewCustomType>;
  setCustomer?: InputMaybe<SetReviewCustomer>;
  setKey?: InputMaybe<SetReviewKey>;
  setLocale?: InputMaybe<SetReviewLocale>;
  setRating?: InputMaybe<SetReviewRating>;
  setTarget?: InputMaybe<SetReviewTarget>;
  setText?: InputMaybe<SetReviewText>;
  setTitle?: InputMaybe<SetReviewTitle>;
  transitionState?: InputMaybe<TransitionReviewState>;
};

export enum RoundingMode {
  /** [Round half down](https://en.wikipedia.org/wiki/Rounding#Round_half_down) */
  HalfDown = 'HalfDown',
  /** [Round half to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). Default rounding mode as used in IEEE 754 computing functions and operators. */
  HalfEven = 'HalfEven',
  /** [Round half up](https://en.wikipedia.org/wiki/Rounding#Round_half_up) */
  HalfUp = 'HalfUp'
}

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type RuleApprover = {
  __typename?: 'RuleApprover';
  associateRole: AssociateRole;
  associateRoleRef: KeyReference;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type RuleApproverDraft = {
  associateRole: ResourceIdentifierInput;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type RuleInfo = {
  __typename?: 'RuleInfo';
  description?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type RuleRequester = {
  __typename?: 'RuleRequester';
  associateRole: AssociateRole;
  associateRoleRef: KeyReference;
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type RuleRequesterDraft = {
  associateRole: ResourceIdentifierInput;
};

export type SnsDestination = Destination & {
  __typename?: 'SNSDestination';
  accessKey?: Maybe<Scalars['String']['output']>;
  accessSecret?: Maybe<Scalars['String']['output']>;
  authenticationMode: AwsAuthenticationMode;
  topicArn: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type SnsDestinationInput = {
  accessKey?: InputMaybe<Scalars['String']['input']>;
  accessSecret?: InputMaybe<Scalars['String']['input']>;
  authenticationMode?: InputMaybe<AwsAuthenticationMode>;
  topicArn: Scalars['String']['input'];
};

export type SqsDestination = Destination & {
  __typename?: 'SQSDestination';
  accessKey?: Maybe<Scalars['String']['output']>;
  accessSecret?: Maybe<Scalars['String']['output']>;
  authenticationMode: AwsAuthenticationMode;
  queueUrl: Scalars['String']['output'];
  region: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type SqsDestinationInput = {
  accessKey?: InputMaybe<Scalars['String']['input']>;
  accessSecret?: InputMaybe<Scalars['String']['input']>;
  authenticationMode?: InputMaybe<AwsAuthenticationMode>;
  queueUrl: Scalars['String']['input'];
  region: Scalars['String']['input'];
};

export type ScopedPrice = {
  __typename?: 'ScopedPrice';
  channel?: Maybe<Channel>;
  channelRef?: Maybe<Reference>;
  country?: Maybe<Scalars['String']['output']>;
  currentValue: BaseMoney;
  custom?: Maybe<CustomFieldsType>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  discounted?: Maybe<DiscountedProductSearchPriceValue>;
  id: Scalars['String']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: BaseMoney;
};

export type ScoreShippingRateInput = ShippingRateInput & {
  __typename?: 'ScoreShippingRateInput';
  score: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type ScoreShippingRateInputDraft = {
  score: Scalars['Int']['input'];
};

export type ScoreShippingRateInputDraftOutput = ShippingRateInputDraftOutput & {
  __typename?: 'ScoreShippingRateInputDraftOutput';
  score: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type SearchFacetInput = {
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  model?: InputMaybe<SearchFacetModelInput>;
  string?: InputMaybe<Scalars['String']['input']>;
};

export type SearchFacetModelInput = {
  range?: InputMaybe<RangeFacetInput>;
  terms?: InputMaybe<TermsFacetInput>;
};

export type SearchFilterInput = {
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  model?: InputMaybe<SearchFilterModelInput>;
  string?: InputMaybe<Scalars['String']['input']>;
};

export type SearchFilterModelInput = {
  exists?: InputMaybe<ExistsFilterInput>;
  missing?: InputMaybe<MissingFilterInput>;
  range?: InputMaybe<RangeFilterInput>;
  tree?: InputMaybe<TreeFilterInput>;
  value?: InputMaybe<ValueFilterInput>;
};

export type SearchIndexingConfiguration = {
  __typename?: 'SearchIndexingConfiguration';
  /** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
  customers?: Maybe<CustomerSearchConfiguration>;
  orders?: Maybe<OrderSearchConfiguration>;
  products?: Maybe<SearchIndexingConfigurationValues>;
  standalonePrices?: Maybe<SearchIndexingConfigurationValues>;
};

export type SearchIndexingConfigurationValues = {
  __typename?: 'SearchIndexingConfigurationValues';
  lastModifiedAt?: Maybe<Scalars['DateTime']['output']>;
  lastModifiedBy?: Maybe<Initiator>;
  status?: Maybe<SearchIndexingStatus>;
};

export enum SearchIndexingStatus {
  Activated = 'Activated',
  Deactivated = 'Deactivated',
  Indexing = 'Indexing'
}

export type SearchKeyword = {
  __typename?: 'SearchKeyword';
  suggestTokenizer?: Maybe<SuggestTokenizer>;
  text: Scalars['String']['output'];
};

export type SearchKeywordArgument = {
  locale: Scalars['Locale']['input'];
  searchKeyword: Scalars['String']['input'];
};

export type SearchKeywordInput = {
  keywords: Array<SearchKeywordItemInput>;
  locale: Scalars['Locale']['input'];
};

export type SearchKeywordItemInput = {
  suggestTokenizer?: InputMaybe<BaseSearchKeywordInput>;
  text: Scalars['String']['input'];
};

export type SearchKeywordProductSearch = {
  __typename?: 'SearchKeywordProductSearch';
  suggestTokenizer?: Maybe<SuggestTokenizerProductSearch>;
  text: Scalars['String']['output'];
};

export type SearchKeywords = {
  __typename?: 'SearchKeywords';
  locale: Scalars['Locale']['output'];
  searchKeywords: Array<SearchKeyword>;
};

export type SearchKeywordsProductSearch = {
  __typename?: 'SearchKeywordsProductSearch';
  locale: Scalars['Locale']['output'];
  searchKeywords: Array<SearchKeywordProductSearch>;
};

export type SearchLimitsProjection = {
  __typename?: 'SearchLimitsProjection';
  maxTextSize: Limit;
};

/** In order to decide which of the matching items will actually be discounted */
export enum SelectionMode {
  Cheapest = 'Cheapest',
  MostExpensive = 'MostExpensive'
}

export type SelectionOfProduct = {
  __typename?: 'SelectionOfProduct';
  createdAt: Scalars['DateTime']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  productSelection?: Maybe<ProductSelection>;
  productSelectionRef: Reference;
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  variantExclusion?: Maybe<ProductVariantExclusion>;
  variantSelection?: Maybe<ProductVariantSelection>;
};

export type SelectionOfProductQueryResult = {
  __typename?: 'SelectionOfProductQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<SelectionOfProduct>;
  total: Scalars['Long']['output'];
};

/** CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta */
export type SetApprovalRuleApprovers = {
  approvers: ApproverHierarchyDraft;
};

export type SetApprovalRuleDescription = {
  description?: InputMaybe<Scalars['String']['input']>;
};

export type SetApprovalRuleKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetApprovalRuleName = {
  name: Scalars['String']['input'];
};

export type SetApprovalRulePredicate = {
  predicate: Scalars['String']['input'];
};

export type SetApprovalRuleRequesters = {
  requesters: Array<RuleRequesterDraft>;
};

export type SetApprovalRuleStatus = {
  status: ApprovalRuleStatus;
};

export type SetAssociateRoleCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetAssociateRoleCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetAssociateRoleName = {
  name?: InputMaybe<Scalars['String']['input']>;
};

export type SetAssociateRolePermissions = {
  permissions?: InputMaybe<Array<Permission>>;
};

export type SetAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'SetAttributeDefinitionType';
  elementType: AttributeDefinitionType;
  name: Scalars['String']['output'];
};

export type SetAttributeGroupAttributes = {
  attributes: Array<AttributeReferenceInput>;
};

export type SetAttributeGroupDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetAttributeGroupKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitAddressCustomField = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitAddressCustomType = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitAssociates = {
  associates?: InputMaybe<Array<AssociateDraft>>;
};

export type SetBusinessUnitContactEmail = {
  contactEmail?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitDefaultBillingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetBusinessUnitDefaultShippingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type SetBusinessUnitStoreMode = {
  storeMode?: InputMaybe<Scalars['String']['input']>;
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type SetBusinessUnitStores = {
  stores: Array<ResourceIdentifierInput>;
};

export type SetCartAnonymousId = {
  anonymousId?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartBillingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetCartBillingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartBillingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartBusinessUnit = {
  businessUnit: ResourceIdentifierInput;
};

export type SetCartCountry = {
  country?: InputMaybe<Scalars['Country']['input']>;
};

export type SetCartCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomLineItemCustomField = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomLineItemCustomType = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomLineItemShippingDetails = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
};

export type SetCartCustomLineItemTaxAmount = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomLineItemTaxRate = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomShippingMethod = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethodName: Scalars['String']['input'];
  shippingRate: ShippingRateDraft;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type SetCartCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomerEmail = {
  email?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartCustomerGroup = {
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
};

export type SetCartCustomerId = {
  customerId?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartDeleteDaysAfterLastModification = {
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
};

export type SetCartDirectDiscounts = {
  discounts: Array<DirectDiscountDraft>;
};

export type SetCartDiscountCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartDiscountCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartDiscountDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetCartDiscountKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type SetCartDiscountStores = {
  stores?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type SetCartDiscountValidFrom = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetCartDiscountValidFromAndUntil = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetCartDiscountValidUntil = {
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetCartItemShippingAddressCustomField = {
  addressKey: Scalars['String']['input'];
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartItemShippingAddressCustomType = {
  addressKey: Scalars['String']['input'];
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemCustomField = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemDistributionChannel = {
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemInventoryMode = {
  inventoryMode?: InputMaybe<InventoryMode>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemPrice = {
  externalPrice?: InputMaybe<BaseMoneyInput>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemShippingDetails = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraft>;
};

export type SetCartLineItemSupplyChannel = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
};

export type SetCartLineItemTaxAmount = {
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemTaxRate = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLineItemTotalPrice = {
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartLocale = {
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type SetCartShippingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetCartShippingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingCustomField = {
  name: Scalars['String']['input'];
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingMethod = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
};

export type SetCartShippingMethodTaxAmount = {
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingMethodTaxRate = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCartShippingRateInput = {
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
};

export type SetCartTotalTax = {
  externalTaxPortions?: InputMaybe<Array<TaxPortionDraft>>;
  externalTotalGross?: InputMaybe<MoneyInput>;
};

export type SetCategoryAssetCustomField = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryAssetCustomType = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryAssetDescription = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetCategoryAssetKey = {
  assetId: Scalars['String']['input'];
  assetKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryAssetSources = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  sources?: InputMaybe<Array<AssetSourceInput>>;
};

export type SetCategoryAssetTags = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type SetCategoryCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetCategoryExternalId = {
  externalId?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetCategoryMetaDescription = {
  metaDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetCategoryMetaKeywords = {
  metaKeywords?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetCategoryMetaTitle = {
  metaTitle?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetChannelAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetChannelAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetChannelAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetChannelCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetChannelCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetChannelGeoLocation = {
  geoLocation?: InputMaybe<GeometryInput>;
};

export type SetChannelRoles = {
  roles: Array<ChannelRole>;
};

export type SetCustomerAddressCustomField = {
  addressId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerAddressCustomType = {
  addressId: Scalars['String']['input'];
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerAuthenticationMode = {
  authMode: AuthenticationMode;
  password?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerCompanyName = {
  companyName?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerDateOfBirth = {
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
};

export type SetCustomerDefaultBillingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerDefaultShippingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerExternalId = {
  externalId?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerFirstName = {
  firstName?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerGroup = {
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
};

export type SetCustomerGroupCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerGroupCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerGroupKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerLastName = {
  lastName?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerLocale = {
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type SetCustomerMiddleName = {
  middleName?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerNumber = {
  customerNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerSalutation = {
  salutation?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerStores = {
  stores: Array<ResourceIdentifierInput>;
};

export type SetCustomerTitle = {
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SetCustomerVatId = {
  vatId?: InputMaybe<Scalars['String']['input']>;
};

export type SetDiscountCodeCartPredicate = {
  cartPredicate?: InputMaybe<Scalars['String']['input']>;
};

export type SetDiscountCodeCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetDiscountCodeCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetDiscountCodeDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetDiscountCodeMaxApplications = {
  maxApplications?: InputMaybe<Scalars['Long']['input']>;
};

export type SetDiscountCodeMaxApplicationsPerCustomer = {
  maxApplicationsPerCustomer?: InputMaybe<Scalars['Long']['input']>;
};

export type SetDiscountCodeName = {
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetDiscountCodeValidFrom = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetDiscountCodeValidFromAndUntil = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetDiscountCodeValidUntil = {
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetExtensionKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetExtensionTimeoutInMs = {
  timeoutInMs?: InputMaybe<Scalars['Int']['input']>;
};

export type SetInventoryEntryCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetInventoryEntryCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetInventoryEntryExpectedDelivery = {
  expectedDelivery?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetInventoryEntryRestockableInDays = {
  restockableInDays?: InputMaybe<Scalars['Int']['input']>;
};

export type SetInventoryEntrySupplyChannel = {
  supplyChannel?: InputMaybe<ResourceIdentifierInput>;
};

export type SetMyBusinessUnitAddressCustomField = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitAddressCustomType = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitContactEmail = {
  contactEmail?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitDefaultBillingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyBusinessUnitDefaultShippingAddress = {
  addressId?: InputMaybe<Scalars['String']['input']>;
  addressKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyCartShippingMethod = {
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
};

export type SetMyQuoteRequestCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetMyQuoteRequestCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderBillingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetOrderBillingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderBillingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomLineItemCustomField = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomLineItemCustomType = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomLineItemShippingDetails = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
};

export type SetOrderCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomerEmail = {
  email?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderCustomerId = {
  customerId?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryAddress = {
  address?: InputMaybe<AddressInput>;
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryAddressCustomField = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryAddressCustomType = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryCustomField = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryCustomType = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderDeliveryItems = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items: Array<DeliveryItemDraftType>;
};

export type SetOrderEditComment = {
  comment?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderEditCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderEditCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderEditKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderEditStagedActions = {
  stagedActions: Array<StagedOrderUpdateAction>;
};

export type SetOrderItemShippingAddressCustomField = {
  addressKey: Scalars['String']['input'];
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderItemShippingAddressCustomType = {
  addressKey: Scalars['String']['input'];
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderLineItemCustomField = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderLineItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderLineItemShippingDetails = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
};

export type SetOrderLocale = {
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type SetOrderNumber = {
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderParcelCustomField = {
  name: Scalars['String']['input'];
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderParcelCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderParcelItems = {
  items: Array<DeliveryItemDraftType>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderParcelMeasurements = {
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderParcelTrackingData = {
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type SetOrderPurchaseOrderNumber = {
  purchaseOrderNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderReturnInfo = {
  items?: InputMaybe<Array<ReturnInfoDraftType>>;
};

export type SetOrderReturnItemCustomField = {
  name: Scalars['String']['input'];
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderReturnItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderReturnPaymentState = {
  paymentState: ReturnPaymentState;
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderReturnShipmentState = {
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  shipmentState: ReturnShipmentState;
};

export type SetOrderShippingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetOrderShippingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderShippingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderShippingCustomField = {
  name: Scalars['String']['input'];
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderShippingCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetOrderStore = {
  store?: InputMaybe<ResourceIdentifierInput>;
};

export type SetPaymentAmountPaid = {
  amount?: InputMaybe<MoneyInput>;
};

export type SetPaymentAmountRefunded = {
  amount?: InputMaybe<MoneyInput>;
};

export type SetPaymentAnonymousId = {
  anonymousId?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentAuthorization = {
  amount?: InputMaybe<MoneyInput>;
  until?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetPaymentCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentCustomer = {
  customer?: InputMaybe<ReferenceInput>;
};

export type SetPaymentExternalId = {
  externalId?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentInterfaceId = {
  interfaceId?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentMethodInfoInterface = {
  interface: Scalars['String']['input'];
};

export type SetPaymentMethodInfoMethod = {
  method?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentMethodInfoName = {
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetPaymentStatusInterfaceCode = {
  interfaceCode?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentStatusInterfaceText = {
  interfaceText?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentTransactionCustomField = {
  name: Scalars['String']['input'];
  transactionId: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetPaymentTransactionCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  transactionId: Scalars['String']['input'];
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductAssetCustomField = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAssetCustomType = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAssetDescription = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAssetKey = {
  assetId: Scalars['String']['input'];
  assetKey?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAssetSources = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  sources?: InputMaybe<Array<AssetSourceInput>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAssetTags = {
  assetId?: InputMaybe<Scalars['String']['input']>;
  assetKey?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAttribute = {
  name: Scalars['String']['input'];
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductAttributeInAllVariants = {
  name: Scalars['String']['input'];
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductCategoryOrderHint = {
  categoryId: Scalars['String']['input'];
  orderHint?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductDiscountDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetProductDiscountKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductDiscountValidFrom = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetProductDiscountValidFromAndUntil = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetProductDiscountValidUntil = {
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetProductDiscountedPrice = {
  discounted?: InputMaybe<DiscountedProductPriceValueInput>;
  priceId: Scalars['String']['input'];
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductImageLabel = {
  imageUrl: Scalars['String']['input'];
  label?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductMetaAttributes = {
  metaDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaKeywords?: InputMaybe<Array<LocalizedStringItemInputType>>;
  metaTitle?: InputMaybe<Array<LocalizedStringItemInputType>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductMetaDescription = {
  metaDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductMetaKeywords = {
  metaKeywords?: InputMaybe<Array<LocalizedStringItemInputType>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductMetaTitle = {
  metaTitle?: InputMaybe<Array<LocalizedStringItemInputType>>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductPriceCustomField = {
  name: Scalars['String']['input'];
  priceId: Scalars['String']['input'];
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductPriceCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  priceId: Scalars['String']['input'];
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductPriceKey = {
  key?: InputMaybe<Scalars['String']['input']>;
  priceId: Scalars['String']['input'];
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetProductPriceMode = {
  priceMode?: InputMaybe<PriceMode>;
};

export type SetProductPrices = {
  prices: Array<ProductPriceDataInput>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProductSelectionCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductSelectionCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductSelectionKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetProductSelectionVariantExclusion = {
  product: ResourceIdentifierInput;
  variantExclusion?: InputMaybe<ProductVariantExclusionDraft>;
};

export type SetProductSelectionVariantSelection = {
  product: ResourceIdentifierInput;
  variantSelection?: InputMaybe<ProductVariantSelectionDraft>;
};

export type SetProductSku = {
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId: Scalars['Int']['input'];
};

export type SetProductTaxCategory = {
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type SetProductVariantKey = {
  key?: InputMaybe<Scalars['String']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

export type SetProjectSettingsExternalOAuth = {
  externalOAuth?: InputMaybe<ExternalOAuthDraft>;
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation = {
  associateRole?: InputMaybe<ResourceIdentifierInput>;
};

export type SetProjectSettingsShippingRateInputType = {
  shippingRateInputType?: InputMaybe<ShippingRateInputTypeInput>;
};

export type SetQuoteCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetQuoteCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetQuoteRequestCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetQuoteRequestCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewAuthorName = {
  authorName?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewCustomer = {
  customer?: InputMaybe<ResourceIdentifierInput>;
};

export type SetReviewKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewLocale = {
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type SetReviewRating = {
  rating?: InputMaybe<Scalars['Int']['input']>;
};

export type SetReviewTarget = {
  target?: InputMaybe<TargetReferenceInput>;
};

export type SetReviewText = {
  text?: InputMaybe<Scalars['String']['input']>;
};

export type SetReviewTitle = {
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SetSearchKeywords = {
  searchKeywords: Array<SearchKeywordInput>;
  staged?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SetShippingMethodCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetShippingMethodCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetShippingMethodDescription = {
  description?: InputMaybe<Scalars['String']['input']>;
};

export type SetShippingMethodKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetShippingMethodLocalizedDescription = {
  localizedDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetShippingMethodLocalizedName = {
  localizedName?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetShippingMethodPredicate = {
  predicate?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListAnonymousId = {
  anonymousId?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListCustomer = {
  customer?: InputMaybe<ResourceIdentifierInput>;
};

export type SetShoppingListDeleteDaysAfterLastModification = {
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
};

export type SetShoppingListDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetShoppingListKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListLineItemCustomField = {
  lineItemId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListLineItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  lineItemId: Scalars['String']['input'];
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListSlug = {
  slug?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetShoppingListStore = {
  store?: InputMaybe<ResourceIdentifierInput>;
};

export type SetShoppingListTextLineItemCustomField = {
  name: Scalars['String']['input'];
  textLineItemId: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListTextLineItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  textLineItemId: Scalars['String']['input'];
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetShoppingListTextLineItemDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  textLineItemId: Scalars['String']['input'];
};

export type SetStagedOrderBillingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetStagedOrderBillingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderBillingAddressCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderBillingAddressCustomFieldOutput';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderBillingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderBillingAddressCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderBillingAddressCustomTypeOutput';
  custom: CustomFieldsCommand;
  type: Scalars['String']['output'];
};

export type SetStagedOrderBillingAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderBillingAddressOutput';
  address?: Maybe<AddressDraft>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCountry = {
  country?: InputMaybe<Scalars['Country']['input']>;
};

export type SetStagedOrderCountryOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCountryOutput';
  country?: Maybe<Scalars['Country']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomFieldOutput';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderCustomLineItemCustomField = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomLineItemCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomLineItemCustomFieldOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderCustomLineItemCustomType = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomLineItemCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomLineItemCustomTypeOutput';
  custom: CustomFieldsCommand;
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomLineItemShippingDetails = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
};

export type SetStagedOrderCustomLineItemShippingDetailsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomLineItemShippingDetailsOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  shippingDetails?: Maybe<ItemShippingDetailsDraftOutput>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomLineItemTaxAmount = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomLineItemTaxAmountOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomLineItemTaxAmountOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  externalTaxAmount?: Maybe<ExternalTaxAmountDraftOutput>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomLineItemTaxRate = {
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomLineItemTaxRateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomLineItemTaxRateOutput';
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomShippingMethod = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethodName: Scalars['String']['input'];
  shippingRate: ShippingRateDraft;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderCustomShippingMethodOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomShippingMethodOutput';
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingMethodName: Scalars['String']['output'];
  shippingRate: ShippingRate;
  taxCategoryResId?: Maybe<ResourceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomTypeOutput';
  custom: CustomFieldsCommand;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomerEmail = {
  email?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomerEmailOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomerEmailOutput';
  email?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomerGroup = {
  customerGroup?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderCustomerGroupOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomerGroupOutput';
  customerGroupResId?: Maybe<CustomerGroupReferenceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderCustomerId = {
  customerId?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderCustomerIdOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderCustomerIdOutput';
  customerId?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderDeliveryAddress = {
  address?: InputMaybe<AddressInput>;
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderDeliveryAddressCustomField = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderDeliveryAddressCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryAddressCustomFieldOutput';
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderDeliveryAddressCustomType = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderDeliveryAddressCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryAddressCustomTypeOutput';
  custom: CustomFieldsCommand;
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderDeliveryAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryAddressOutput';
  address?: Maybe<AddressDraft>;
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderDeliveryCustomField = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderDeliveryCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryCustomFieldOutput';
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderDeliveryCustomType = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderDeliveryCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryCustomTypeOutput';
  custom: CustomFieldsCommand;
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderDeliveryItems = {
  deliveryId?: InputMaybe<Scalars['String']['input']>;
  deliveryKey?: InputMaybe<Scalars['String']['input']>;
  items: Array<DeliveryItemDraftType>;
};

export type SetStagedOrderDeliveryItemsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDeliveryItemsOutput';
  deliveryId?: Maybe<Scalars['String']['output']>;
  deliveryKey?: Maybe<Scalars['String']['output']>;
  items: Array<DeliveryItem>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderDirectDiscounts = {
  discounts: Array<DirectDiscountDraft>;
};

export type SetStagedOrderDirectDiscountsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderDirectDiscountsOutput';
  discounts: Array<DirectDiscountDraftOutput>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderItemShippingAddressCustomField = {
  addressKey: Scalars['String']['input'];
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderItemShippingAddressCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderItemShippingAddressCustomFieldOutput';
  addressKey: Scalars['String']['output'];
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderItemShippingAddressCustomType = {
  addressKey: Scalars['String']['input'];
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderItemShippingAddressCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderItemShippingAddressCustomTypeOutput';
  addressKey: Scalars['String']['output'];
  custom: CustomFieldsCommand;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemCustomField = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemCustomFieldOutput';
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderLineItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemCustomTypeOutput';
  custom: CustomFieldsCommand;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemDistributionChannel = {
  distributionChannel?: InputMaybe<ResourceIdentifierInput>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemDistributionChannelOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemDistributionChannelOutput';
  distributionChannelResId?: Maybe<ChannelReferenceIdentifier>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemPrice = {
  externalPrice?: InputMaybe<BaseMoneyInput>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemPriceOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemPriceOutput';
  externalPrice?: Maybe<BaseMoney>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemShippingDetails = {
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingDetails?: InputMaybe<ItemShippingDetailsDraftType>;
};

export type SetStagedOrderLineItemShippingDetailsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemShippingDetailsOutput';
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  shippingDetails?: Maybe<ItemShippingDetailsDraftOutput>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemTaxAmount = {
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemTaxAmountOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemTaxAmountOutput';
  externalTaxAmount?: Maybe<ExternalTaxAmountDraftOutput>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemTaxRate = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemTaxRateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemTaxRateOutput';
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLineItemTotalPrice = {
  externalTotalPrice?: InputMaybe<ExternalLineItemTotalPriceDraft>;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderLineItemTotalPriceOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLineItemTotalPriceOutput';
  externalTotalPrice?: Maybe<ExternalLineItemTotalPrice>;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderLocale = {
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type SetStagedOrderLocaleOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderLocaleOutput';
  locale?: Maybe<Scalars['Locale']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderOrderNumber = {
  orderNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderOrderNumberOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderOrderNumberOutput';
  orderNumber?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderOrderTotalTax = {
  externalTaxPortions?: InputMaybe<Array<TaxPortionDraft>>;
  externalTotalGross?: InputMaybe<MoneyInput>;
};

export type SetStagedOrderOrderTotalTaxOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderOrderTotalTaxOutput';
  externalTaxPortions: Array<TaxPortion>;
  externalTotalGross?: Maybe<Money>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderParcelCustomField = {
  name: Scalars['String']['input'];
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderParcelCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderParcelCustomFieldOutput';
  name: Scalars['String']['output'];
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderParcelCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderParcelCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderParcelCustomTypeOutput';
  custom: CustomFieldsCommand;
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderParcelItems = {
  items: Array<DeliveryItemDraftType>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderParcelItemsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderParcelItemsOutput';
  items: Array<DeliveryItem>;
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderParcelMeasurements = {
  measurements?: InputMaybe<ParcelMeasurementsDraftType>;
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderParcelMeasurementsOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderParcelMeasurementsOutput';
  measurements?: Maybe<ParcelMeasurements>;
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderParcelTrackingData = {
  parcelId?: InputMaybe<Scalars['String']['input']>;
  parcelKey?: InputMaybe<Scalars['String']['input']>;
  trackingData?: InputMaybe<TrackingDataDraftType>;
};

export type SetStagedOrderParcelTrackingDataOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderParcelTrackingDataOutput';
  parcelId?: Maybe<Scalars['String']['output']>;
  parcelKey?: Maybe<Scalars['String']['output']>;
  trackingData?: Maybe<TrackingData>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderPurchaseOrderNumber = {
  purchaseOrderNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderPurchaseOrderNumberOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderPurchaseOrderNumberOutput';
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderReturnInfo = {
  items?: InputMaybe<Array<ReturnInfoDraftType>>;
};

export type SetStagedOrderReturnInfoOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderReturnInfoOutput';
  items: Array<ReturnInfoDraftTypeOutput>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderReturnItemCustomField = {
  name: Scalars['String']['input'];
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderReturnItemCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderReturnItemCustomFieldOutput';
  name: Scalars['String']['output'];
  returnItemId?: Maybe<Scalars['String']['output']>;
  returnItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderReturnItemCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderReturnItemCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderReturnItemCustomTypeOutput';
  custom: CustomFieldsCommand;
  returnItemId?: Maybe<Scalars['String']['output']>;
  returnItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderReturnPaymentState = {
  paymentState: ReturnPaymentState;
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderReturnPaymentStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderReturnPaymentStateOutput';
  paymentState: ReturnPaymentState;
  returnItemId?: Maybe<Scalars['String']['output']>;
  returnItemKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderReturnShipmentState = {
  returnItemId?: InputMaybe<Scalars['String']['input']>;
  returnItemKey?: InputMaybe<Scalars['String']['input']>;
  shipmentState: ReturnShipmentState;
};

export type SetStagedOrderReturnShipmentStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderReturnShipmentStateOutput';
  returnItemId?: Maybe<Scalars['String']['output']>;
  returnItemKey?: Maybe<Scalars['String']['output']>;
  shipmentState: ReturnShipmentState;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingAddress = {
  address?: InputMaybe<AddressInput>;
};

export type SetStagedOrderShippingAddressAndCustomShippingMethod = {
  address: AddressInput;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethodName: Scalars['String']['input'];
  shippingRate: ShippingRateDraft;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderShippingAddressAndCustomShippingMethodOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingAddressAndCustomShippingMethodOutput';
  address: AddressDraft;
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingMethodName: Scalars['String']['output'];
  shippingRate: ShippingRate;
  taxCategoryResId?: Maybe<ResourceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingAddressAndShippingMethod = {
  address: AddressInput;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderShippingAddressAndShippingMethodOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingAddressAndShippingMethodOutput';
  address: AddressDraft;
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingMethodResId?: Maybe<ResourceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingAddressCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingAddressCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingAddressCustomFieldOutput';
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderShippingAddressCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingAddressCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingAddressCustomTypeOutput';
  custom: CustomFieldsCommand;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingAddressOutput';
  address?: Maybe<AddressDraft>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingCustomField = {
  name: Scalars['String']['input'];
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingCustomFieldOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingCustomFieldOutput';
  name: Scalars['String']['output'];
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['Json']['output']>;
};

export type SetStagedOrderShippingCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingCustomTypeOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingCustomTypeOutput';
  custom: CustomFieldsCommand;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingMethod = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderShippingMethodOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingMethodOutput';
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingMethodResId?: Maybe<ResourceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingMethodTaxAmount = {
  externalTaxAmount?: InputMaybe<ExternalTaxAmountDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingMethodTaxAmountOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingMethodTaxAmountOutput';
  externalTaxAmount?: Maybe<ExternalTaxAmountDraftOutput>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingMethodTaxRate = {
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  shippingKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedOrderShippingMethodTaxRateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingMethodTaxRateOutput';
  externalTaxRate?: Maybe<ExternalTaxRateDraftOutput>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderShippingRateInput = {
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
};

export type SetStagedOrderShippingRateInputOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderShippingRateInputOutput';
  shippingRateInput?: Maybe<ShippingRateInputDraftOutput>;
  type: Scalars['String']['output'];
};

export type SetStagedOrderStore = {
  store?: InputMaybe<ResourceIdentifierInput>;
};

export type SetStagedOrderStoreOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'SetStagedOrderStoreOutput';
  storeResId?: Maybe<ResourceIdentifier>;
  type: Scalars['String']['output'];
};

export type SetStagedQuoteCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedQuoteCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedQuoteSellerComment = {
  sellerComment?: InputMaybe<Scalars['String']['input']>;
};

export type SetStagedQuoteValidTo = {
  validTo?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetStandalonePriceCustomFields = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStandalonePriceDiscountedPrice = {
  discounted?: InputMaybe<DiscountedProductPriceValueInput>;
};

export type SetStandalonePriceKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetStandalonePriceTiers = {
  tiers: Array<ProductPriceTierInput>;
};

export type SetStandalonePriceValidFrom = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetStandalonePriceValidFromAndUntil = {
  validFrom?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetStandalonePriceValidUntil = {
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SetStateDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetStateName = {
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetStateRoles = {
  roles: Array<StateRole>;
};

export type SetStateTransitions = {
  transitions?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type SetStoreCountries = {
  countries?: InputMaybe<Array<StoreCountryInput>>;
};

export type SetStoreCustomField = {
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

export type SetStoreCustomType = {
  fields?: InputMaybe<Array<CustomFieldInput>>;
  type?: InputMaybe<ResourceIdentifierInput>;
  typeId?: InputMaybe<Scalars['String']['input']>;
  typeKey?: InputMaybe<Scalars['String']['input']>;
};

export type SetStoreDistributionChannels = {
  distributionChannels?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type SetStoreLanguages = {
  languages?: InputMaybe<Array<Scalars['Locale']['input']>>;
};

export type SetStoreName = {
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetStoreProductSelections = {
  productSelections?: InputMaybe<Array<ProductSelectionSettingInActionInput>>;
};

export type SetStoreSupplyChannels = {
  supplyChannels?: InputMaybe<Array<ResourceIdentifierInput>>;
};

export type SetSubscriptionChanges = {
  changes: Array<ChangeSubscriptionInput>;
};

export type SetSubscriptionKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetSubscriptionMessages = {
  messages: Array<MessageSubscriptionInput>;
};

export type SetTaxCategoryKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export type SetType = FieldType & {
  __typename?: 'SetType';
  elementType: FieldType;
  name: Scalars['String']['output'];
};

export type SetTypeDescription = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetZoneDescription = {
  description?: InputMaybe<Scalars['String']['input']>;
};

export type SetZoneKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};

export enum ShipmentState {
  Backorder = 'Backorder',
  Delayed = 'Delayed',
  Delivered = 'Delivered',
  Partial = 'Partial',
  Pending = 'Pending',
  Ready = 'Ready',
  Shipped = 'Shipped'
}

export type Shipping = {
  __typename?: 'Shipping';
  shippingAddress?: Maybe<Address>;
  shippingCustomFields?: Maybe<CustomFieldsType>;
  shippingInfo?: Maybe<ShippingInfo>;
  shippingKey?: Maybe<Scalars['String']['output']>;
  shippingRateInput?: Maybe<ShippingRateInput>;
};

export type ShippingDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  deliveries?: InputMaybe<Array<DeliveryDraft>>;
  externalTaxRate?: InputMaybe<ExternalTaxRateDraft>;
  key: Scalars['String']['input'];
  shippingAddress: AddressInput;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
  shippingRateInput?: InputMaybe<ShippingRateInputDraft>;
};

export type ShippingInfo = {
  __typename?: 'ShippingInfo';
  deliveries: Array<Delivery>;
  discountedPrice?: Maybe<DiscountedLineItemPrice>;
  price: Money;
  shippingMethod?: Maybe<ShippingMethod>;
  shippingMethodName: Scalars['String']['output'];
  shippingMethodRef?: Maybe<Reference>;
  shippingMethodState: ShippingMethodState;
  shippingRate: ShippingRate;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  taxRate?: Maybe<TaxRate>;
  taxedPrice?: Maybe<TaxedItemPrice>;
};

export type ShippingInfoImportDraft = {
  deliveries?: Array<DeliveryDraft>;
  discountedPrice?: InputMaybe<DiscountedLineItemPriceDraft>;
  price: MoneyInput;
  shippingMethod?: InputMaybe<ResourceIdentifierInput>;
  shippingMethodName: Scalars['String']['input'];
  shippingMethodState?: ShippingMethodState;
  shippingRate: ShippingRateDraft;
  taxCategory?: InputMaybe<ResourceIdentifierInput>;
  taxRate?: InputMaybe<TaxRateInput>;
};

export type ShippingMethod = ReferenceExpandable & Versioned & {
  __typename?: 'ShippingMethod';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  isDefault: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  localizedDescription?: Maybe<Scalars['String']['output']>;
  localizedDescriptionAllLocales?: Maybe<Array<LocalizedString>>;
  localizedName?: Maybe<Scalars['String']['output']>;
  localizedNameAllLocales?: Maybe<Array<LocalizedString>>;
  name: Scalars['String']['output'];
  predicate?: Maybe<Scalars['String']['output']>;
  taxCategory?: Maybe<TaxCategory>;
  taxCategoryRef?: Maybe<Reference>;
  version: Scalars['Long']['output'];
  zoneRates: Array<ZoneRate>;
};


export type ShippingMethodLocalizedDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ShippingMethodLocalizedNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ShippingMethodDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  /** The usage of parameter 'description' is deprecated in favor of using 'localizedDescription' */
  description?: InputMaybe<Scalars['String']['input']>;
  isDefault: Scalars['Boolean']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
  localizedDescription?: InputMaybe<Array<LocalizedStringItemInputType>>;
  localizedName?: InputMaybe<Array<LocalizedStringItemInputType>>;
  name: Scalars['String']['input'];
  predicate?: InputMaybe<Scalars['String']['input']>;
  taxCategory: ResourceIdentifierInput;
  zoneRates?: InputMaybe<Array<ZoneRateDraft>>;
};

export type ShippingMethodLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'ShippingMethodLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type ShippingMethodLimitsProjection = {
  __typename?: 'ShippingMethodLimitsProjection';
  total: ShippingMethodLimitWithCurrent;
};

export type ShippingMethodQueryResult = {
  __typename?: 'ShippingMethodQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ShippingMethod>;
  total: Scalars['Long']['output'];
};

export enum ShippingMethodState {
  /** The ShippingMethod predicate does not match the cart. Ordering this cart will fail with error ShippingMethodDoesNotMatchCart */
  DoesNotMatchCart = 'DoesNotMatchCart',
  /** Either there is no predicate defined for the ShippingMethod or the given predicate matches the cart */
  MatchesCart = 'MatchesCart'
}

export type ShippingMethodUpdateAction = {
  addShippingRate?: InputMaybe<AddShippingMethodShippingRate>;
  addZone?: InputMaybe<AddShippingMethodZone>;
  changeIsDefault?: InputMaybe<ChangeShippingMethodIsDefault>;
  changeName?: InputMaybe<ChangeShippingMethodName>;
  changeTaxCategory?: InputMaybe<ChangeShippingMethodTaxCategory>;
  removeShippingRate?: InputMaybe<RemoveShippingMethodShippingRate>;
  removeZone?: InputMaybe<RemoveShippingMethodZone>;
  setCustomField?: InputMaybe<SetShippingMethodCustomField>;
  setCustomType?: InputMaybe<SetShippingMethodCustomType>;
  /** This action is deprecated in favor of using 'setLocalizedDescription' */
  setDescription?: InputMaybe<SetShippingMethodDescription>;
  setKey?: InputMaybe<SetShippingMethodKey>;
  setLocalizedDescription?: InputMaybe<SetShippingMethodLocalizedDescription>;
  setLocalizedName?: InputMaybe<SetShippingMethodLocalizedName>;
  setPredicate?: InputMaybe<SetShippingMethodPredicate>;
};

/** A field to retrieve available shipping methods for a cart. */
export type ShippingMethodsByCartInterface = {
  shippingMethodsByCart: Array<ShippingMethod>;
};


/** A field to retrieve available shipping methods for a cart. */
export type ShippingMethodsByCartInterfaceShippingMethodsByCartArgs = {
  id: Scalars['String']['input'];
};

export enum ShippingMode {
  /** Allows multiple shipping methods for the cart with their respective shipping addresses */
  Multiple = 'Multiple',
  /** Allows only one shipping method and shipping address for the cart */
  Single = 'Single'
}

/** Shipping Rate */
export type ShippingRate = {
  __typename?: 'ShippingRate';
  freeAbove?: Maybe<Money>;
  isMatching?: Maybe<Scalars['Boolean']['output']>;
  price: Money;
  tiers: Array<ShippingRatePriceTier>;
};

export type ShippingRateCartClassificationPriceTier = ShippingRatePriceTier & {
  __typename?: 'ShippingRateCartClassificationPriceTier';
  isMatching?: Maybe<Scalars['Boolean']['output']>;
  price: Money;
  type: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ShippingRateCartScorePriceTier = ShippingRatePriceTier & {
  __typename?: 'ShippingRateCartScorePriceTier';
  isMatching?: Maybe<Scalars['Boolean']['output']>;
  price?: Maybe<Money>;
  priceFunction?: Maybe<PriceFunction>;
  score: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type ShippingRateCartValuePriceTier = ShippingRatePriceTier & {
  __typename?: 'ShippingRateCartValuePriceTier';
  isMatching?: Maybe<Scalars['Boolean']['output']>;
  minimumCentAmount: Scalars['Int']['output'];
  price: Money;
  type: Scalars['String']['output'];
};

export type ShippingRateDraft = {
  freeAbove?: InputMaybe<MoneyDraft>;
  price: MoneyDraft;
  tiers?: InputMaybe<Array<ShippingRatePriceTierDraft>>;
};

export type ShippingRateInput = {
  type: Scalars['String']['output'];
};

export type ShippingRateInputDraft = {
  Classification?: InputMaybe<ClassificationShippingRateInputDraft>;
  Score?: InputMaybe<ScoreShippingRateInputDraft>;
};

export type ShippingRateInputDraftOutput = {
  type: Scalars['String']['output'];
};

export type ShippingRateInputLocalizedEnumValue = {
  __typename?: 'ShippingRateInputLocalizedEnumValue';
  key: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  labelAllLocales: Array<LocalizedString>;
};


export type ShippingRateInputLocalizedEnumValueLabelArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ShippingRateInputType = {
  type: Scalars['String']['output'];
};

export type ShippingRateInputTypeInput = {
  CartClassification?: InputMaybe<CartClassificationInput>;
  CartScore?: InputMaybe<CartScoreInput>;
  CartValue?: InputMaybe<CartValueInput>;
};

export type ShippingRatePriceTier = {
  type: Scalars['String']['output'];
};

export type ShippingRatePriceTierCartClassificationDraft = {
  price: MoneyDraft;
  value: Scalars['String']['input'];
};

export type ShippingRatePriceTierCartScoreDraft = {
  price?: InputMaybe<MoneyDraft>;
  priceFunction?: InputMaybe<PriceFunctionDraft>;
  score: Scalars['Int']['input'];
};

export type ShippingRatePriceTierCartValueDraft = {
  minimumCentAmount: Scalars['Int']['input'];
  price: MoneyDraft;
};

export type ShippingRatePriceTierDraft = {
  CartClassification?: InputMaybe<ShippingRatePriceTierCartClassificationDraft>;
  CartScore?: InputMaybe<ShippingRatePriceTierCartScoreDraft>;
  CartValue?: InputMaybe<ShippingRatePriceTierCartValueDraft>;
};

export type ShippingTarget = CartDiscountTarget & {
  __typename?: 'ShippingTarget';
  type: Scalars['String']['output'];
};

export type ShippingTargetDraft = {
  addressKey: Scalars['String']['input'];
  quantity: Scalars['Long']['input'];
  shippingMethodKey?: InputMaybe<Scalars['String']['input']>;
};

export type ShippingTargetDraftType = {
  addressKey: Scalars['String']['input'];
  quantity: Scalars['Long']['input'];
  shippingMethodKey?: InputMaybe<Scalars['String']['input']>;
};

export type ShippingTargetInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type ShoppingList = ReferenceExpandable & Versioned & {
  __typename?: 'ShoppingList';
  anonymousId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  deleteDaysAfterLastModification?: Maybe<Scalars['Int']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  lineItems: Array<ShoppingListLineItem>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales?: Maybe<Array<LocalizedString>>;
  store?: Maybe<Store>;
  storeRef?: Maybe<KeyReference>;
  textLineItems: Array<TextLineItem>;
  version: Scalars['Long']['output'];
};


export type ShoppingListDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ShoppingListNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ShoppingListSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ShoppingListDraft = {
  anonymousId?: InputMaybe<Scalars['String']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  customer?: InputMaybe<ResourceIdentifierInput>;
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  key?: InputMaybe<Scalars['String']['input']>;
  lineItems?: InputMaybe<Array<ShoppingListLineItemDraft>>;
  name: Array<LocalizedStringItemInputType>;
  slug?: InputMaybe<Array<LocalizedStringItemInputType>>;
  textLineItems?: InputMaybe<Array<TextLineItemDraft>>;
};

export type ShoppingListLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'ShoppingListLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type ShoppingListLimitsProjection = {
  __typename?: 'ShoppingListLimitsProjection';
  lineItems: Limit;
  textLineItems: Limit;
  total: ShoppingListLimitWithCurrent;
};

export type ShoppingListLineItem = {
  __typename?: 'ShoppingListLineItem';
  addedAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  deactivatedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  productId: Scalars['String']['output'];
  productSlug?: Maybe<Scalars['String']['output']>;
  productSlugAllLocales?: Maybe<Array<LocalizedString>>;
  productType: ProductTypeDefinition;
  productTypeRef: Reference;
  quantity: Scalars['Int']['output'];
  variant?: Maybe<ProductVariant>;
  variantId?: Maybe<Scalars['Int']['output']>;
};


export type ShoppingListLineItemNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type ShoppingListLineItemProductSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ShoppingListLineItemDraft = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  productId?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['Int']['input']>;
};

/** Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists. */
export type ShoppingListQueryInterface = {
  shoppingList?: Maybe<ShoppingList>;
  shoppingLists: ShoppingListQueryResult;
};


/** Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists. */
export type ShoppingListQueryInterfaceShoppingListArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
};


/** Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists. */
export type ShoppingListQueryInterfaceShoppingListsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<Scalars['String']['input']>>;
  where?: InputMaybe<Scalars['String']['input']>;
};

export type ShoppingListQueryResult = {
  __typename?: 'ShoppingListQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<ShoppingList>;
  total: Scalars['Long']['output'];
};

export type ShoppingListUpdateAction = {
  addLineItem?: InputMaybe<AddShoppingListLineItem>;
  addTextLineItem?: InputMaybe<AddShoppingListTextLineItem>;
  changeLineItemQuantity?: InputMaybe<ChangeShoppingListLineItemQuantity>;
  changeLineItemsOrder?: InputMaybe<ChangeShoppingListLineItemsOrder>;
  changeName?: InputMaybe<ChangeShoppingListName>;
  changeTextLineItemName?: InputMaybe<ChangeShoppingListTextLineItemName>;
  changeTextLineItemQuantity?: InputMaybe<ChangeShoppingListTextLineItemQuantity>;
  changeTextLineItemsOrder?: InputMaybe<ChangeShoppingListTextLineItemsOrder>;
  removeLineItem?: InputMaybe<RemoveShoppingListLineItem>;
  removeTextLineItem?: InputMaybe<RemoveShoppingListTextLineItem>;
  setAnonymousId?: InputMaybe<SetShoppingListAnonymousId>;
  setCustomField?: InputMaybe<SetShoppingListCustomField>;
  setCustomType?: InputMaybe<SetShoppingListCustomType>;
  setCustomer?: InputMaybe<SetShoppingListCustomer>;
  setDeleteDaysAfterLastModification?: InputMaybe<SetShoppingListDeleteDaysAfterLastModification>;
  setDescription?: InputMaybe<SetShoppingListDescription>;
  setKey?: InputMaybe<SetShoppingListKey>;
  setLineItemCustomField?: InputMaybe<SetShoppingListLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetShoppingListLineItemCustomType>;
  setSlug?: InputMaybe<SetShoppingListSlug>;
  setStore?: InputMaybe<SetShoppingListStore>;
  setTextLineItemCustomField?: InputMaybe<SetShoppingListTextLineItemCustomField>;
  setTextLineItemCustomType?: InputMaybe<SetShoppingListTextLineItemCustomType>;
  setTextLineItemDescription?: InputMaybe<SetShoppingListTextLineItemDescription>;
};

export type ShoppingListsConfiguration = {
  __typename?: 'ShoppingListsConfiguration';
  deleteDaysAfterLastModification?: Maybe<Scalars['Int']['output']>;
};

export type ShoppingListsConfigurationInput = {
  deleteDaysAfterLastModification?: InputMaybe<Scalars['Int']['input']>;
};

export type SignUpInMyBusinessUnitDraft = {
  associateRoleAssignments: Array<AssociateRoleAssignmentDraft>;
  businessUnit: ResourceIdentifierInput;
  customer: CustomerSignUpDraft;
  version: Scalars['Long']['input'];
};

/** This has been deprecated and replaced with the AssociateRole entity */
export enum SimpleAssociateRole {
  Admin = 'Admin',
  Buyer = 'Buyer'
}

export type SimpleAttributeTypeDraft = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type SimpleFieldTypeDraft = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

/** Describes how this discount interacts with other discounts */
export enum StackingMode {
  /** Default. Continue applying other matching discounts after applying this one. */
  Stacking = 'Stacking',
  /** Don’t apply any more matching discounts after this one. */
  StopAfterThisDiscount = 'StopAfterThisDiscount'
}

export type StagedOrderUpdateAction = {
  addCustomLineItem?: InputMaybe<AddStagedOrderCustomLineItem>;
  addDelivery?: InputMaybe<AddStagedOrderDelivery>;
  addDiscountCode?: InputMaybe<AddStagedOrderDiscountCode>;
  addItemShippingAddress?: InputMaybe<AddStagedOrderItemShippingAddress>;
  addLineItem?: InputMaybe<AddStagedOrderLineItem>;
  addParcelToDelivery?: InputMaybe<AddStagedOrderParcelToDelivery>;
  addPayment?: InputMaybe<AddStagedOrderPayment>;
  addReturnInfo?: InputMaybe<AddStagedOrderReturnInfo>;
  addShoppingList?: InputMaybe<AddStagedOrderShoppingList>;
  changeCustomLineItemMoney?: InputMaybe<ChangeStagedOrderCustomLineItemMoney>;
  changeCustomLineItemQuantity?: InputMaybe<ChangeStagedOrderCustomLineItemQuantity>;
  changeLineItemQuantity?: InputMaybe<ChangeStagedOrderLineItemQuantity>;
  changeOrderState?: InputMaybe<ChangeStagedOrderOrderState>;
  changePaymentState?: InputMaybe<ChangeStagedOrderPaymentState>;
  changeShipmentState?: InputMaybe<ChangeStagedOrderShipmentState>;
  changeTaxCalculationMode?: InputMaybe<ChangeStagedOrderTaxCalculationMode>;
  changeTaxMode?: InputMaybe<ChangeStagedOrderTaxMode>;
  changeTaxRoundingMode?: InputMaybe<ChangeStagedOrderTaxRoundingMode>;
  importCustomLineItemState?: InputMaybe<ImportStagedOrderCustomLineItemState>;
  importLineItemState?: InputMaybe<ImportStagedOrderLineItemState>;
  recalculate?: InputMaybe<RecalculateStagedOrder>;
  removeCustomLineItem?: InputMaybe<RemoveStagedOrderCustomLineItem>;
  removeDelivery?: InputMaybe<RemoveStagedOrderDelivery>;
  removeDiscountCode?: InputMaybe<RemoveStagedOrderDiscountCode>;
  removeItemShippingAddress?: InputMaybe<RemoveStagedOrderItemShippingAddress>;
  removeLineItem?: InputMaybe<RemoveStagedOrderLineItem>;
  removeParcelFromDelivery?: InputMaybe<RemoveStagedOrderParcelFromDelivery>;
  removePayment?: InputMaybe<RemoveStagedOrderPayment>;
  setBillingAddress?: InputMaybe<SetStagedOrderBillingAddress>;
  setBillingAddressCustomField?: InputMaybe<SetStagedOrderBillingAddressCustomField>;
  setBillingAddressCustomType?: InputMaybe<SetStagedOrderBillingAddressCustomType>;
  setCountry?: InputMaybe<SetStagedOrderCountry>;
  setCustomField?: InputMaybe<SetStagedOrderCustomField>;
  setCustomLineItemCustomField?: InputMaybe<SetStagedOrderCustomLineItemCustomField>;
  setCustomLineItemCustomType?: InputMaybe<SetStagedOrderCustomLineItemCustomType>;
  setCustomLineItemShippingDetails?: InputMaybe<SetStagedOrderCustomLineItemShippingDetails>;
  setCustomLineItemTaxAmount?: InputMaybe<SetStagedOrderCustomLineItemTaxAmount>;
  setCustomLineItemTaxRate?: InputMaybe<SetStagedOrderCustomLineItemTaxRate>;
  setCustomShippingMethod?: InputMaybe<SetStagedOrderCustomShippingMethod>;
  setCustomType?: InputMaybe<SetStagedOrderCustomType>;
  setCustomerEmail?: InputMaybe<SetStagedOrderCustomerEmail>;
  setCustomerGroup?: InputMaybe<SetStagedOrderCustomerGroup>;
  setCustomerId?: InputMaybe<SetStagedOrderCustomerId>;
  setDeliveryAddress?: InputMaybe<SetStagedOrderDeliveryAddress>;
  setDeliveryAddressCustomField?: InputMaybe<SetStagedOrderDeliveryAddressCustomField>;
  setDeliveryAddressCustomType?: InputMaybe<SetStagedOrderDeliveryAddressCustomType>;
  setDeliveryCustomField?: InputMaybe<SetStagedOrderDeliveryCustomField>;
  setDeliveryCustomType?: InputMaybe<SetStagedOrderDeliveryCustomType>;
  setDeliveryItems?: InputMaybe<SetStagedOrderDeliveryItems>;
  setDirectDiscounts?: InputMaybe<SetStagedOrderDirectDiscounts>;
  setItemShippingAddressCustomField?: InputMaybe<SetStagedOrderItemShippingAddressCustomField>;
  setItemShippingAddressCustomType?: InputMaybe<SetStagedOrderItemShippingAddressCustomType>;
  setLineItemCustomField?: InputMaybe<SetStagedOrderLineItemCustomField>;
  setLineItemCustomType?: InputMaybe<SetStagedOrderLineItemCustomType>;
  setLineItemDistributionChannel?: InputMaybe<SetStagedOrderLineItemDistributionChannel>;
  setLineItemPrice?: InputMaybe<SetStagedOrderLineItemPrice>;
  setLineItemShippingDetails?: InputMaybe<SetStagedOrderLineItemShippingDetails>;
  setLineItemTaxAmount?: InputMaybe<SetStagedOrderLineItemTaxAmount>;
  setLineItemTaxRate?: InputMaybe<SetStagedOrderLineItemTaxRate>;
  setLineItemTotalPrice?: InputMaybe<SetStagedOrderLineItemTotalPrice>;
  setLocale?: InputMaybe<SetStagedOrderLocale>;
  setOrderNumber?: InputMaybe<SetStagedOrderOrderNumber>;
  setOrderTotalTax?: InputMaybe<SetStagedOrderOrderTotalTax>;
  setParcelCustomField?: InputMaybe<SetStagedOrderParcelCustomField>;
  setParcelCustomType?: InputMaybe<SetStagedOrderParcelCustomType>;
  setParcelItems?: InputMaybe<SetStagedOrderParcelItems>;
  setParcelMeasurements?: InputMaybe<SetStagedOrderParcelMeasurements>;
  setParcelTrackingData?: InputMaybe<SetStagedOrderParcelTrackingData>;
  setPurchaseOrderNumber?: InputMaybe<SetStagedOrderPurchaseOrderNumber>;
  setReturnInfo?: InputMaybe<SetStagedOrderReturnInfo>;
  setReturnItemCustomField?: InputMaybe<SetStagedOrderReturnItemCustomField>;
  setReturnItemCustomType?: InputMaybe<SetStagedOrderReturnItemCustomType>;
  setReturnPaymentState?: InputMaybe<SetStagedOrderReturnPaymentState>;
  setReturnShipmentState?: InputMaybe<SetStagedOrderReturnShipmentState>;
  setShippingAddress?: InputMaybe<SetStagedOrderShippingAddress>;
  setShippingAddressAndCustomShippingMethod?: InputMaybe<SetStagedOrderShippingAddressAndCustomShippingMethod>;
  setShippingAddressAndShippingMethod?: InputMaybe<SetStagedOrderShippingAddressAndShippingMethod>;
  setShippingAddressCustomField?: InputMaybe<SetStagedOrderShippingAddressCustomField>;
  setShippingAddressCustomType?: InputMaybe<SetStagedOrderShippingAddressCustomType>;
  setShippingCustomField?: InputMaybe<SetStagedOrderShippingCustomField>;
  setShippingCustomType?: InputMaybe<SetStagedOrderShippingCustomType>;
  setShippingMethod?: InputMaybe<SetStagedOrderShippingMethod>;
  setShippingMethodTaxAmount?: InputMaybe<SetStagedOrderShippingMethodTaxAmount>;
  setShippingMethodTaxRate?: InputMaybe<SetStagedOrderShippingMethodTaxRate>;
  setShippingRateInput?: InputMaybe<SetStagedOrderShippingRateInput>;
  setStore?: InputMaybe<SetStagedOrderStore>;
  transitionCustomLineItemState?: InputMaybe<TransitionStagedOrderCustomLineItemState>;
  transitionLineItemState?: InputMaybe<TransitionStagedOrderLineItemState>;
  transitionState?: InputMaybe<TransitionStagedOrderState>;
  updateItemShippingAddress?: InputMaybe<UpdateStagedOrderItemShippingAddress>;
  updateSyncInfo?: InputMaybe<UpdateStagedOrderSyncInfo>;
};

export type StagedOrderUpdateActionOutput = {
  type: Scalars['String']['output'];
};

export type StagedPriceDraft = {
  value: BaseMoneyInput;
};

export type StagedQuote = Versioned & {
  __typename?: 'StagedQuote';
  businessUnit?: Maybe<BusinessUnit>;
  businessUnitRef?: Maybe<KeyReference>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customer?: Maybe<Customer>;
  customerRef?: Maybe<Reference>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  purchaseOrderNumber?: Maybe<Scalars['String']['output']>;
  quotationCart?: Maybe<Cart>;
  quotationCartRef: Reference;
  quoteRequest?: Maybe<QuoteRequest>;
  quoteRequestRef: Reference;
  sellerComment?: Maybe<Scalars['String']['output']>;
  stagedQuoteState: StagedQuoteState;
  state?: Maybe<State>;
  stateRef?: Maybe<Reference>;
  validTo?: Maybe<Scalars['DateTime']['output']>;
  version: Scalars['Long']['output'];
};

export type StagedQuoteDraft = {
  custom?: InputMaybe<CustomFieldsDraft>;
  key?: InputMaybe<Scalars['String']['input']>;
  quoteRequest?: InputMaybe<ResourceIdentifierInput>;
  quoteRequestStateToAccepted?: InputMaybe<Scalars['Boolean']['input']>;
  quoteRequestVersion?: InputMaybe<Scalars['Long']['input']>;
  state?: InputMaybe<ReferenceInput>;
};

export type StagedQuoteQueryResult = {
  __typename?: 'StagedQuoteQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<StagedQuote>;
  total: Scalars['Long']['output'];
};

export enum StagedQuoteState {
  Closed = 'Closed',
  InProgress = 'InProgress',
  Sent = 'Sent'
}

export type StagedQuoteUpdateAction = {
  changeStagedQuoteState?: InputMaybe<ChangeStagedQuoteState>;
  setCustomField?: InputMaybe<SetStagedQuoteCustomField>;
  setCustomType?: InputMaybe<SetStagedQuoteCustomType>;
  setSellerComment?: InputMaybe<SetStagedQuoteSellerComment>;
  setValidTo?: InputMaybe<SetStagedQuoteValidTo>;
  transitionState?: InputMaybe<TransitionStagedQuoteState>;
};

export type StagedStandalonePrice = {
  __typename?: 'StagedStandalonePrice';
  discounted?: Maybe<DiscountedProductPriceValue>;
  value: BaseMoney;
};

/**
 * StandalonePrices are managed and queried through the StandalonePrices API
 * and associated to a ProductVariant through the sku field.
 */
export type StandalonePrice = Versioned & {
  __typename?: 'StandalonePrice';
  active: Scalars['Boolean']['output'];
  channel?: Maybe<Channel>;
  channelRef?: Maybe<Reference>;
  country?: Maybe<Scalars['Country']['output']>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  customerGroup?: Maybe<CustomerGroup>;
  customerGroupRef?: Maybe<Reference>;
  discounted?: Maybe<DiscountedProductPriceValue>;
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  sku: Scalars['String']['output'];
  staged?: Maybe<StagedStandalonePrice>;
  tiers?: Maybe<Array<ProductPriceTier>>;
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
  value: BaseMoney;
  version: Scalars['Long']['output'];
};

export type StandalonePriceActiveChanged = MessagePayload & {
  __typename?: 'StandalonePriceActiveChanged';
  active: Scalars['Boolean']['output'];
  oldActive: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
};

export type StandalonePriceCreated = MessagePayload & {
  __typename?: 'StandalonePriceCreated';
  standalonePrice: StandalonePrice;
  type: Scalars['String']['output'];
};

export type StandalonePriceDeleted = MessagePayload & {
  __typename?: 'StandalonePriceDeleted';
  sku?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type StandalonePriceDiscountSet = MessagePayload & {
  __typename?: 'StandalonePriceDiscountSet';
  discounted?: Maybe<DiscountedProductPriceValue>;
  type: Scalars['String']['output'];
};

/** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
export type StandalonePriceExpiresAtSet = MessagePayload & {
  __typename?: 'StandalonePriceExpiresAtSet';
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  type: Scalars['String']['output'];
};

export type StandalonePriceExternalDiscountSet = MessagePayload & {
  __typename?: 'StandalonePriceExternalDiscountSet';
  discounted?: Maybe<DiscountedProductPriceValue>;
  type: Scalars['String']['output'];
};

export type StandalonePriceKeySet = MessagePayload & {
  __typename?: 'StandalonePriceKeySet';
  key?: Maybe<Scalars['String']['output']>;
  oldKey?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

export type StandalonePriceQueryResult = {
  __typename?: 'StandalonePriceQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<StandalonePrice>;
  total: Scalars['Long']['output'];
};

export type StandalonePriceStagedChangesApplied = MessagePayload & {
  __typename?: 'StandalonePriceStagedChangesApplied';
  stagedChanges: StagedStandalonePrice;
  type: Scalars['String']['output'];
};

export type StandalonePriceStagedChangesRemoved = MessagePayload & {
  __typename?: 'StandalonePriceStagedChangesRemoved';
  type: Scalars['String']['output'];
};

export type StandalonePriceTierAdded = MessagePayload & {
  __typename?: 'StandalonePriceTierAdded';
  tier: ProductPriceTier;
  type: Scalars['String']['output'];
};

export type StandalonePriceTierRemoved = MessagePayload & {
  __typename?: 'StandalonePriceTierRemoved';
  tier: ProductPriceTier;
  type: Scalars['String']['output'];
};

export type StandalonePriceTiersSet = MessagePayload & {
  __typename?: 'StandalonePriceTiersSet';
  previousTiers: Array<ProductPriceTier>;
  tiers: Array<ProductPriceTier>;
  type: Scalars['String']['output'];
};

export type StandalonePriceUpdateAction = {
  addPriceTier?: InputMaybe<AddStandalonePriceTier>;
  applyStagedChanges?: InputMaybe<ApplyStagedChanges>;
  changeActive?: InputMaybe<ChangeStandalonePriceActive>;
  changeValue?: InputMaybe<ChangeStandalonePriceValue>;
  removePriceTier?: InputMaybe<RemoveStandalonePriceTier>;
  removeStagedChanges?: InputMaybe<RemoveStagedChanges>;
  setCustomField?: InputMaybe<SetStandalonePriceCustomFields>;
  setCustomType?: InputMaybe<CustomFieldsDraft>;
  setDiscountedPrice?: InputMaybe<SetStandalonePriceDiscountedPrice>;
  setKey?: InputMaybe<SetStandalonePriceKey>;
  setPriceTiers?: InputMaybe<SetStandalonePriceTiers>;
  setValidFrom?: InputMaybe<SetStandalonePriceValidFrom>;
  setValidFromAndUntil?: InputMaybe<SetStandalonePriceValidFromAndUntil>;
  setValidUntil?: InputMaybe<SetStandalonePriceValidUntil>;
};

export type StandalonePriceValidFromAndUntilSet = MessagePayload & {
  __typename?: 'StandalonePriceValidFromAndUntilSet';
  previousValidFrom?: Maybe<Scalars['DateTime']['output']>;
  previousValidUntil?: Maybe<Scalars['DateTime']['output']>;
  type: Scalars['String']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};

export type StandalonePriceValidFromSet = MessagePayload & {
  __typename?: 'StandalonePriceValidFromSet';
  previousValidFrom?: Maybe<Scalars['DateTime']['output']>;
  type: Scalars['String']['output'];
  validFrom?: Maybe<Scalars['DateTime']['output']>;
};

export type StandalonePriceValidUntilSet = MessagePayload & {
  __typename?: 'StandalonePriceValidUntilSet';
  previousValidUntil?: Maybe<Scalars['DateTime']['output']>;
  type: Scalars['String']['output'];
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};

export type StandalonePriceValueChanged = MessagePayload & {
  __typename?: 'StandalonePriceValueChanged';
  oldValue?: Maybe<BaseMoney>;
  staged: Scalars['Boolean']['output'];
  type: Scalars['String']['output'];
  value: BaseMoney;
};

/** [State](https://docs.commercetools.com/api/projects/states) */
export type State = ReferenceExpandable & Versioned & {
  __typename?: 'State';
  builtIn: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  initial: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  roles: Array<StateRole>;
  transitions?: Maybe<Array<State>>;
  transitionsRef?: Maybe<Array<Reference>>;
  type: StateType;
  version: Scalars['Long']['output'];
};


/** [State](https://docs.commercetools.com/api/projects/states) */
export type StateDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/** [State](https://docs.commercetools.com/api/projects/states) */
export type StateNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type StateDraft = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  initial?: InputMaybe<Scalars['Boolean']['input']>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Array<LocalizedStringItemInputType>>;
  roles?: InputMaybe<Array<StateRole>>;
  transitions?: InputMaybe<Array<ReferenceInput>>;
  type: StateType;
};

export type StateQueryResult = {
  __typename?: 'StateQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<State>;
  total: Scalars['Long']['output'];
};

export enum StateRole {
  Return = 'Return',
  ReviewIncludedInStatistics = 'ReviewIncludedInStatistics'
}

export enum StateType {
  LineItemState = 'LineItemState',
  OrderState = 'OrderState',
  PaymentState = 'PaymentState',
  ProductState = 'ProductState',
  QuoteRequestState = 'QuoteRequestState',
  QuoteState = 'QuoteState',
  ReviewState = 'ReviewState',
  StagedQuoteState = 'StagedQuoteState'
}

export type StateUpdateAction = {
  addRoles?: InputMaybe<AddStateRoles>;
  changeInitial?: InputMaybe<ChangeStateInitial>;
  changeKey?: InputMaybe<ChangeStateKey>;
  changeType?: InputMaybe<ChangeStateType>;
  removeRoles?: InputMaybe<RemoveStateRoles>;
  setDescription?: InputMaybe<SetStateDescription>;
  setName?: InputMaybe<SetStateName>;
  setRoles?: InputMaybe<SetStateRoles>;
  setTransitions?: InputMaybe<SetStateTransitions>;
};

/** Stores allow defining different contexts for a project. */
export type Store = ReferenceExpandable & Versioned & {
  __typename?: 'Store';
  countries?: Maybe<Array<StoreCountry>>;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  custom?: Maybe<CustomFieldsType>;
  distributionChannels: Array<Channel>;
  distributionChannelsRef: Array<Reference>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  languages?: Maybe<Array<Scalars['Locale']['output']>>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  productSelections: Array<ProductSelectionSetting>;
  supplyChannels: Array<Channel>;
  supplyChannelsRef: Array<Reference>;
  version: Scalars['Long']['output'];
};


/** Stores allow defining different contexts for a project. */
export type StoreNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type StoreCountriesChanged = MessagePayload & {
  __typename?: 'StoreCountriesChanged';
  addedCountries?: Maybe<Array<StoreCountry>>;
  removedCountries?: Maybe<Array<StoreCountry>>;
  type: Scalars['String']['output'];
};

export type StoreCountry = {
  __typename?: 'StoreCountry';
  code: Scalars['Country']['output'];
};

export type StoreCountryInput = {
  code: Scalars['Country']['input'];
};

export type StoreCreated = MessagePayload & {
  __typename?: 'StoreCreated';
  countries?: Maybe<Array<StoreCountry>>;
  custom?: Maybe<CustomFieldsType>;
  distributionChannels: Array<Channel>;
  distributionChannelsRef: Array<Reference>;
  languages: Array<Scalars['Locale']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  productSelections: Array<ProductSelectionSetting>;
  productSelectionsRef: Array<Reference>;
  supplyChannels: Array<Channel>;
  supplyChannelsRef: Array<Reference>;
  type: Scalars['String']['output'];
};


export type StoreCreatedNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type StoreDeleted = MessagePayload & {
  __typename?: 'StoreDeleted';
  type: Scalars['String']['output'];
};

export type StoreDistributionChannelsChanged = MessagePayload & {
  __typename?: 'StoreDistributionChannelsChanged';
  addedDistributionChannels?: Maybe<Array<Channel>>;
  addedDistributionChannelsRef?: Maybe<Array<Reference>>;
  removedDistributionChannels?: Maybe<Array<Channel>>;
  removedDistributionChannelsRef?: Maybe<Array<Reference>>;
  type: Scalars['String']['output'];
};

export type StoreLanguagesChanged = MessagePayload & {
  __typename?: 'StoreLanguagesChanged';
  addedLanguages?: Maybe<Array<Scalars['Locale']['output']>>;
  removedLanguages?: Maybe<Array<Scalars['Locale']['output']>>;
  type: Scalars['String']['output'];
};

export type StoreLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'StoreLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type StoreLimitsProjection = {
  __typename?: 'StoreLimitsProjection';
  inventorySupplyChannels: Limit;
  productDistributionChannels: Limit;
  productSelections: Limit;
  total: StoreLimitWithCurrent;
};

export type StoreNameSet = MessagePayload & {
  __typename?: 'StoreNameSet';
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales?: Maybe<Array<LocalizedString>>;
  type: Scalars['String']['output'];
};


export type StoreNameSetNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type StoreProductSelectionsChanged = MessagePayload & {
  __typename?: 'StoreProductSelectionsChanged';
  addedProductSelections?: Maybe<Array<ProductSelectionSetting>>;
  removedProductSelections?: Maybe<Array<ProductSelectionSetting>>;
  type: Scalars['String']['output'];
  updatedProductSelections?: Maybe<Array<ProductSelectionSetting>>;
};

export type StoreQueryResult = {
  __typename?: 'StoreQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Store>;
  total: Scalars['Long']['output'];
};

export type StoreSupplyChannelsChanged = MessagePayload & {
  __typename?: 'StoreSupplyChannelsChanged';
  addedSupplyChannels?: Maybe<Array<Channel>>;
  addedSupplyChannelsRef?: Maybe<Array<Reference>>;
  removedSupplyChannels?: Maybe<Array<Channel>>;
  removedSupplyChannelsRef?: Maybe<Array<Reference>>;
  type: Scalars['String']['output'];
};

export type StoreUpdateAction = {
  addCountry?: InputMaybe<AddStoreCountry>;
  addDistributionChannel?: InputMaybe<AddStoreDistributionChannel>;
  addProductSelection?: InputMaybe<AddStoreProductSelection>;
  addSupplyChannel?: InputMaybe<AddStoreSupplyChannel>;
  changeProductSelectionActive?: InputMaybe<ChangeStoreProductSelectionActive>;
  removeCountry?: InputMaybe<RemoveStoreCountry>;
  removeDistributionChannel?: InputMaybe<RemoveStoreDistributionChannel>;
  removeProductSelection?: InputMaybe<RemoveStoreProductSelection>;
  removeSupplyChannel?: InputMaybe<RemoveStoreSupplyChannel>;
  setCountries?: InputMaybe<SetStoreCountries>;
  setCustomField?: InputMaybe<SetStoreCustomField>;
  setCustomType?: InputMaybe<SetStoreCustomType>;
  setDistributionChannels?: InputMaybe<SetStoreDistributionChannels>;
  setLanguages?: InputMaybe<SetStoreLanguages>;
  setName?: InputMaybe<SetStoreName>;
  setProductSelections?: InputMaybe<SetStoreProductSelections>;
  setSupplyChannels?: InputMaybe<SetStoreSupplyChannels>;
};

export type StringAttribute = Attribute & {
  __typename?: 'StringAttribute';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type StringField = CustomField & {
  __typename?: 'StringField';
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type StringType = FieldType & {
  __typename?: 'StringType';
  name: Scalars['String']['output'];
};

export type SubRate = {
  __typename?: 'SubRate';
  amount: Scalars['Float']['output'];
  name: Scalars['String']['output'];
};

export type SubRateDraft = {
  amount: Scalars['Float']['input'];
  name: Scalars['String']['input'];
};

export type SubscriptionDraft = {
  changes?: InputMaybe<Array<ChangeSubscriptionInput>>;
  destination: DestinationInput;
  format?: InputMaybe<SubscriptionFormatInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  messages?: InputMaybe<Array<MessageSubscriptionInput>>;
};

export type SubscriptionFormatInput = {
  CloudEvents?: InputMaybe<CloudEventsSubscriptionsFormatInput>;
  Platform?: InputMaybe<PlatformFormatInput>;
};

export enum SubscriptionHealthStatus {
  ConfigurationError = 'ConfigurationError',
  ConfigurationErrorDeliveryStopped = 'ConfigurationErrorDeliveryStopped',
  Healthy = 'Healthy',
  TemporaryError = 'TemporaryError'
}

export type SubscriptionUpdateAction = {
  changeDestination?: InputMaybe<ChangeSubscriptionDestination>;
  setChanges?: InputMaybe<SetSubscriptionChanges>;
  setKey?: InputMaybe<SetSubscriptionKey>;
  setMessages?: InputMaybe<SetSubscriptionMessages>;
};

export type SubscriptionsLimitsProjection = {
  __typename?: 'SubscriptionsLimitsProjection';
  maxSubscriptions: Limit;
};

export type SuggestResult = {
  __typename?: 'SuggestResult';
  searchKeywords: Array<SuggestResultEntry>;
};

export type SuggestResultEntry = {
  __typename?: 'SuggestResultEntry';
  locale: Scalars['Locale']['output'];
  suggestions: Array<Suggestion>;
};

export type SuggestTokenizer = {
  type: Scalars['String']['output'];
};

export type SuggestTokenizerProductSearch = {
  type: Scalars['String']['output'];
};

export type Suggestion = {
  __typename?: 'Suggestion';
  text: Scalars['String']['output'];
};

/** Stores information about order synchronization activities (like export or import). */
export type SyncInfo = {
  __typename?: 'SyncInfo';
  channel?: Maybe<Channel>;
  channelRef: Reference;
  externalId?: Maybe<Scalars['String']['output']>;
  syncedAt: Scalars['DateTime']['output'];
};

export type TargetReferenceInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  typeId: Scalars['String']['input'];
};

export enum TaxCalculationMode {
  /**
   * Default. This calculation mode calculates the taxes after the unit price is multiplied with the quantity.
   * E.g. `($1.08 * 3 = $3.24) * 1.19 = $3.8556 -> $3.86 rounded`
   */
  LineItemLevel = 'LineItemLevel',
  /**
   * This calculation mode calculates the taxes on the unit price before multiplying with the quantity.
   * E.g. `($1.08 * 1.19 = $1.2852 -> $1.29 rounded) * 3 = $3.87`
   */
  UnitPriceLevel = 'UnitPriceLevel'
}

/** Tax Categories define how products are to be taxed in different countries. */
export type TaxCategory = ReferenceExpandable & Versioned & {
  __typename?: 'TaxCategory';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name: Scalars['String']['output'];
  rates: Array<TaxRate>;
  version: Scalars['Long']['output'];
};

export type TaxCategoryAddTaxRate = {
  taxRate: TaxRateDraft;
};

export type TaxCategoryChangeName = {
  name: Scalars['String']['input'];
};

export type TaxCategoryDraft = {
  description?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  rates?: InputMaybe<Array<TaxRateDraft>>;
};

export type TaxCategoryLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'TaxCategoryLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type TaxCategoryLimitsProjection = {
  __typename?: 'TaxCategoryLimitsProjection';
  total: TaxCategoryLimitWithCurrent;
};

export type TaxCategoryQueryResult = {
  __typename?: 'TaxCategoryQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<TaxCategory>;
  total: Scalars['Long']['output'];
};

export type TaxCategoryRemoveTaxRate = {
  taxRateId?: InputMaybe<Scalars['String']['input']>;
  taxRateKey?: InputMaybe<Scalars['String']['input']>;
};

export type TaxCategoryReplaceTaxRate = {
  taxRate: TaxRateDraft;
  taxRateId?: InputMaybe<Scalars['String']['input']>;
  taxRateKey?: InputMaybe<Scalars['String']['input']>;
};

export type TaxCategorySetDescription = {
  description?: InputMaybe<Scalars['String']['input']>;
};

export type TaxCategoryUpdateAction = {
  addTaxRate?: InputMaybe<TaxCategoryAddTaxRate>;
  changeName?: InputMaybe<TaxCategoryChangeName>;
  removeTaxRate?: InputMaybe<TaxCategoryRemoveTaxRate>;
  replaceTaxRate?: InputMaybe<TaxCategoryReplaceTaxRate>;
  setDescription?: InputMaybe<TaxCategorySetDescription>;
  setKey?: InputMaybe<SetTaxCategoryKey>;
};

export enum TaxMode {
  /** No taxes are added to the cart. */
  Disabled = 'Disabled',
  /**
   * The tax rates are set externally per ExternalTaxRateDraft. A cart with this tax mode can only be ordered if all
   * line items, all custom line items and the shipping method have an external tax rate set. The totalNet and
   * totalGross as well as the taxPortions fields are calculated according to the taxRoundingMode.
   */
  External = 'External',
  /**
   * The tax amounts and the tax rates as well as the tax portions are set externally per ExternalTaxAmountDraft.
   * A cart with this tax mode can only be ordered if the cart itself and all line items, all custom line items and
   * the shipping method have an external tax amount and rate set
   */
  ExternalAmount = 'ExternalAmount',
  /**
   * The tax rates are selected from the TaxCategories based on the cart shipping address.
   * The totalNet and totalGross as well as the taxPortions fields are calculated according to the
   * taxRoundingMode.
   */
  Platform = 'Platform'
}

/**
 * Represents the portions that sum up to the totalGross field of a TaxedPrice. The portions are calculated
 * from the TaxRates. If a tax rate has SubRates, they are used and can be identified by name. Tax portions
 * from line items that have the same rate and name will be accumulated to the same tax portion.
 */
export type TaxPortion = {
  __typename?: 'TaxPortion';
  amount: Money;
  name?: Maybe<Scalars['String']['output']>;
  rate: Scalars['Float']['output'];
};

export type TaxPortionDraft = {
  amount: MoneyInput;
  name?: InputMaybe<Scalars['String']['input']>;
  rate: Scalars['Float']['input'];
};

export type TaxRate = {
  __typename?: 'TaxRate';
  amount: Scalars['Float']['output'];
  country: Scalars['Country']['output'];
  id?: Maybe<Scalars['String']['output']>;
  includedInPrice: Scalars['Boolean']['output'];
  key?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  subRates: Array<SubRate>;
};

export type TaxRateDraft = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  country: Scalars['Country']['input'];
  includedInPrice: Scalars['Boolean']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  state?: InputMaybe<Scalars['String']['input']>;
  subRates?: InputMaybe<Array<SubRateDraft>>;
};

export type TaxRateInput = {
  amount: Scalars['Float']['input'];
  country: Scalars['Country']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  includedInPrice: Scalars['Boolean']['input'];
  key?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  state?: InputMaybe<Scalars['String']['input']>;
  subRates?: InputMaybe<Array<SubRateDraft>>;
};

export type TaxedItemPrice = {
  __typename?: 'TaxedItemPrice';
  totalGross: Money;
  totalNet: Money;
  totalTax?: Maybe<Money>;
};

export type TaxedPrice = {
  __typename?: 'TaxedPrice';
  taxPortions: Array<TaxPortion>;
  totalGross: Money;
  totalNet: Money;
  totalTax?: Maybe<Money>;
};

export type TaxedPriceDraft = {
  taxPortions: Array<TaxPortionDraft>;
  totalGross: BaseMoneyInput;
  totalNet: BaseMoneyInput;
  totalTax?: InputMaybe<BaseMoneyInput>;
};

export type TermCount = {
  __typename?: 'TermCount';
  count: Scalars['Int']['output'];
  productCount?: Maybe<Scalars['Int']['output']>;
  term: Scalars['String']['output'];
};

export type TermsFacetInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  countProducts?: Scalars['Boolean']['input'];
  path: Scalars['String']['input'];
};

export type TermsFacetResult = FacetResult & {
  __typename?: 'TermsFacetResult';
  dataType: Scalars['String']['output'];
  missing: Scalars['Int']['output'];
  other: Scalars['Int']['output'];
  terms: Array<TermCount>;
  total: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type TextAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'TextAttributeDefinitionType';
  name: Scalars['String']['output'];
};

/** UI hint telling what kind of edit control should be displayed for a text attribute. */
export enum TextInputHint {
  MultiLine = 'MultiLine',
  SingleLine = 'SingleLine'
}

export type TextLineItem = {
  __typename?: 'TextLineItem';
  addedAt: Scalars['DateTime']['output'];
  custom?: Maybe<CustomFieldsType>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  id: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  quantity: Scalars['Int']['output'];
};


export type TextLineItemDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


export type TextLineItemNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type TextLineItemDraft = {
  addedAt?: InputMaybe<Scalars['DateTime']['input']>;
  custom?: InputMaybe<CustomFieldsDraft>;
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  name: Array<LocalizedStringItemInputType>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
};

export type TimeAttribute = Attribute & {
  __typename?: 'TimeAttribute';
  name: Scalars['String']['output'];
  value: Scalars['Time']['output'];
};

export type TimeAttributeDefinitionType = AttributeDefinitionType & {
  __typename?: 'TimeAttributeDefinitionType';
  name: Scalars['String']['output'];
};

export type TimeField = CustomField & {
  __typename?: 'TimeField';
  name: Scalars['String']['output'];
  value: Scalars['Time']['output'];
};

export type TimeType = FieldType & {
  __typename?: 'TimeType';
  name: Scalars['String']['output'];
};

export type TrackingData = {
  __typename?: 'TrackingData';
  carrier?: Maybe<Scalars['String']['output']>;
  isReturn: Scalars['Boolean']['output'];
  provider?: Maybe<Scalars['String']['output']>;
  providerTransaction?: Maybe<Scalars['String']['output']>;
  trackingId?: Maybe<Scalars['String']['output']>;
};

export type TrackingDataDraftType = {
  carrier?: InputMaybe<Scalars['String']['input']>;
  isReturn?: InputMaybe<Scalars['Boolean']['input']>;
  provider?: InputMaybe<Scalars['String']['input']>;
  providerTransaction?: InputMaybe<Scalars['String']['input']>;
  trackingId?: InputMaybe<Scalars['String']['input']>;
};

export type Transaction = {
  __typename?: 'Transaction';
  amount: Money;
  custom?: Maybe<CustomFieldsType>;
  id: Scalars['String']['output'];
  interactionId?: Maybe<Scalars['String']['output']>;
  state: TransactionState;
  timestamp?: Maybe<Scalars['DateTime']['output']>;
  type?: Maybe<TransactionType>;
};

export type TransactionDraft = {
  amount: MoneyInput;
  custom?: InputMaybe<CustomFieldsDraft>;
  interactionId?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<TransactionState>;
  timestamp?: InputMaybe<Scalars['DateTime']['input']>;
  type: TransactionType;
};

export enum TransactionState {
  Failure = 'Failure',
  Initial = 'Initial',
  Pending = 'Pending',
  Success = 'Success'
}

export enum TransactionType {
  Authorization = 'Authorization',
  CancelAuthorization = 'CancelAuthorization',
  Charge = 'Charge',
  Chargeback = 'Chargeback',
  Refund = 'Refund'
}

export type TransitionOrderCustomLineItemState = {
  actualTransitionDate?: InputMaybe<Scalars['DateTime']['input']>;
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  fromState: ResourceIdentifierInput;
  quantity: Scalars['Long']['input'];
  toState: ResourceIdentifierInput;
};

export type TransitionOrderLineItemState = {
  actualTransitionDate?: InputMaybe<Scalars['DateTime']['input']>;
  fromState: ResourceIdentifierInput;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
  toState: ResourceIdentifierInput;
};

export type TransitionOrderState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionPaymentState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionProductState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ReferenceInput;
};

export type TransitionQuoteRequestState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionQuoteState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionReviewState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionStagedOrderCustomLineItemState = {
  actualTransitionDate?: InputMaybe<Scalars['DateTime']['input']>;
  customLineItemId?: InputMaybe<Scalars['String']['input']>;
  customLineItemKey?: InputMaybe<Scalars['String']['input']>;
  fromState: ResourceIdentifierInput;
  quantity: Scalars['Long']['input'];
  toState: ResourceIdentifierInput;
};

export type TransitionStagedOrderCustomLineItemStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'TransitionStagedOrderCustomLineItemStateOutput';
  actualTransitionDate?: Maybe<Scalars['DateTime']['output']>;
  customLineItemId?: Maybe<Scalars['String']['output']>;
  customLineItemKey?: Maybe<Scalars['String']['output']>;
  fromStateResId: ResourceIdentifier;
  quantity: Scalars['Long']['output'];
  toStateResId: ResourceIdentifier;
  type: Scalars['String']['output'];
};

export type TransitionStagedOrderLineItemState = {
  actualTransitionDate?: InputMaybe<Scalars['DateTime']['input']>;
  fromState: ResourceIdentifierInput;
  lineItemId?: InputMaybe<Scalars['String']['input']>;
  lineItemKey?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Long']['input'];
  toState: ResourceIdentifierInput;
};

export type TransitionStagedOrderLineItemStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'TransitionStagedOrderLineItemStateOutput';
  actualTransitionDate?: Maybe<Scalars['DateTime']['output']>;
  fromStateResId: ResourceIdentifier;
  lineItemId?: Maybe<Scalars['String']['output']>;
  lineItemKey?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Long']['output'];
  toStateResId: ResourceIdentifier;
  type: Scalars['String']['output'];
};

export type TransitionStagedOrderState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TransitionStagedOrderStateOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'TransitionStagedOrderStateOutput';
  force: Scalars['Boolean']['output'];
  stateResId: ResourceIdentifier;
  type: Scalars['String']['output'];
};

export type TransitionStagedQuoteState = {
  force?: InputMaybe<Scalars['Boolean']['input']>;
  state: ResourceIdentifierInput;
};

export type TreeFilterInput = {
  path: Scalars['String']['input'];
  rootValues: Array<Scalars['String']['input']>;
  subTreeValues: Array<Scalars['String']['input']>;
};

export type Trigger = {
  __typename?: 'Trigger';
  actions: Array<ActionType>;
  condition?: Maybe<Scalars['String']['output']>;
  resourceTypeId: Scalars['String']['output'];
};

export type TriggerInput = {
  actions?: InputMaybe<Array<ActionType>>;
  condition?: InputMaybe<Scalars['String']['input']>;
  resourceTypeId: Scalars['String']['input'];
};

/** Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields. */
export type TypeDefinition = ReferenceExpandable & Versioned & {
  __typename?: 'TypeDefinition';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  descriptionAllLocales?: Maybe<Array<LocalizedString>>;
  fieldDefinitions: Array<FieldDefinition>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  name?: Maybe<Scalars['String']['output']>;
  nameAllLocales: Array<LocalizedString>;
  resourceTypeIds: Array<Scalars['String']['output']>;
  version: Scalars['Long']['output'];
};


/** Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields. */
export type TypeDefinitionDescriptionArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};


/** Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields. */
export type TypeDefinitionFieldDefinitionsArgs = {
  excludeNames?: InputMaybe<Array<Scalars['String']['input']>>;
  includeNames?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields. */
export type TypeDefinitionNameArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type TypeDefinitionDraft = {
  description?: InputMaybe<Array<LocalizedStringItemInputType>>;
  fieldDefinitions?: InputMaybe<Array<FieldDefinitionInput>>;
  key: Scalars['String']['input'];
  name: Array<LocalizedStringItemInputType>;
  resourceTypeIds: Array<Scalars['String']['input']>;
};

export type TypeDefinitionQueryResult = {
  __typename?: 'TypeDefinitionQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<TypeDefinition>;
  total: Scalars['Long']['output'];
};

export type TypeUpdateAction = {
  addEnumValue?: InputMaybe<AddTypeEnumValue>;
  addFieldDefinition?: InputMaybe<AddTypeFieldDefinition>;
  addLocalizedEnumValue?: InputMaybe<AddTypeLocalizedEnumValue>;
  changeEnumValueLabel?: InputMaybe<ChangeTypeEnumValueLabel>;
  changeEnumValueOrder?: InputMaybe<ChangeTypeEnumValueOrder>;
  changeFieldDefinitionOrder?: InputMaybe<ChangeTypeFieldDefinitionOrder>;
  changeInputHint?: InputMaybe<ChangeTypeInputHint>;
  changeKey?: InputMaybe<ChangeTypeKey>;
  changeLabel?: InputMaybe<ChangeTypeLabel>;
  changeLocalizedEnumValueLabel?: InputMaybe<ChangeTypeLocalizedEnumValueLabel>;
  changeLocalizedEnumValueOrder?: InputMaybe<ChangeTypeLocalizedEnumValueOrder>;
  changeName?: InputMaybe<ChangeTypeName>;
  removeFieldDefinition?: InputMaybe<RemoveTypeFieldDefinition>;
  setDescription?: InputMaybe<SetTypeDescription>;
};

export type UnfreezeCart = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type UnpublishProduct = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateCartItemShippingAddress = {
  address: AddressInput;
};

export type UpdateOrderItemShippingAddress = {
  address: AddressInput;
};

export type UpdateOrderSyncInfo = {
  channel: ResourceIdentifierInput;
  externalId?: InputMaybe<Scalars['String']['input']>;
  syncedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UpdateStagedOrderItemShippingAddress = {
  address: AddressInput;
};

export type UpdateStagedOrderItemShippingAddressOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'UpdateStagedOrderItemShippingAddressOutput';
  address: AddressDraft;
  type: Scalars['String']['output'];
};

export type UpdateStagedOrderSyncInfo = {
  channel: ResourceIdentifierInput;
  externalId?: InputMaybe<Scalars['String']['input']>;
  syncedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UpdateStagedOrderSyncInfoOutput = StagedOrderUpdateActionOutput & {
  __typename?: 'UpdateStagedOrderSyncInfoOutput';
  channelResId: ChannelReferenceIdentifier;
  externalId?: Maybe<Scalars['String']['output']>;
  syncedAt?: Maybe<Scalars['DateTime']['output']>;
  type: Scalars['String']['output'];
};

export type UserProvidedIdentifiers = {
  __typename?: 'UserProvidedIdentifiers';
  customerNumber?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  orderNumber?: Maybe<Scalars['String']['output']>;
  sku?: Maybe<Scalars['String']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  slugAllLocales?: Maybe<Array<LocalizedString>>;
};


export type UserProvidedIdentifiersSlugArgs = {
  acceptLanguage?: InputMaybe<Array<Scalars['Locale']['input']>>;
  locale?: InputMaybe<Scalars['Locale']['input']>;
};

export type ValueFacetResult = FacetResult & {
  __typename?: 'ValueFacetResult';
  count: Scalars['Int']['output'];
  productCount?: Maybe<Scalars['Int']['output']>;
  type: Scalars['String']['output'];
};

export type ValueFilterInput = {
  path: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

/** Versioned object have an ID and version and modification. Every update of this object changes it's version. */
export type Versioned = {
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  id: Scalars['String']['output'];
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  version: Scalars['Long']['output'];
};

export type WhitespaceSuggestTokenizer = SuggestTokenizer & {
  __typename?: 'WhitespaceSuggestTokenizer';
  type: Scalars['String']['output'];
};

export type WhitespaceSuggestTokenizerInput = {
  dummy?: InputMaybe<Scalars['String']['input']>;
};

export type WhitespaceSuggestTokenizerProductSearch = SuggestTokenizerProductSearch & {
  __typename?: 'WhitespaceSuggestTokenizerProductSearch';
  type: Scalars['String']['output'];
};

/** Zones allow defining ShippingRates for specific Locations. */
export type Zone = ReferenceExpandable & Versioned & {
  __typename?: 'Zone';
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Initiator>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key?: Maybe<Scalars['String']['output']>;
  lastModifiedAt: Scalars['DateTime']['output'];
  lastModifiedBy?: Maybe<Initiator>;
  locations: Array<Location>;
  name: Scalars['String']['output'];
  version: Scalars['Long']['output'];
};

export type ZoneLimitWithCurrent = LimitWithCurrent & {
  __typename?: 'ZoneLimitWithCurrent';
  current: Scalars['Long']['output'];
  limit?: Maybe<Scalars['Long']['output']>;
};

export type ZoneLimitsProjection = {
  __typename?: 'ZoneLimitsProjection';
  total: ZoneLimitWithCurrent;
};

export type ZoneLocation = {
  country: Scalars['Country']['input'];
  state?: InputMaybe<Scalars['String']['input']>;
};

export type ZoneQueryResult = {
  __typename?: 'ZoneQueryResult';
  count: Scalars['Int']['output'];
  /** BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta */
  exists: Scalars['Boolean']['output'];
  offset: Scalars['Int']['output'];
  results: Array<Zone>;
  total: Scalars['Long']['output'];
};

export type ZoneRate = {
  __typename?: 'ZoneRate';
  shippingRates: Array<ShippingRate>;
  zone?: Maybe<Zone>;
  zoneRef?: Maybe<Reference>;
};

export type ZoneRateDraft = {
  shippingRates?: InputMaybe<Array<ShippingRateDraft>>;
  zone: ResourceIdentifierInput;
};

export type ZoneUpdateAction = {
  addLocation?: InputMaybe<AddZoneLocation>;
  changeName?: InputMaybe<ChangeZoneName>;
  removeLocation?: InputMaybe<RemoveZoneLocation>;
  setDescription?: InputMaybe<SetZoneDescription>;
  setKey?: InputMaybe<SetZoneKey>;
};

export type AddAttributeDefinition = {
  attributeDefinition: AttributeDefinitionDraft;
};

export type AddLocalizedEnumValue = {
  attributeName: Scalars['String']['input'];
  value: LocalizedEnumValueDraft;
};

export type AddPlainEnumValue = {
  attributeName: Scalars['String']['input'];
  value: PlainEnumValueDraft;
};

export type ChangeAttributeName = {
  attributeName: Scalars['String']['input'];
  newAttributeName: Scalars['String']['input'];
};

export type ChangeAttributeOrder = {
  attributeDefinitions: Array<AttributeDefinitionDraft>;
};

export type ChangeAttributeOrderByName = {
  attributeNames: Array<Scalars['String']['input']>;
};

export type ChangeDescription = {
  description: Scalars['String']['input'];
};

export type ChangeEnumKey = {
  attributeName: Scalars['String']['input'];
  key: Scalars['String']['input'];
  newKey: Scalars['String']['input'];
};

export type ChangeInputHint = {
  attributeName: Scalars['String']['input'];
  newValue: TextInputHint;
};

export type ChangeIsSearchable = {
  attributeName: Scalars['String']['input'];
  isSearchable: Scalars['Boolean']['input'];
};

export type ChangeLabel = {
  attributeName: Scalars['String']['input'];
  label: Array<LocalizedStringItemInputType>;
};

export type ChangeLocalizedEnumValueLabel = {
  attributeName: Scalars['String']['input'];
  newValue: LocalizedEnumValueDraft;
};

export type ChangeLocalizedEnumValueOrder = {
  attributeName: Scalars['String']['input'];
  values: Array<LocalizedEnumValueDraft>;
};

export type ChangeName = {
  name: Scalars['String']['input'];
};

export type ChangePlainEnumValueLabel = {
  attributeName: Scalars['String']['input'];
  newValue: PlainEnumValueDraft;
};

export type ChangePlainEnumValueOrder = {
  attributeName: Scalars['String']['input'];
  values: Array<PlainEnumValueDraft>;
};

export type RemoveAttributeDefinition = {
  name: Scalars['String']['input'];
};

export type RemoveEnumValues = {
  attributeName: Scalars['String']['input'];
  keys: Array<Scalars['String']['input']>;
};

export type SetInputTip = {
  attributeName: Scalars['String']['input'];
  inputTip?: InputMaybe<Array<LocalizedStringItemInputType>>;
};

export type SetKey = {
  key?: InputMaybe<Scalars['String']['input']>;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;


/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = {
  ActiveCartInterface: ( InStoreMe ) | ( Me );
  Attribute: ( BooleanAttribute ) | ( DateAttribute ) | ( DateTimeAttribute ) | ( EnumAttribute ) | ( LocalizedEnumAttribute ) | ( LocalizedStringAttribute ) | ( MoneyAttribute ) | ( NumberAttribute ) | ( ReferenceAttribute ) | ( StringAttribute ) | ( TimeAttribute );
  AttributeDefinitionType: ( BooleanAttributeDefinitionType ) | ( DateAttributeDefinitionType ) | ( DateTimeAttributeDefinitionType ) | ( EnumAttributeDefinitionType ) | ( LocalizableEnumAttributeDefinitionType ) | ( LocalizableTextAttributeDefinitionType ) | ( MoneyAttributeDefinitionType ) | ( NestedAttributeDefinitionType ) | ( NumberAttributeDefinitionType ) | ( ReferenceAttributeDefinitionType ) | ( SetAttributeDefinitionType ) | ( TextAttributeDefinitionType ) | ( TimeAttributeDefinitionType );
  BaseMoney: ( HighPrecisionMoney ) | ( Money );
  CartDiscountQueryInterface: ( InStore );
  CartDiscountTarget: ( CustomLineItemsTarget ) | ( LineItemsTarget ) | ( MultiBuyCustomLineItemsTarget ) | ( MultiBuyLineItemsTarget ) | ( ShippingTarget );
  CartDiscountValue: ( AbsoluteDiscountValue ) | ( FixedPriceDiscountValue ) | ( GiftLineItemValue ) | ( RelativeDiscountValue );
  CartQueryInterface: ( AsAssociate ) | ( InStore ) | ( InStoreMe ) | ( Me ) | ( Query );
  CustomField: ( BooleanField ) | ( DateField ) | ( DateTimeField ) | ( EnumField ) | ( LocalizedEnumField ) | ( LocalizedStringField ) | ( MoneyField ) | ( NumberField ) | ( ReferenceField ) | ( StringField ) | ( TimeField );
  CustomerActiveCartInterface: ( InStore ) | ( Query );
  CustomerQueryInterface: ( InStore ) | ( Query );
  Destination: ( AzureServiceBusDestination ) | ( ConfluentCloudDestination ) | ( EventBridgeDestination ) | ( EventGridDestination ) | ( GoogleCloudPubSubDestination ) | ( SnsDestination ) | ( SqsDestination );
  ExtensionDestination: ( AwsLambdaDestination ) | ( GoogleCloudFunctionDestination ) | ( HttpDestination );
  FacetResult: ( RangeFacetResult ) | ( TermsFacetResult ) | ( ValueFacetResult );
  FieldType: ( BooleanType ) | ( DateTimeType ) | ( DateType ) | ( EnumType ) | ( LocalizedEnumType ) | ( LocalizedStringType ) | ( MoneyType ) | ( NumberType ) | ( ReferenceType ) | ( SetType ) | ( StringType ) | ( TimeType );
  Geometry: ( Point );
  HttpDestinationAuthentication: ( AuthorizationHeader ) | ( AzureFunctionsAuthentication );
  LimitWithCurrent: ( AttributeGroupLimitWithCurrent ) | ( CartDiscountLimitWithCurrent ) | ( CartLimitWithCurrent ) | ( CustomObjectLimitWithCurrent ) | ( CustomerGroupLimitWithCurrent ) | ( CustomerLimitWithCurrent ) | ( OrderEditLimitWithCurrent ) | ( ProductDiscountLimitWithCurrent ) | ( ProductTypeLimitWithCurrent ) | ( RefreshTokenLimitWithCurrent ) | ( ShippingMethodLimitWithCurrent ) | ( ShoppingListLimitWithCurrent ) | ( StoreLimitWithCurrent ) | ( TaxCategoryLimitWithCurrent ) | ( ZoneLimitWithCurrent );
  MeFieldInterface: ( InStore ) | ( Query );
  MeQueryInterface: ( InStoreMe ) | ( Me );
  MessagePayload: ( ApprovalFlowApproved ) | ( ApprovalFlowCompleted ) | ( ApprovalFlowCreated ) | ( ApprovalFlowRejected ) | ( AssociateRoleBuyerAssignableChanged ) | ( AssociateRoleCreated ) | ( AssociateRoleDeleted ) | ( AssociateRoleNameSet ) | ( AssociateRolePermissionAdded ) | ( AssociateRolePermissionRemoved ) | ( AssociateRolePermissionsSet ) | ( BusinessUnitAddressAdded ) | ( BusinessUnitAddressChanged ) | ( BusinessUnitAddressRemoved ) | ( BusinessUnitAssociateAdded ) | ( BusinessUnitAssociateChanged ) | ( BusinessUnitAssociateModeChanged ) | ( BusinessUnitAssociateRemoved ) | ( BusinessUnitAssociatesSet ) | ( BusinessUnitBillingAddressAdded ) | ( BusinessUnitBillingAddressRemoved ) | ( BusinessUnitContactEmailSet ) | ( BusinessUnitCreated ) | ( BusinessUnitDefaultBillingAddressSet ) | ( BusinessUnitDefaultShippingAddressSet ) | ( BusinessUnitDeleted ) | ( BusinessUnitNameChanged ) | ( BusinessUnitParentChanged ) | ( BusinessUnitShippingAddressAdded ) | ( BusinessUnitShippingAddressRemoved ) | ( BusinessUnitStatusChanged ) | ( BusinessUnitStoreAdded ) | ( BusinessUnitStoreModeChanged ) | ( BusinessUnitStoreRemoved ) | ( BusinessUnitStoresSet ) | ( CartCreated ) | ( CategoryCreated ) | ( CategorySlugChanged ) | ( CustomLineItemStateTransition ) | ( CustomerAddressAdded ) | ( CustomerAddressChanged ) | ( CustomerAddressRemoved ) | ( CustomerCompanyNameSet ) | ( CustomerCreated ) | ( CustomerDateOfBirthSet ) | ( CustomerDeleted ) | ( CustomerEmailChanged ) | ( CustomerEmailTokenCreated ) | ( CustomerEmailVerified ) | ( CustomerFirstNameSet ) | ( CustomerGroupSet ) | ( CustomerLastNameSet ) | ( CustomerPasswordTokenCreated ) | ( CustomerPasswordUpdated ) | ( CustomerTitleSet ) | ( DeliveryAdded ) | ( DeliveryAddressSet ) | ( DeliveryItemsUpdated ) | ( DeliveryRemoved ) | ( InventoryEntryCreated ) | ( InventoryEntryDeleted ) | ( InventoryEntryQuantitySet ) | ( LineItemStateTransition ) | ( OrderBillingAddressSet ) | ( OrderCreated ) | ( OrderCustomFieldAdded ) | ( OrderCustomFieldChanged ) | ( OrderCustomFieldRemoved ) | ( OrderCustomLineItemAdded ) | ( OrderCustomLineItemDiscountSet ) | ( OrderCustomLineItemQuantityChanged ) | ( OrderCustomLineItemRemoved ) | ( OrderCustomTypeRemoved ) | ( OrderCustomTypeSet ) | ( OrderCustomerEmailSet ) | ( OrderCustomerGroupSet ) | ( OrderCustomerSet ) | ( OrderDeleted ) | ( OrderDiscountCodeAdded ) | ( OrderDiscountCodeRemoved ) | ( OrderDiscountCodeStateSet ) | ( OrderEditApplied ) | ( OrderImported ) | ( OrderLineItemAdded ) | ( OrderLineItemDiscountSet ) | ( OrderLineItemDistributionChannelSet ) | ( OrderLineItemRemoved ) | ( OrderPaymentAdded ) | ( OrderPaymentRemoved ) | ( OrderPaymentStateChanged ) | ( OrderReturnShipmentStateChanged ) | ( OrderShipmentStateChanged ) | ( OrderShippingAddressSet ) | ( OrderShippingInfoSet ) | ( OrderShippingRateInputSet ) | ( OrderStateChanged ) | ( OrderStateTransition ) | ( OrderStoreSet ) | ( ParcelAddedToDelivery ) | ( ParcelItemsUpdated ) | ( ParcelMeasurementsUpdated ) | ( ParcelRemovedFromDelivery ) | ( ParcelTrackingDataUpdated ) | ( PaymentCreated ) | ( PaymentInteractionAdded ) | ( PaymentStatusInterfaceCodeSet ) | ( PaymentStatusStateTransition ) | ( PaymentTransactionAdded ) | ( PaymentTransactionStateChanged ) | ( ProductAddedToCategory ) | ( ProductCreated ) | ( ProductDeleted ) | ( ProductImageAdded ) | ( ProductPriceAdded ) | ( ProductPriceChanged ) | ( ProductPriceDiscountsSet ) | ( ProductPriceExternalDiscountSet ) | ( ProductPriceKeySet ) | ( ProductPriceModeSet ) | ( ProductPriceRemoved ) | ( ProductPricesSet ) | ( ProductPublished ) | ( ProductRemovedFromCategory ) | ( ProductRevertedStagedChanges ) | ( ProductSelectionCreated ) | ( ProductSelectionDeleted ) | ( ProductSelectionProductAdded ) | ( ProductSelectionProductExcluded ) | ( ProductSelectionProductRemoved ) | ( ProductSelectionVariantExclusionChanged ) | ( ProductSelectionVariantSelectionChanged ) | ( ProductSlugChanged ) | ( ProductStateTransition ) | ( ProductUnpublished ) | ( ProductVariantAdded ) | ( ProductVariantDeleted ) | ( PurchaseOrderNumberSet ) | ( ReturnInfoAdded ) | ( ReturnInfoSet ) | ( ReviewCreated ) | ( ReviewRatingSet ) | ( ReviewStateTransition ) | ( StandalonePriceActiveChanged ) | ( StandalonePriceCreated ) | ( StandalonePriceDeleted ) | ( StandalonePriceDiscountSet ) | ( StandalonePriceExpiresAtSet ) | ( StandalonePriceExternalDiscountSet ) | ( StandalonePriceKeySet ) | ( StandalonePriceStagedChangesApplied ) | ( StandalonePriceStagedChangesRemoved ) | ( StandalonePriceTierAdded ) | ( StandalonePriceTierRemoved ) | ( StandalonePriceTiersSet ) | ( StandalonePriceValidFromAndUntilSet ) | ( StandalonePriceValidFromSet ) | ( StandalonePriceValidUntilSet ) | ( StandalonePriceValueChanged ) | ( StoreCountriesChanged ) | ( StoreCreated ) | ( StoreDeleted ) | ( StoreDistributionChannelsChanged ) | ( StoreLanguagesChanged ) | ( StoreNameSet ) | ( StoreProductSelectionsChanged ) | ( StoreSupplyChannelsChanged );
  NotificationFormat: ( CloudEventsSubscriptionsFormat ) | ( PlatformFormat );
  OrderEditResult: ( Applied ) | ( NotProcessed ) | ( PreviewFailure ) | ( PreviewSuccess );
  OrderMessagePayload: ( CustomLineItemStateTransition ) | ( DeliveryAdded ) | ( DeliveryAddressSet ) | ( DeliveryItemsUpdated ) | ( DeliveryRemoved ) | ( LineItemStateTransition ) | ( OrderBillingAddressSet ) | ( OrderCreated ) | ( OrderCustomFieldAdded ) | ( OrderCustomFieldChanged ) | ( OrderCustomFieldRemoved ) | ( OrderCustomLineItemAdded ) | ( OrderCustomLineItemDiscountSet ) | ( OrderCustomLineItemQuantityChanged ) | ( OrderCustomLineItemRemoved ) | ( OrderCustomTypeRemoved ) | ( OrderCustomTypeSet ) | ( OrderCustomerEmailSet ) | ( OrderCustomerGroupSet ) | ( OrderCustomerSet ) | ( OrderDeleted ) | ( OrderDiscountCodeAdded ) | ( OrderDiscountCodeRemoved ) | ( OrderDiscountCodeStateSet ) | ( OrderEditApplied ) | ( OrderImported ) | ( OrderLineItemAdded ) | ( OrderLineItemDiscountSet ) | ( OrderLineItemDistributionChannelSet ) | ( OrderLineItemRemoved ) | ( OrderPaymentAdded ) | ( OrderPaymentRemoved ) | ( OrderPaymentStateChanged ) | ( OrderReturnShipmentStateChanged ) | ( OrderShipmentStateChanged ) | ( OrderShippingAddressSet ) | ( OrderShippingInfoSet ) | ( OrderShippingRateInputSet ) | ( OrderStateChanged ) | ( OrderStateTransition ) | ( OrderStoreSet ) | ( ParcelAddedToDelivery ) | ( ParcelItemsUpdated ) | ( ParcelMeasurementsUpdated ) | ( ParcelRemovedFromDelivery ) | ( ParcelTrackingDataUpdated ) | ( PurchaseOrderNumberSet ) | ( ReturnInfoAdded ) | ( ReturnInfoSet );
  OrderQueryInterface: ( AsAssociate ) | ( InStore ) | ( InStoreMe ) | ( Me ) | ( Query );
  ProductDiscountValue: ( AbsoluteDiscountValue ) | ( ExternalDiscountValue ) | ( RelativeDiscountValue );
  ProductSelectionQueryInterface: ( Query );
  ProductVariantSelection: ( ProductVariantSelectionIncludeAllExcept ) | ( ProductVariantSelectionIncludeOnly );
  QuoteQueryInterface: ( AsAssociate );
  QuoteRequestQueryInterface: ( AsAssociate );
  RangeCount: ( RangeCountDouble ) | ( RangeCountLong );
  ReferenceExpandable: ( Cart ) | ( CartDiscount ) | ( Category ) | ( Channel ) | ( CustomObject ) | ( Customer ) | ( CustomerGroup ) | ( DiscountCode ) | ( Extension ) | ( InventoryEntry ) | ( Message ) | ( Order ) | ( Product ) | ( ProductDiscount ) | ( ProductTypeDefinition ) | ( Review ) | ( ShippingMethod ) | ( ShoppingList ) | ( State ) | ( Store ) | ( TaxCategory ) | ( TypeDefinition ) | ( Zone );
  ReturnItem: ( CustomLineItemReturnItem ) | ( LineItemReturnItem );
  ReviewTarget: ( Channel ) | ( Product );
  ShippingMethodsByCartInterface: ( InStore ) | ( Query );
  ShippingRateInput: ( ClassificationShippingRateInput ) | ( ScoreShippingRateInput );
  ShippingRateInputDraftOutput: ( ClassificationShippingRateInputDraftOutput ) | ( ScoreShippingRateInputDraftOutput );
  ShippingRateInputType: ( CartClassificationType ) | ( CartScoreType ) | ( CartValueType );
  ShippingRatePriceTier: ( ShippingRateCartClassificationPriceTier ) | ( ShippingRateCartScorePriceTier ) | ( ShippingRateCartValuePriceTier );
  ShoppingListQueryInterface: ( InStoreMe ) | ( Me ) | ( Query );
  StagedOrderUpdateActionOutput: ( AddStagedOrderCustomLineItemOutput ) | ( AddStagedOrderDeliveryOutput ) | ( AddStagedOrderDiscountCodeOutput ) | ( AddStagedOrderItemShippingAddressOutput ) | ( AddStagedOrderLineItemOutput ) | ( AddStagedOrderParcelToDeliveryOutput ) | ( AddStagedOrderPaymentOutput ) | ( AddStagedOrderReturnInfoOutput ) | ( AddStagedOrderShoppingListOutput ) | ( ChangeStagedOrderCustomLineItemMoneyOutput ) | ( ChangeStagedOrderCustomLineItemQuantityOutput ) | ( ChangeStagedOrderLineItemQuantityOutput ) | ( ChangeStagedOrderOrderStateOutput ) | ( ChangeStagedOrderPaymentStateOutput ) | ( ChangeStagedOrderShipmentStateOutput ) | ( ChangeStagedOrderTaxCalculationModeOutput ) | ( ChangeStagedOrderTaxModeOutput ) | ( ChangeStagedOrderTaxRoundingModeOutput ) | ( ImportStagedOrderCustomLineItemStateOutput ) | ( ImportStagedOrderLineItemStateOutput ) | ( RecalculateStagedOrderOutput ) | ( RemoveStagedOrderCustomLineItemOutput ) | ( RemoveStagedOrderDeliveryOutput ) | ( RemoveStagedOrderDiscountCodeOutput ) | ( RemoveStagedOrderItemShippingAddressOutput ) | ( RemoveStagedOrderLineItemOutput ) | ( RemoveStagedOrderParcelFromDeliveryOutput ) | ( RemoveStagedOrderPaymentOutput ) | ( SetStagedOrderBillingAddressCustomFieldOutput ) | ( SetStagedOrderBillingAddressCustomTypeOutput ) | ( SetStagedOrderBillingAddressOutput ) | ( SetStagedOrderCountryOutput ) | ( SetStagedOrderCustomFieldOutput ) | ( SetStagedOrderCustomLineItemCustomFieldOutput ) | ( SetStagedOrderCustomLineItemCustomTypeOutput ) | ( SetStagedOrderCustomLineItemShippingDetailsOutput ) | ( SetStagedOrderCustomLineItemTaxAmountOutput ) | ( SetStagedOrderCustomLineItemTaxRateOutput ) | ( SetStagedOrderCustomShippingMethodOutput ) | ( SetStagedOrderCustomTypeOutput ) | ( SetStagedOrderCustomerEmailOutput ) | ( SetStagedOrderCustomerGroupOutput ) | ( SetStagedOrderCustomerIdOutput ) | ( SetStagedOrderDeliveryAddressCustomFieldOutput ) | ( SetStagedOrderDeliveryAddressCustomTypeOutput ) | ( SetStagedOrderDeliveryAddressOutput ) | ( SetStagedOrderDeliveryCustomFieldOutput ) | ( SetStagedOrderDeliveryCustomTypeOutput ) | ( SetStagedOrderDeliveryItemsOutput ) | ( SetStagedOrderDirectDiscountsOutput ) | ( SetStagedOrderItemShippingAddressCustomFieldOutput ) | ( SetStagedOrderItemShippingAddressCustomTypeOutput ) | ( SetStagedOrderLineItemCustomFieldOutput ) | ( SetStagedOrderLineItemCustomTypeOutput ) | ( SetStagedOrderLineItemDistributionChannelOutput ) | ( SetStagedOrderLineItemPriceOutput ) | ( SetStagedOrderLineItemShippingDetailsOutput ) | ( SetStagedOrderLineItemTaxAmountOutput ) | ( SetStagedOrderLineItemTaxRateOutput ) | ( SetStagedOrderLineItemTotalPriceOutput ) | ( SetStagedOrderLocaleOutput ) | ( SetStagedOrderOrderNumberOutput ) | ( SetStagedOrderOrderTotalTaxOutput ) | ( SetStagedOrderParcelCustomFieldOutput ) | ( SetStagedOrderParcelCustomTypeOutput ) | ( SetStagedOrderParcelItemsOutput ) | ( SetStagedOrderParcelMeasurementsOutput ) | ( SetStagedOrderParcelTrackingDataOutput ) | ( SetStagedOrderPurchaseOrderNumberOutput ) | ( SetStagedOrderReturnInfoOutput ) | ( SetStagedOrderReturnItemCustomFieldOutput ) | ( SetStagedOrderReturnItemCustomTypeOutput ) | ( SetStagedOrderReturnPaymentStateOutput ) | ( SetStagedOrderReturnShipmentStateOutput ) | ( SetStagedOrderShippingAddressAndCustomShippingMethodOutput ) | ( SetStagedOrderShippingAddressAndShippingMethodOutput ) | ( SetStagedOrderShippingAddressCustomFieldOutput ) | ( SetStagedOrderShippingAddressCustomTypeOutput ) | ( SetStagedOrderShippingAddressOutput ) | ( SetStagedOrderShippingCustomFieldOutput ) | ( SetStagedOrderShippingCustomTypeOutput ) | ( SetStagedOrderShippingMethodOutput ) | ( SetStagedOrderShippingMethodTaxAmountOutput ) | ( SetStagedOrderShippingMethodTaxRateOutput ) | ( SetStagedOrderShippingRateInputOutput ) | ( SetStagedOrderStoreOutput ) | ( TransitionStagedOrderCustomLineItemStateOutput ) | ( TransitionStagedOrderLineItemStateOutput ) | ( TransitionStagedOrderStateOutput ) | ( UpdateStagedOrderItemShippingAddressOutput ) | ( UpdateStagedOrderSyncInfoOutput );
  SuggestTokenizer: ( CustomSuggestTokenizer ) | ( WhitespaceSuggestTokenizer );
  SuggestTokenizerProductSearch: ( CustomSuggestTokenizerProductSearch ) | ( WhitespaceSuggestTokenizerProductSearch );
  Versioned: ( ApprovalFlow ) | ( ApprovalRule ) | ( AssociateRole ) | ( AttributeGroup ) | ( BusinessUnit ) | ( Cart ) | ( CartDiscount ) | ( Category ) | ( Channel ) | ( CommercetoolsSubscription ) | ( CustomObject ) | ( Customer ) | ( CustomerEmailToken ) | ( CustomerGroup ) | ( CustomerPasswordToken ) | ( DiscountCode ) | ( Extension ) | ( InventoryEntry ) | ( Message ) | ( Order ) | ( OrderEdit ) | ( Payment ) | ( Product ) | ( ProductDiscount ) | ( ProductSelection ) | ( ProductTypeDefinition ) | ( Quote ) | ( QuoteRequest ) | ( Review ) | ( ShippingMethod ) | ( ShoppingList ) | ( StagedQuote ) | ( StandalonePrice ) | ( State ) | ( Store ) | ( TaxCategory ) | ( TypeDefinition ) | ( Zone );
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  APIClientWithSecret: ResolverTypeWrapper<ApiClientWithSecret>;
  APIClientWithoutSecret: ResolverTypeWrapper<ApiClientWithoutSecret>;
  APIClientWithoutSecretQueryResult: ResolverTypeWrapper<ApiClientWithoutSecretQueryResult>;
  AWSLambdaDestination: ResolverTypeWrapper<AwsLambdaDestination>;
  AWSLambdaDestinationInput: AwsLambdaDestinationInput;
  AbsoluteDiscountValue: ResolverTypeWrapper<AbsoluteDiscountValue>;
  AbsoluteDiscountValueInput: AbsoluteDiscountValueInput;
  ActionType: ActionType;
  ActiveCartInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ActiveCartInterface']>;
  AddAssociateRolePermission: AddAssociateRolePermission;
  AddAttributeGroupAttribute: AddAttributeGroupAttribute;
  AddBusinessUnitAddress: AddBusinessUnitAddress;
  AddBusinessUnitAssociate: AddBusinessUnitAssociate;
  AddBusinessUnitBillingAddressId: AddBusinessUnitBillingAddressId;
  AddBusinessUnitShippingAddressId: AddBusinessUnitShippingAddressId;
  AddBusinessUnitStore: AddBusinessUnitStore;
  AddCartCustomLineItem: AddCartCustomLineItem;
  AddCartCustomShippingMethod: AddCartCustomShippingMethod;
  AddCartDiscountCode: AddCartDiscountCode;
  AddCartDiscountStore: AddCartDiscountStore;
  AddCartItemShippingAddress: AddCartItemShippingAddress;
  AddCartLineItem: AddCartLineItem;
  AddCartPayment: AddCartPayment;
  AddCartShippingMethod: AddCartShippingMethod;
  AddCartShoppingList: AddCartShoppingList;
  AddCategoryAsset: AddCategoryAsset;
  AddChannelRoles: AddChannelRoles;
  AddCustomerAddress: AddCustomerAddress;
  AddCustomerBillingAddressId: AddCustomerBillingAddressId;
  AddCustomerShippingAddressId: AddCustomerShippingAddressId;
  AddCustomerStore: AddCustomerStore;
  AddInventoryEntryQuantity: AddInventoryEntryQuantity;
  AddMyBusinessUnitAddress: AddMyBusinessUnitAddress;
  AddMyBusinessUnitBillingAddressId: AddMyBusinessUnitBillingAddressId;
  AddMyBusinessUnitShippingAddressId: AddMyBusinessUnitShippingAddressId;
  AddMyCartLineItem: AddMyCartLineItem;
  AddMyPaymentTransaction: AddMyPaymentTransaction;
  AddOrderDelivery: AddOrderDelivery;
  AddOrderEditStagedAction: AddOrderEditStagedAction;
  AddOrderItemShippingAddress: AddOrderItemShippingAddress;
  AddOrderParcelToDelivery: AddOrderParcelToDelivery;
  AddOrderPayment: AddOrderPayment;
  AddOrderReturnInfo: AddOrderReturnInfo;
  AddPaymentInterfaceInteraction: AddPaymentInterfaceInteraction;
  AddPaymentTransaction: AddPaymentTransaction;
  AddProductAsset: AddProductAsset;
  AddProductExternalImage: AddProductExternalImage;
  AddProductPrice: AddProductPrice;
  AddProductSelectionProduct: AddProductSelectionProduct;
  AddProductToCategory: AddProductToCategory;
  AddProductVariant: AddProductVariant;
  AddShippingMethodShippingRate: AddShippingMethodShippingRate;
  AddShippingMethodZone: AddShippingMethodZone;
  AddShoppingListLineItem: AddShoppingListLineItem;
  AddShoppingListTextLineItem: AddShoppingListTextLineItem;
  AddStagedOrderCustomLineItem: AddStagedOrderCustomLineItem;
  AddStagedOrderCustomLineItemOutput: ResolverTypeWrapper<AddStagedOrderCustomLineItemOutput>;
  AddStagedOrderDelivery: AddStagedOrderDelivery;
  AddStagedOrderDeliveryOutput: ResolverTypeWrapper<AddStagedOrderDeliveryOutput>;
  AddStagedOrderDiscountCode: AddStagedOrderDiscountCode;
  AddStagedOrderDiscountCodeOutput: ResolverTypeWrapper<AddStagedOrderDiscountCodeOutput>;
  AddStagedOrderItemShippingAddress: AddStagedOrderItemShippingAddress;
  AddStagedOrderItemShippingAddressOutput: ResolverTypeWrapper<AddStagedOrderItemShippingAddressOutput>;
  AddStagedOrderLineItem: AddStagedOrderLineItem;
  AddStagedOrderLineItemOutput: ResolverTypeWrapper<AddStagedOrderLineItemOutput>;
  AddStagedOrderParcelToDelivery: AddStagedOrderParcelToDelivery;
  AddStagedOrderParcelToDeliveryOutput: ResolverTypeWrapper<AddStagedOrderParcelToDeliveryOutput>;
  AddStagedOrderPayment: AddStagedOrderPayment;
  AddStagedOrderPaymentOutput: ResolverTypeWrapper<AddStagedOrderPaymentOutput>;
  AddStagedOrderReturnInfo: AddStagedOrderReturnInfo;
  AddStagedOrderReturnInfoOutput: ResolverTypeWrapper<AddStagedOrderReturnInfoOutput>;
  AddStagedOrderShoppingList: AddStagedOrderShoppingList;
  AddStagedOrderShoppingListOutput: ResolverTypeWrapper<AddStagedOrderShoppingListOutput>;
  AddStandalonePriceTier: AddStandalonePriceTier;
  AddStateRoles: AddStateRoles;
  AddStoreCountry: AddStoreCountry;
  AddStoreDistributionChannel: AddStoreDistributionChannel;
  AddStoreProductSelection: AddStoreProductSelection;
  AddStoreSupplyChannel: AddStoreSupplyChannel;
  AddTypeEnumValue: AddTypeEnumValue;
  AddTypeFieldDefinition: AddTypeFieldDefinition;
  AddTypeLocalizedEnumValue: AddTypeLocalizedEnumValue;
  AddZoneLocation: AddZoneLocation;
  Address: ResolverTypeWrapper<Address>;
  AddressDraft: ResolverTypeWrapper<AddressDraft>;
  AddressInput: AddressInput;
  AnonymousCartSignInMode: AnonymousCartSignInMode;
  Applied: ResolverTypeWrapper<Applied>;
  ApplyCartDeltaToCustomLineItemShippingDetailsTargets: ApplyCartDeltaToCustomLineItemShippingDetailsTargets;
  ApplyCartDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets;
  ApplyStagedChanges: ApplyStagedChanges;
  ApprovalFlow: ResolverTypeWrapper<ApprovalFlow>;
  ApprovalFlowApproval: ResolverTypeWrapper<ApprovalFlowApproval>;
  ApprovalFlowApproved: ResolverTypeWrapper<ApprovalFlowApproved>;
  ApprovalFlowCompleted: ResolverTypeWrapper<ApprovalFlowCompleted>;
  ApprovalFlowCreated: ResolverTypeWrapper<ApprovalFlowCreated>;
  ApprovalFlowQueryResult: ResolverTypeWrapper<ApprovalFlowQueryResult>;
  ApprovalFlowRejected: ResolverTypeWrapper<ApprovalFlowRejected>;
  ApprovalFlowRejection: ResolverTypeWrapper<ApprovalFlowRejection>;
  ApprovalFlowUpdateAction: ApprovalFlowUpdateAction;
  ApprovalRule: ResolverTypeWrapper<ApprovalRule>;
  ApprovalRuleDraft: ApprovalRuleDraft;
  ApprovalRuleQueryResult: ResolverTypeWrapper<ApprovalRuleQueryResult>;
  ApprovalRuleStatus: ApprovalRuleStatus;
  ApprovalRuleUpdateAction: ApprovalRuleUpdateAction;
  ApproveApprovalFlow: ApproveApprovalFlow;
  ApproverConjunction: ResolverTypeWrapper<ApproverConjunction>;
  ApproverConjunctionDraft: ApproverConjunctionDraft;
  ApproverDisjunction: ResolverTypeWrapper<ApproverDisjunction>;
  ApproverDisjunctionDraft: ApproverDisjunctionDraft;
  ApproverHierarchy: ResolverTypeWrapper<ApproverHierarchy>;
  ApproverHierarchyDraft: ApproverHierarchyDraft;
  AsAssociate: ResolverTypeWrapper<AsAssociate>;
  AsAssociateArgument: AsAssociateArgument;
  Asset: ResolverTypeWrapper<Asset>;
  AssetDimensions: ResolverTypeWrapper<AssetDimensions>;
  AssetDimensionsInput: AssetDimensionsInput;
  AssetDraftInput: AssetDraftInput;
  AssetSource: ResolverTypeWrapper<AssetSource>;
  AssetSourceInput: AssetSourceInput;
  Associate: ResolverTypeWrapper<Associate>;
  AssociateDraft: AssociateDraft;
  AssociateInheritanceMode: AssociateInheritanceMode;
  AssociateRole: ResolverTypeWrapper<AssociateRole>;
  AssociateRoleAssignment: ResolverTypeWrapper<AssociateRoleAssignment>;
  AssociateRoleAssignmentDraft: AssociateRoleAssignmentDraft;
  AssociateRoleBuyerAssignableChanged: ResolverTypeWrapper<AssociateRoleBuyerAssignableChanged>;
  AssociateRoleCreated: ResolverTypeWrapper<AssociateRoleCreated>;
  AssociateRoleDeleted: ResolverTypeWrapper<AssociateRoleDeleted>;
  AssociateRoleDraft: AssociateRoleDraft;
  AssociateRoleNameSet: ResolverTypeWrapper<AssociateRoleNameSet>;
  AssociateRolePermissionAdded: ResolverTypeWrapper<AssociateRolePermissionAdded>;
  AssociateRolePermissionRemoved: ResolverTypeWrapper<AssociateRolePermissionRemoved>;
  AssociateRolePermissionsSet: ResolverTypeWrapper<AssociateRolePermissionsSet>;
  AssociateRoleQueryResult: ResolverTypeWrapper<AssociateRoleQueryResult>;
  AssociateRoleUpdateAction: AssociateRoleUpdateAction;
  Attribute: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Attribute']>;
  AttributeConstraint: AttributeConstraint;
  AttributeDefinition: ResolverTypeWrapper<AttributeDefinition>;
  AttributeDefinitionDraft: AttributeDefinitionDraft;
  AttributeDefinitionResult: ResolverTypeWrapper<AttributeDefinitionResult>;
  AttributeDefinitionType: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['AttributeDefinitionType']>;
  AttributeGroup: ResolverTypeWrapper<AttributeGroup>;
  AttributeGroupDraft: AttributeGroupDraft;
  AttributeGroupLimitWithCurrent: ResolverTypeWrapper<AttributeGroupLimitWithCurrent>;
  AttributeGroupLimitsProjection: ResolverTypeWrapper<AttributeGroupLimitsProjection>;
  AttributeGroupQueryResult: ResolverTypeWrapper<AttributeGroupQueryResult>;
  AttributeGroupUpdateAction: AttributeGroupUpdateAction;
  AttributeReference: ResolverTypeWrapper<AttributeReference>;
  AttributeReferenceInput: AttributeReferenceInput;
  AttributeSetElementTypeDraft: AttributeSetElementTypeDraft;
  AttributeSetTypeDraft: AttributeSetTypeDraft;
  AttributeTypeDraft: AttributeTypeDraft;
  AuthenticationMode: AuthenticationMode;
  AuthorizationHeader: ResolverTypeWrapper<AuthorizationHeader>;
  AuthorizationHeaderInput: AuthorizationHeaderInput;
  AwsAuthenticationMode: AwsAuthenticationMode;
  AzureFunctionsAuthentication: ResolverTypeWrapper<AzureFunctionsAuthentication>;
  AzureFunctionsAuthenticationInput: AzureFunctionsAuthenticationInput;
  AzureServiceBusDestination: ResolverTypeWrapper<AzureServiceBusDestination>;
  AzureServiceBusDestinationInput: AzureServiceBusDestinationInput;
  BaseMoney: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['BaseMoney']>;
  BaseMoneyInput: BaseMoneyInput;
  BaseSearchKeywordInput: BaseSearchKeywordInput;
  BigDecimal: ResolverTypeWrapper<Scalars['BigDecimal']['output']>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  BooleanAttribute: ResolverTypeWrapper<BooleanAttribute>;
  BooleanAttributeDefinitionType: ResolverTypeWrapper<BooleanAttributeDefinitionType>;
  BooleanField: ResolverTypeWrapper<BooleanField>;
  BooleanType: ResolverTypeWrapper<BooleanType>;
  BusinessUnit: ResolverTypeWrapper<BusinessUnit>;
  BusinessUnitAddressAdded: ResolverTypeWrapper<BusinessUnitAddressAdded>;
  BusinessUnitAddressChanged: ResolverTypeWrapper<BusinessUnitAddressChanged>;
  BusinessUnitAddressRemoved: ResolverTypeWrapper<BusinessUnitAddressRemoved>;
  BusinessUnitAssociateAdded: ResolverTypeWrapper<BusinessUnitAssociateAdded>;
  BusinessUnitAssociateChanged: ResolverTypeWrapper<BusinessUnitAssociateChanged>;
  BusinessUnitAssociateMode: BusinessUnitAssociateMode;
  BusinessUnitAssociateModeChanged: ResolverTypeWrapper<BusinessUnitAssociateModeChanged>;
  BusinessUnitAssociateRemoved: ResolverTypeWrapper<BusinessUnitAssociateRemoved>;
  BusinessUnitAssociatesSet: ResolverTypeWrapper<BusinessUnitAssociatesSet>;
  BusinessUnitBillingAddressAdded: ResolverTypeWrapper<BusinessUnitBillingAddressAdded>;
  BusinessUnitBillingAddressRemoved: ResolverTypeWrapper<BusinessUnitBillingAddressRemoved>;
  BusinessUnitConfiguration: ResolverTypeWrapper<BusinessUnitConfiguration>;
  BusinessUnitConfigurationStatus: BusinessUnitConfigurationStatus;
  BusinessUnitContactEmailSet: ResolverTypeWrapper<BusinessUnitContactEmailSet>;
  BusinessUnitCreated: ResolverTypeWrapper<BusinessUnitCreated>;
  BusinessUnitDefaultBillingAddressSet: ResolverTypeWrapper<BusinessUnitDefaultBillingAddressSet>;
  BusinessUnitDefaultShippingAddressSet: ResolverTypeWrapper<BusinessUnitDefaultShippingAddressSet>;
  BusinessUnitDeleted: ResolverTypeWrapper<BusinessUnitDeleted>;
  BusinessUnitDraft: BusinessUnitDraft;
  BusinessUnitNameChanged: ResolverTypeWrapper<BusinessUnitNameChanged>;
  BusinessUnitParentChanged: ResolverTypeWrapper<BusinessUnitParentChanged>;
  BusinessUnitQueryResult: ResolverTypeWrapper<BusinessUnitQueryResult>;
  BusinessUnitShippingAddressAdded: ResolverTypeWrapper<BusinessUnitShippingAddressAdded>;
  BusinessUnitShippingAddressRemoved: ResolverTypeWrapper<BusinessUnitShippingAddressRemoved>;
  BusinessUnitStatus: BusinessUnitStatus;
  BusinessUnitStatusChanged: ResolverTypeWrapper<BusinessUnitStatusChanged>;
  BusinessUnitStoreAdded: ResolverTypeWrapper<BusinessUnitStoreAdded>;
  BusinessUnitStoreModeChanged: ResolverTypeWrapper<BusinessUnitStoreModeChanged>;
  BusinessUnitStoreRemoved: ResolverTypeWrapper<BusinessUnitStoreRemoved>;
  BusinessUnitStoresSet: ResolverTypeWrapper<BusinessUnitStoresSet>;
  BusinessUnitType: BusinessUnitType;
  BusinessUnitUpdateAction: BusinessUnitUpdateAction;
  CancelQuoteRequest: CancelQuoteRequest;
  Cart: ResolverTypeWrapper<Cart>;
  CartClassificationInput: CartClassificationInput;
  CartClassificationType: ResolverTypeWrapper<CartClassificationType>;
  CartCreated: ResolverTypeWrapper<CartCreated>;
  CartDiscount: ResolverTypeWrapper<CartDiscount>;
  CartDiscountDraft: CartDiscountDraft;
  CartDiscountLimitWithCurrent: ResolverTypeWrapper<CartDiscountLimitWithCurrent>;
  CartDiscountLimitsProjection: ResolverTypeWrapper<CartDiscountLimitsProjection>;
  CartDiscountQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CartDiscountQueryInterface']>;
  CartDiscountQueryResult: ResolverTypeWrapper<CartDiscountQueryResult>;
  CartDiscountTarget: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CartDiscountTarget']>;
  CartDiscountTargetInput: CartDiscountTargetInput;
  CartDiscountUpdateAction: CartDiscountUpdateAction;
  CartDiscountValue: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CartDiscountValue']>;
  CartDiscountValueBaseMoneyInput: CartDiscountValueBaseMoneyInput;
  CartDiscountValueInput: CartDiscountValueInput;
  CartDraft: CartDraft;
  CartLimitWithCurrent: ResolverTypeWrapper<CartLimitWithCurrent>;
  CartLimitsProjection: ResolverTypeWrapper<CartLimitsProjection>;
  CartOrigin: CartOrigin;
  CartQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CartQueryInterface']>;
  CartQueryResult: ResolverTypeWrapper<CartQueryResult>;
  CartScoreInput: CartScoreInput;
  CartScoreType: ResolverTypeWrapper<CartScoreType>;
  CartState: CartState;
  CartUpdateAction: CartUpdateAction;
  CartValueInput: CartValueInput;
  CartValueType: ResolverTypeWrapper<CartValueType>;
  CartsConfiguration: ResolverTypeWrapper<CartsConfiguration>;
  CartsConfigurationInput: CartsConfigurationInput;
  Category: ResolverTypeWrapper<Category>;
  CategoryCreated: ResolverTypeWrapper<CategoryCreated>;
  CategoryDraft: CategoryDraft;
  CategoryLimitsProjection: ResolverTypeWrapper<CategoryLimitsProjection>;
  CategoryOrderHint: ResolverTypeWrapper<CategoryOrderHint>;
  CategoryOrderHintInput: CategoryOrderHintInput;
  CategoryOrderHintProductSearch: ResolverTypeWrapper<CategoryOrderHintProductSearch>;
  CategoryQueryResult: ResolverTypeWrapper<CategoryQueryResult>;
  CategorySearch: ResolverTypeWrapper<CategorySearch>;
  CategorySearchResult: ResolverTypeWrapper<CategorySearchResult>;
  CategorySlugChanged: ResolverTypeWrapper<CategorySlugChanged>;
  CategoryUpdateAction: CategoryUpdateAction;
  ChangeAssociateRoleBuyerAssignable: ChangeAssociateRoleBuyerAssignable;
  ChangeAttributeGroupName: ChangeAttributeGroupName;
  ChangeBusinessUnitAddress: ChangeBusinessUnitAddress;
  ChangeBusinessUnitAssociate: ChangeBusinessUnitAssociate;
  ChangeBusinessUnitAssociateMode: ChangeBusinessUnitAssociateMode;
  ChangeBusinessUnitName: ChangeBusinessUnitName;
  ChangeBusinessUnitParentUnit: ChangeBusinessUnitParentUnit;
  ChangeBusinessUnitStatus: ChangeBusinessUnitStatus;
  ChangeCartCustomLineItemMoney: ChangeCartCustomLineItemMoney;
  ChangeCartCustomLineItemPriceMode: ChangeCartCustomLineItemPriceMode;
  ChangeCartCustomLineItemQuantity: ChangeCartCustomLineItemQuantity;
  ChangeCartDiscountCartPredicate: ChangeCartDiscountCartPredicate;
  ChangeCartDiscountIsActive: ChangeCartDiscountIsActive;
  ChangeCartDiscountName: ChangeCartDiscountName;
  ChangeCartDiscountRequiresDiscountCode: ChangeCartDiscountRequiresDiscountCode;
  ChangeCartDiscountSortOrder: ChangeCartDiscountSortOrder;
  ChangeCartDiscountStackingMode: ChangeCartDiscountStackingMode;
  ChangeCartDiscountTarget: ChangeCartDiscountTarget;
  ChangeCartDiscountValue: ChangeCartDiscountValue;
  ChangeCartLineItemQuantity: ChangeCartLineItemQuantity;
  ChangeCartTaxCalculationMode: ChangeCartTaxCalculationMode;
  ChangeCartTaxMode: ChangeCartTaxMode;
  ChangeCartTaxRoundingMode: ChangeCartTaxRoundingMode;
  ChangeCategoryAssetName: ChangeCategoryAssetName;
  ChangeCategoryAssetOrder: ChangeCategoryAssetOrder;
  ChangeCategoryName: ChangeCategoryName;
  ChangeCategoryOrderHint: ChangeCategoryOrderHint;
  ChangeCategoryParent: ChangeCategoryParent;
  ChangeCategorySlug: ChangeCategorySlug;
  ChangeChannelDescription: ChangeChannelDescription;
  ChangeChannelKey: ChangeChannelKey;
  ChangeChannelName: ChangeChannelName;
  ChangeCustomerAddress: ChangeCustomerAddress;
  ChangeCustomerEmail: ChangeCustomerEmail;
  ChangeCustomerGroupName: ChangeCustomerGroupName;
  ChangeDiscountCodeCartDiscounts: ChangeDiscountCodeCartDiscounts;
  ChangeDiscountCodeGroups: ChangeDiscountCodeGroups;
  ChangeDiscountCodeIsActive: ChangeDiscountCodeIsActive;
  ChangeExtensionDestination: ChangeExtensionDestination;
  ChangeExtensionTriggers: ChangeExtensionTriggers;
  ChangeInventoryEntryQuantity: ChangeInventoryEntryQuantity;
  ChangeMyBusinessUnitAddress: ChangeMyBusinessUnitAddress;
  ChangeMyBusinessUnitAssociate: ChangeMyBusinessUnitAssociate;
  ChangeMyBusinessUnitName: ChangeMyBusinessUnitName;
  ChangeMyBusinessUnitParentUnit: ChangeMyBusinessUnitParentUnit;
  ChangeMyCartTaxMode: ChangeMyCartTaxMode;
  ChangeMyQuoteMyQuoteState: ChangeMyQuoteMyQuoteState;
  ChangeOrderPaymentState: ChangeOrderPaymentState;
  ChangeOrderShipmentState: ChangeOrderShipmentState;
  ChangeOrderState: ChangeOrderState;
  ChangePaymentAmountPlanned: ChangePaymentAmountPlanned;
  ChangePaymentTransactionInteractionId: ChangePaymentTransactionInteractionId;
  ChangePaymentTransactionState: ChangePaymentTransactionState;
  ChangePaymentTransactionTimestamp: ChangePaymentTransactionTimestamp;
  ChangeProductAssetName: ChangeProductAssetName;
  ChangeProductAssetOrder: ChangeProductAssetOrder;
  ChangeProductDiscountIsActive: ChangeProductDiscountIsActive;
  ChangeProductDiscountName: ChangeProductDiscountName;
  ChangeProductDiscountPredicate: ChangeProductDiscountPredicate;
  ChangeProductDiscountSortOrder: ChangeProductDiscountSortOrder;
  ChangeProductDiscountValue: ChangeProductDiscountValue;
  ChangeProductImageLabel: ChangeProductImageLabel;
  ChangeProductMasterVariant: ChangeProductMasterVariant;
  ChangeProductName: ChangeProductName;
  ChangeProductPrice: ChangeProductPrice;
  ChangeProductSelectionName: ChangeProductSelectionName;
  ChangeProductSlug: ChangeProductSlug;
  ChangeProjectSettingsCartsConfiguration: ChangeProjectSettingsCartsConfiguration;
  ChangeProjectSettingsCountries: ChangeProjectSettingsCountries;
  ChangeProjectSettingsCountryTaxRateFallbackEnabled: ChangeProjectSettingsCountryTaxRateFallbackEnabled;
  ChangeProjectSettingsCurrencies: ChangeProjectSettingsCurrencies;
  ChangeProjectSettingsCustomerSearchStatus: ChangeProjectSettingsCustomerSearchStatus;
  ChangeProjectSettingsLanguages: ChangeProjectSettingsLanguages;
  ChangeProjectSettingsMessagesConfiguration: ChangeProjectSettingsMessagesConfiguration;
  ChangeProjectSettingsMessagesEnabled: ChangeProjectSettingsMessagesEnabled;
  ChangeProjectSettingsMyBusinessUnitStatusOnCreation: ChangeProjectSettingsMyBusinessUnitStatusOnCreation;
  ChangeProjectSettingsName: ChangeProjectSettingsName;
  ChangeProjectSettingsOrderSearchStatus: ChangeProjectSettingsOrderSearchStatus;
  ChangeProjectSettingsProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled;
  ChangeProjectSettingsShoppingListsConfiguration: ChangeProjectSettingsShoppingListsConfiguration;
  ChangeProjectSettingsStandalonePriceSearchIndexingEnabled: ChangeProjectSettingsStandalonePriceSearchIndexingEnabled;
  ChangeQuoteCustomer: ChangeQuoteCustomer;
  ChangeQuoteRequestCustomer: ChangeQuoteRequestCustomer;
  ChangeQuoteRequestState: ChangeQuoteRequestState;
  ChangeQuoteState: ChangeQuoteState;
  ChangeShippingMethodIsDefault: ChangeShippingMethodIsDefault;
  ChangeShippingMethodName: ChangeShippingMethodName;
  ChangeShippingMethodTaxCategory: ChangeShippingMethodTaxCategory;
  ChangeShoppingListLineItemQuantity: ChangeShoppingListLineItemQuantity;
  ChangeShoppingListLineItemsOrder: ChangeShoppingListLineItemsOrder;
  ChangeShoppingListName: ChangeShoppingListName;
  ChangeShoppingListTextLineItemName: ChangeShoppingListTextLineItemName;
  ChangeShoppingListTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity;
  ChangeShoppingListTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder;
  ChangeStagedOrderCustomLineItemMoney: ChangeStagedOrderCustomLineItemMoney;
  ChangeStagedOrderCustomLineItemMoneyOutput: ResolverTypeWrapper<ChangeStagedOrderCustomLineItemMoneyOutput>;
  ChangeStagedOrderCustomLineItemQuantity: ChangeStagedOrderCustomLineItemQuantity;
  ChangeStagedOrderCustomLineItemQuantityOutput: ResolverTypeWrapper<ChangeStagedOrderCustomLineItemQuantityOutput>;
  ChangeStagedOrderLineItemQuantity: ChangeStagedOrderLineItemQuantity;
  ChangeStagedOrderLineItemQuantityOutput: ResolverTypeWrapper<ChangeStagedOrderLineItemQuantityOutput>;
  ChangeStagedOrderOrderState: ChangeStagedOrderOrderState;
  ChangeStagedOrderOrderStateOutput: ResolverTypeWrapper<ChangeStagedOrderOrderStateOutput>;
  ChangeStagedOrderPaymentState: ChangeStagedOrderPaymentState;
  ChangeStagedOrderPaymentStateOutput: ResolverTypeWrapper<ChangeStagedOrderPaymentStateOutput>;
  ChangeStagedOrderShipmentState: ChangeStagedOrderShipmentState;
  ChangeStagedOrderShipmentStateOutput: ResolverTypeWrapper<ChangeStagedOrderShipmentStateOutput>;
  ChangeStagedOrderTaxCalculationMode: ChangeStagedOrderTaxCalculationMode;
  ChangeStagedOrderTaxCalculationModeOutput: ResolverTypeWrapper<ChangeStagedOrderTaxCalculationModeOutput>;
  ChangeStagedOrderTaxMode: ChangeStagedOrderTaxMode;
  ChangeStagedOrderTaxModeOutput: ResolverTypeWrapper<ChangeStagedOrderTaxModeOutput>;
  ChangeStagedOrderTaxRoundingMode: ChangeStagedOrderTaxRoundingMode;
  ChangeStagedOrderTaxRoundingModeOutput: ResolverTypeWrapper<ChangeStagedOrderTaxRoundingModeOutput>;
  ChangeStagedQuoteState: ChangeStagedQuoteState;
  ChangeStandalonePriceActive: ChangeStandalonePriceActive;
  ChangeStandalonePriceValue: ChangeStandalonePriceValue;
  ChangeStateInitial: ChangeStateInitial;
  ChangeStateKey: ChangeStateKey;
  ChangeStateType: ChangeStateType;
  ChangeStoreProductSelectionActive: ChangeStoreProductSelectionActive;
  ChangeSubscription: ResolverTypeWrapper<ChangeSubscription>;
  ChangeSubscriptionDestination: ChangeSubscriptionDestination;
  ChangeSubscriptionInput: ChangeSubscriptionInput;
  ChangeTypeEnumValueLabel: ChangeTypeEnumValueLabel;
  ChangeTypeEnumValueOrder: ChangeTypeEnumValueOrder;
  ChangeTypeFieldDefinitionOrder: ChangeTypeFieldDefinitionOrder;
  ChangeTypeInputHint: ChangeTypeInputHint;
  ChangeTypeKey: ChangeTypeKey;
  ChangeTypeLabel: ChangeTypeLabel;
  ChangeTypeLocalizedEnumValueLabel: ChangeTypeLocalizedEnumValueLabel;
  ChangeTypeLocalizedEnumValueOrder: ChangeTypeLocalizedEnumValueOrder;
  ChangeTypeName: ChangeTypeName;
  ChangeZoneName: ChangeZoneName;
  Channel: ResolverTypeWrapper<Channel>;
  ChannelDraft: ChannelDraft;
  ChannelQueryResult: ResolverTypeWrapper<ChannelQueryResult>;
  ChannelReferenceIdentifier: ResolverTypeWrapper<ChannelReferenceIdentifier>;
  ChannelRole: ChannelRole;
  ChannelUpdateAction: ChannelUpdateAction;
  ClassificationShippingRateInput: ResolverTypeWrapper<ClassificationShippingRateInput>;
  ClassificationShippingRateInputDraft: ClassificationShippingRateInputDraft;
  ClassificationShippingRateInputDraftOutput: ResolverTypeWrapper<ClassificationShippingRateInputDraftOutput>;
  CloudEventsSubscriptionsFormat: ResolverTypeWrapper<CloudEventsSubscriptionsFormat>;
  CloudEventsSubscriptionsFormatInput: CloudEventsSubscriptionsFormatInput;
  CommercetoolsSubscription: ResolverTypeWrapper<CommercetoolsSubscription>;
  CommercetoolsSubscriptionQueryResult: ResolverTypeWrapper<CommercetoolsSubscriptionQueryResult>;
  ConfluentCloudDestination: ResolverTypeWrapper<ConfluentCloudDestination>;
  ConfluentCloudDestinationInput: ConfluentCloudDestinationInput;
  Country: ResolverTypeWrapper<Scalars['Country']['output']>;
  CreateApiClient: CreateApiClient;
  CreateProductSelectionDraft: CreateProductSelectionDraft;
  CreateStandalonePrice: CreateStandalonePrice;
  CreateStore: CreateStore;
  CreateZone: CreateZone;
  Currency: ResolverTypeWrapper<Scalars['Currency']['output']>;
  CustomField: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CustomField']>;
  CustomFieldInput: CustomFieldInput;
  CustomFieldsCommand: ResolverTypeWrapper<CustomFieldsCommand>;
  CustomFieldsDraft: CustomFieldsDraft;
  CustomFieldsType: ResolverTypeWrapper<CustomFieldsType>;
  CustomLineItem: ResolverTypeWrapper<CustomLineItem>;
  CustomLineItemDraft: CustomLineItemDraft;
  CustomLineItemDraftOutput: ResolverTypeWrapper<CustomLineItemDraftOutput>;
  CustomLineItemImportDraft: CustomLineItemImportDraft;
  CustomLineItemPriceMode: CustomLineItemPriceMode;
  CustomLineItemReturnItem: ResolverTypeWrapper<CustomLineItemReturnItem>;
  CustomLineItemStateTransition: ResolverTypeWrapper<CustomLineItemStateTransition>;
  CustomLineItemsTarget: ResolverTypeWrapper<CustomLineItemsTarget>;
  CustomLineItemsTargetInput: CustomLineItemsTargetInput;
  CustomObject: ResolverTypeWrapper<CustomObject>;
  CustomObjectDraft: CustomObjectDraft;
  CustomObjectLimitWithCurrent: ResolverTypeWrapper<CustomObjectLimitWithCurrent>;
  CustomObjectLimitsProjection: ResolverTypeWrapper<CustomObjectLimitsProjection>;
  CustomObjectQueryResult: ResolverTypeWrapper<CustomObjectQueryResult>;
  CustomShippingDraft: CustomShippingDraft;
  CustomSuggestTokenizer: ResolverTypeWrapper<CustomSuggestTokenizer>;
  CustomSuggestTokenizerInput: CustomSuggestTokenizerInput;
  CustomSuggestTokenizerProductSearch: ResolverTypeWrapper<CustomSuggestTokenizerProductSearch>;
  Customer: ResolverTypeWrapper<Customer>;
  CustomerActiveCartInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CustomerActiveCartInterface']>;
  CustomerAddressAdded: ResolverTypeWrapper<CustomerAddressAdded>;
  CustomerAddressChanged: ResolverTypeWrapper<CustomerAddressChanged>;
  CustomerAddressRemoved: ResolverTypeWrapper<CustomerAddressRemoved>;
  CustomerCompanyNameSet: ResolverTypeWrapper<CustomerCompanyNameSet>;
  CustomerCreated: ResolverTypeWrapper<CustomerCreated>;
  CustomerDateOfBirthSet: ResolverTypeWrapper<CustomerDateOfBirthSet>;
  CustomerDeleted: ResolverTypeWrapper<CustomerDeleted>;
  CustomerEmailChanged: ResolverTypeWrapper<CustomerEmailChanged>;
  CustomerEmailToken: ResolverTypeWrapper<CustomerEmailToken>;
  CustomerEmailTokenCreated: ResolverTypeWrapper<CustomerEmailTokenCreated>;
  CustomerEmailVerified: ResolverTypeWrapper<CustomerEmailVerified>;
  CustomerFirstNameSet: ResolverTypeWrapper<CustomerFirstNameSet>;
  CustomerGroup: ResolverTypeWrapper<CustomerGroup>;
  CustomerGroupDraft: CustomerGroupDraft;
  CustomerGroupLimitWithCurrent: ResolverTypeWrapper<CustomerGroupLimitWithCurrent>;
  CustomerGroupLimitsProjection: ResolverTypeWrapper<CustomerGroupLimitsProjection>;
  CustomerGroupQueryResult: ResolverTypeWrapper<CustomerGroupQueryResult>;
  CustomerGroupReferenceIdentifier: ResolverTypeWrapper<CustomerGroupReferenceIdentifier>;
  CustomerGroupSet: ResolverTypeWrapper<CustomerGroupSet>;
  CustomerGroupUpdateAction: CustomerGroupUpdateAction;
  CustomerLastNameSet: ResolverTypeWrapper<CustomerLastNameSet>;
  CustomerLimitWithCurrent: ResolverTypeWrapper<CustomerLimitWithCurrent>;
  CustomerLimitsProjection: ResolverTypeWrapper<CustomerLimitsProjection>;
  CustomerPasswordToken: ResolverTypeWrapper<CustomerPasswordToken>;
  CustomerPasswordTokenCreated: ResolverTypeWrapper<CustomerPasswordTokenCreated>;
  CustomerPasswordUpdated: ResolverTypeWrapper<CustomerPasswordUpdated>;
  CustomerQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['CustomerQueryInterface']>;
  CustomerQueryResult: ResolverTypeWrapper<CustomerQueryResult>;
  CustomerSearchConfiguration: ResolverTypeWrapper<CustomerSearchConfiguration>;
  CustomerSearchStatus: CustomerSearchStatus;
  CustomerSignInDraft: CustomerSignInDraft;
  CustomerSignInResult: ResolverTypeWrapper<CustomerSignInResult>;
  CustomerSignMeInDraft: CustomerSignMeInDraft;
  CustomerSignMeUpDraft: CustomerSignMeUpDraft;
  CustomerSignUpDraft: CustomerSignUpDraft;
  CustomerTitleSet: ResolverTypeWrapper<CustomerTitleSet>;
  CustomerUpdateAction: CustomerUpdateAction;
  Date: ResolverTypeWrapper<Scalars['Date']['output']>;
  DateAttribute: ResolverTypeWrapper<DateAttribute>;
  DateAttributeDefinitionType: ResolverTypeWrapper<DateAttributeDefinitionType>;
  DateField: ResolverTypeWrapper<DateField>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']['output']>;
  DateTimeAttribute: ResolverTypeWrapper<DateTimeAttribute>;
  DateTimeAttributeDefinitionType: ResolverTypeWrapper<DateTimeAttributeDefinitionType>;
  DateTimeField: ResolverTypeWrapper<DateTimeField>;
  DateTimeType: ResolverTypeWrapper<DateTimeType>;
  DateType: ResolverTypeWrapper<DateType>;
  Delivery: ResolverTypeWrapper<Delivery>;
  DeliveryAdded: ResolverTypeWrapper<DeliveryAdded>;
  DeliveryAddressSet: ResolverTypeWrapper<DeliveryAddressSet>;
  DeliveryDraft: DeliveryDraft;
  DeliveryItem: ResolverTypeWrapper<DeliveryItem>;
  DeliveryItemDraftType: DeliveryItemDraftType;
  DeliveryItemsUpdated: ResolverTypeWrapper<DeliveryItemsUpdated>;
  DeliveryRemoved: ResolverTypeWrapper<DeliveryRemoved>;
  Destination: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Destination']>;
  DestinationInput: DestinationInput;
  Dimensions: ResolverTypeWrapper<Dimensions>;
  DimensionsInput: DimensionsInput;
  DimensionsProductSearch: ResolverTypeWrapper<DimensionsProductSearch>;
  DirectDiscount: ResolverTypeWrapper<DirectDiscount>;
  DirectDiscountDraft: DirectDiscountDraft;
  DirectDiscountDraftOutput: ResolverTypeWrapper<DirectDiscountDraftOutput>;
  DiscountCode: ResolverTypeWrapper<DiscountCode>;
  DiscountCodeDraft: DiscountCodeDraft;
  DiscountCodeInfo: ResolverTypeWrapper<DiscountCodeInfo>;
  DiscountCodeQueryResult: ResolverTypeWrapper<DiscountCodeQueryResult>;
  DiscountCodeState: DiscountCodeState;
  DiscountCodeUpdateAction: DiscountCodeUpdateAction;
  DiscountedLineItemPortion: ResolverTypeWrapper<DiscountedLineItemPortion>;
  DiscountedLineItemPortionDraft: DiscountedLineItemPortionDraft;
  DiscountedLineItemPrice: ResolverTypeWrapper<DiscountedLineItemPrice>;
  DiscountedLineItemPriceDraft: DiscountedLineItemPriceDraft;
  DiscountedLineItemPriceForQuantity: ResolverTypeWrapper<DiscountedLineItemPriceForQuantity>;
  DiscountedProductPriceValue: ResolverTypeWrapper<DiscountedProductPriceValue>;
  DiscountedProductPriceValueInput: DiscountedProductPriceValueInput;
  DiscountedProductSearchPriceValue: ResolverTypeWrapper<DiscountedProductSearchPriceValue>;
  EnumAttribute: ResolverTypeWrapper<EnumAttribute>;
  EnumAttributeDefinitionType: ResolverTypeWrapper<EnumAttributeDefinitionType>;
  EnumField: ResolverTypeWrapper<EnumField>;
  EnumType: ResolverTypeWrapper<EnumType>;
  EnumTypeDraft: EnumTypeDraft;
  EnumValue: ResolverTypeWrapper<EnumValue>;
  EnumValueInput: EnumValueInput;
  EventBridgeDestination: ResolverTypeWrapper<EventBridgeDestination>;
  EventBridgeDestinationInput: EventBridgeDestinationInput;
  EventGridDestination: ResolverTypeWrapper<EventGridDestination>;
  EventGridDestinationInput: EventGridDestinationInput;
  ExcludeProductSelectionProduct: ExcludeProductSelectionProduct;
  ExistsFilterInput: ExistsFilterInput;
  Extension: ResolverTypeWrapper<Extension>;
  ExtensionDestination: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ExtensionDestination']>;
  ExtensionDestinationInput: ExtensionDestinationInput;
  ExtensionDraft: ExtensionDraft;
  ExtensionLimitsProjection: ResolverTypeWrapper<ExtensionLimitsProjection>;
  ExtensionQueryResult: ResolverTypeWrapper<ExtensionQueryResult>;
  ExtensionUpdateAction: ExtensionUpdateAction;
  ExternalDiscountValue: ResolverTypeWrapper<ExternalDiscountValue>;
  ExternalDiscountValueInput: ExternalDiscountValueInput;
  ExternalLineItemTotalPrice: ResolverTypeWrapper<ExternalLineItemTotalPrice>;
  ExternalLineItemTotalPriceDraft: ExternalLineItemTotalPriceDraft;
  ExternalOAuth: ResolverTypeWrapper<ExternalOAuth>;
  ExternalOAuthDraft: ExternalOAuthDraft;
  ExternalTaxAmountDraft: ExternalTaxAmountDraft;
  ExternalTaxAmountDraftOutput: ResolverTypeWrapper<ExternalTaxAmountDraftOutput>;
  ExternalTaxRateDraft: ExternalTaxRateDraft;
  ExternalTaxRateDraftOutput: ResolverTypeWrapper<ExternalTaxRateDraftOutput>;
  FacetResult: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['FacetResult']>;
  FacetResultValue: ResolverTypeWrapper<FacetResultValue>;
  FieldDefinition: ResolverTypeWrapper<FieldDefinition>;
  FieldDefinitionInput: FieldDefinitionInput;
  FieldType: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['FieldType']>;
  FieldTypeEnumTypeDraft: FieldTypeEnumTypeDraft;
  FieldTypeInput: FieldTypeInput;
  FieldTypeLocalizedEnumTypeDraft: FieldTypeLocalizedEnumTypeDraft;
  FieldTypeReferenceTypeDraft: FieldTypeReferenceTypeDraft;
  FieldTypeSetElementTypeDraft: FieldTypeSetElementTypeDraft;
  FieldTypeSetTypeDraft: FieldTypeSetTypeDraft;
  FixedPriceDiscountValue: ResolverTypeWrapper<FixedPriceDiscountValue>;
  FixedPriceDiscountValueInput: FixedPriceDiscountValueInput;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  FreezeCart: FreezeCart;
  Geometry: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Geometry']>;
  GeometryInput: GeometryInput;
  GiftLineItemValue: ResolverTypeWrapper<GiftLineItemValue>;
  GiftLineItemValueInput: GiftLineItemValueInput;
  GoogleCloudFunctionDestination: ResolverTypeWrapper<GoogleCloudFunctionDestination>;
  GoogleCloudFunctionDestinationInput: GoogleCloudFunctionDestinationInput;
  GoogleCloudPubSubDestination: ResolverTypeWrapper<GoogleCloudPubSubDestination>;
  GoogleCloudPubSubDestinationInput: GoogleCloudPubSubDestinationInput;
  HighPrecisionMoney: ResolverTypeWrapper<HighPrecisionMoney>;
  HighPrecisionMoneyInput: HighPrecisionMoneyInput;
  HttpDestination: ResolverTypeWrapper<HttpDestination>;
  HttpDestinationAuthentication: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['HttpDestinationAuthentication']>;
  HttpDestinationAuthenticationInput: HttpDestinationAuthenticationInput;
  HttpDestinationInput: HttpDestinationInput;
  Image: ResolverTypeWrapper<Image>;
  ImageInput: ImageInput;
  ImageProductSearch: ResolverTypeWrapper<ImageProductSearch>;
  ImportOrderCustomLineItemState: ImportOrderCustomLineItemState;
  ImportOrderDraft: ImportOrderDraft;
  ImportOrderLineItemState: ImportOrderLineItemState;
  ImportStagedOrderCustomLineItemState: ImportStagedOrderCustomLineItemState;
  ImportStagedOrderCustomLineItemStateOutput: ResolverTypeWrapper<ImportStagedOrderCustomLineItemStateOutput>;
  ImportStagedOrderLineItemState: ImportStagedOrderLineItemState;
  ImportStagedOrderLineItemStateOutput: ResolverTypeWrapper<ImportStagedOrderLineItemStateOutput>;
  InStore: ResolverTypeWrapper<InStore>;
  InStoreMe: ResolverTypeWrapper<InStoreMe>;
  InheritedAssociate: ResolverTypeWrapper<InheritedAssociate>;
  InheritedAssociateRoleAssignment: ResolverTypeWrapper<InheritedAssociateRoleAssignment>;
  InheritedStore: ResolverTypeWrapper<InheritedStore>;
  Initiator: ResolverTypeWrapper<Initiator>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  InterfaceInteractionsRaw: ResolverTypeWrapper<InterfaceInteractionsRaw>;
  InterfaceInteractionsRawResult: ResolverTypeWrapper<InterfaceInteractionsRawResult>;
  InventoryEntry: ResolverTypeWrapper<InventoryEntry>;
  InventoryEntryCreated: ResolverTypeWrapper<InventoryEntryCreated>;
  InventoryEntryDeleted: ResolverTypeWrapper<InventoryEntryDeleted>;
  InventoryEntryDraft: InventoryEntryDraft;
  InventoryEntryQuantitySet: ResolverTypeWrapper<InventoryEntryQuantitySet>;
  InventoryEntryQueryResult: ResolverTypeWrapper<InventoryEntryQueryResult>;
  InventoryEntryUpdateAction: InventoryEntryUpdateAction;
  InventoryMode: InventoryMode;
  ItemShippingDetails: ResolverTypeWrapper<ItemShippingDetails>;
  ItemShippingDetailsDraft: ItemShippingDetailsDraft;
  ItemShippingDetailsDraftOutput: ResolverTypeWrapper<ItemShippingDetailsDraftOutput>;
  ItemShippingDetailsDraftType: ItemShippingDetailsDraftType;
  ItemShippingTarget: ResolverTypeWrapper<ItemShippingTarget>;
  ItemState: ResolverTypeWrapper<ItemState>;
  ItemStateDraftType: ItemStateDraftType;
  Json: ResolverTypeWrapper<Scalars['Json']['output']>;
  KeyReference: ResolverTypeWrapper<KeyReference>;
  KeyReferenceInput: ResolverTypeWrapper<Scalars['KeyReferenceInput']['output']>;
  Limit: ResolverTypeWrapper<Limit>;
  LimitWithCurrent: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['LimitWithCurrent']>;
  LineItem: ResolverTypeWrapper<LineItem>;
  LineItemDraft: LineItemDraft;
  LineItemDraftOutput: ResolverTypeWrapper<LineItemDraftOutput>;
  LineItemImportDraft: LineItemImportDraft;
  LineItemMode: LineItemMode;
  LineItemPriceMode: LineItemPriceMode;
  LineItemReturnItem: ResolverTypeWrapper<LineItemReturnItem>;
  LineItemStateTransition: ResolverTypeWrapper<LineItemStateTransition>;
  LineItemsTarget: ResolverTypeWrapper<LineItemsTarget>;
  LineItemsTargetInput: LineItemsTargetInput;
  Locale: ResolverTypeWrapper<Scalars['Locale']['output']>;
  LocalizableEnumAttributeDefinitionType: ResolverTypeWrapper<LocalizableEnumAttributeDefinitionType>;
  LocalizableEnumTypeDraft: LocalizableEnumTypeDraft;
  LocalizableEnumValueType: ResolverTypeWrapper<LocalizableEnumValueType>;
  LocalizableEnumValueTypeResult: ResolverTypeWrapper<LocalizableEnumValueTypeResult>;
  LocalizableTextAttributeDefinitionType: ResolverTypeWrapper<LocalizableTextAttributeDefinitionType>;
  LocalizedEnumAttribute: ResolverTypeWrapper<LocalizedEnumAttribute>;
  LocalizedEnumField: ResolverTypeWrapper<LocalizedEnumField>;
  LocalizedEnumType: ResolverTypeWrapper<LocalizedEnumType>;
  LocalizedEnumValue: ResolverTypeWrapper<LocalizedEnumValue>;
  LocalizedEnumValueDraft: LocalizedEnumValueDraft;
  LocalizedEnumValueInput: LocalizedEnumValueInput;
  LocalizedString: ResolverTypeWrapper<LocalizedString>;
  LocalizedStringAttribute: ResolverTypeWrapper<LocalizedStringAttribute>;
  LocalizedStringField: ResolverTypeWrapper<LocalizedStringField>;
  LocalizedStringItemInputType: LocalizedStringItemInputType;
  LocalizedStringType: ResolverTypeWrapper<LocalizedStringType>;
  LocalizedText: LocalizedText;
  Location: ResolverTypeWrapper<Location>;
  Long: ResolverTypeWrapper<Scalars['Long']['output']>;
  Me: ResolverTypeWrapper<Me>;
  MeFieldInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['MeFieldInterface']>;
  MeQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['MeQueryInterface']>;
  Message: ResolverTypeWrapper<Message>;
  MessagePayload: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['MessagePayload']>;
  MessageQueryResult: ResolverTypeWrapper<MessageQueryResult>;
  MessageSubscription: ResolverTypeWrapper<MessageSubscription>;
  MessageSubscriptionInput: MessageSubscriptionInput;
  MessagesConfiguration: ResolverTypeWrapper<MessagesConfiguration>;
  MessagesConfigurationDraft: MessagesConfigurationDraft;
  MethodTaxRate: ResolverTypeWrapper<MethodTaxRate>;
  MethodTaxedPrice: ResolverTypeWrapper<MethodTaxedPrice>;
  MissingFilterInput: MissingFilterInput;
  Money: ResolverTypeWrapper<Money>;
  MoneyAttribute: ResolverTypeWrapper<MoneyAttribute>;
  MoneyAttributeDefinitionType: ResolverTypeWrapper<MoneyAttributeDefinitionType>;
  MoneyDraft: MoneyDraft;
  MoneyField: ResolverTypeWrapper<MoneyField>;
  MoneyInput: MoneyInput;
  MoneyType: ResolverTypeWrapper<MoneyType>;
  MoveProductImageToPosition: MoveProductImageToPosition;
  MultiBuyCustomLineItemsTarget: ResolverTypeWrapper<MultiBuyCustomLineItemsTarget>;
  MultiBuyCustomLineItemsTargetInput: MultiBuyCustomLineItemsTargetInput;
  MultiBuyLineItemsTarget: ResolverTypeWrapper<MultiBuyLineItemsTarget>;
  MultiBuyLineItemsTargetInput: MultiBuyLineItemsTargetInput;
  Mutation: ResolverTypeWrapper<{}>;
  MyBusinessUnitDraft: MyBusinessUnitDraft;
  MyBusinessUnitUpdateAction: MyBusinessUnitUpdateAction;
  MyCartDraft: MyCartDraft;
  MyCartUpdateAction: MyCartUpdateAction;
  MyCustomerUpdateAction: MyCustomerUpdateAction;
  MyLineItemDraft: MyLineItemDraft;
  MyPayment: ResolverTypeWrapper<MyPayment>;
  MyPaymentDraft: MyPaymentDraft;
  MyPaymentQueryResult: ResolverTypeWrapper<MyPaymentQueryResult>;
  MyPaymentUpdateAction: MyPaymentUpdateAction;
  MyQuoteRequestDraft: MyQuoteRequestDraft;
  MyQuoteRequestUpdateAction: MyQuoteRequestUpdateAction;
  MyQuoteState: MyQuoteState;
  MyQuoteUpdateAction: MyQuoteUpdateAction;
  MyShoppingListDraft: MyShoppingListDraft;
  MyShoppingListUpdateAction: MyShoppingListUpdateAction;
  MyTransactionDraft: MyTransactionDraft;
  NestedAttributeDefinitionType: ResolverTypeWrapper<NestedAttributeDefinitionType>;
  NotProcessed: ResolverTypeWrapper<NotProcessed>;
  NotificationFormat: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['NotificationFormat']>;
  NumberAttribute: ResolverTypeWrapper<NumberAttribute>;
  NumberAttributeDefinitionType: ResolverTypeWrapper<NumberAttributeDefinitionType>;
  NumberField: ResolverTypeWrapper<NumberField>;
  NumberType: ResolverTypeWrapper<NumberType>;
  Order: ResolverTypeWrapper<Order>;
  OrderBillingAddressSet: ResolverTypeWrapper<OrderBillingAddressSet>;
  OrderCartCommand: OrderCartCommand;
  OrderCreated: ResolverTypeWrapper<OrderCreated>;
  OrderCustomFieldAdded: ResolverTypeWrapper<OrderCustomFieldAdded>;
  OrderCustomFieldChanged: ResolverTypeWrapper<OrderCustomFieldChanged>;
  OrderCustomFieldRemoved: ResolverTypeWrapper<OrderCustomFieldRemoved>;
  OrderCustomLineItemAdded: ResolverTypeWrapper<OrderCustomLineItemAdded>;
  OrderCustomLineItemDiscountSet: ResolverTypeWrapper<OrderCustomLineItemDiscountSet>;
  OrderCustomLineItemQuantityChanged: ResolverTypeWrapper<OrderCustomLineItemQuantityChanged>;
  OrderCustomLineItemRemoved: ResolverTypeWrapper<OrderCustomLineItemRemoved>;
  OrderCustomTypeRemoved: ResolverTypeWrapper<OrderCustomTypeRemoved>;
  OrderCustomTypeSet: ResolverTypeWrapper<OrderCustomTypeSet>;
  OrderCustomerEmailSet: ResolverTypeWrapper<OrderCustomerEmailSet>;
  OrderCustomerGroupSet: ResolverTypeWrapper<OrderCustomerGroupSet>;
  OrderCustomerSet: ResolverTypeWrapper<OrderCustomerSet>;
  OrderDeleted: ResolverTypeWrapper<OrderDeleted>;
  OrderDiscountCodeAdded: ResolverTypeWrapper<OrderDiscountCodeAdded>;
  OrderDiscountCodeRemoved: ResolverTypeWrapper<OrderDiscountCodeRemoved>;
  OrderDiscountCodeStateSet: ResolverTypeWrapper<OrderDiscountCodeStateSet>;
  OrderEdit: ResolverTypeWrapper<OrderEdit>;
  OrderEditApplied: ResolverTypeWrapper<OrderEditApplied>;
  OrderEditDraft: OrderEditDraft;
  OrderEditLimitWithCurrent: ResolverTypeWrapper<OrderEditLimitWithCurrent>;
  OrderEditLimitsProjection: ResolverTypeWrapper<OrderEditLimitsProjection>;
  OrderEditQueryResult: ResolverTypeWrapper<OrderEditQueryResult>;
  OrderEditResult: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['OrderEditResult']>;
  OrderEditUpdateAction: OrderEditUpdateAction;
  OrderExcerpt: ResolverTypeWrapper<OrderExcerpt>;
  OrderImported: ResolverTypeWrapper<OrderImported>;
  OrderLineItemAdded: ResolverTypeWrapper<OrderLineItemAdded>;
  OrderLineItemDiscountSet: ResolverTypeWrapper<OrderLineItemDiscountSet>;
  OrderLineItemDistributionChannelSet: ResolverTypeWrapper<OrderLineItemDistributionChannelSet>;
  OrderLineItemRemoved: ResolverTypeWrapper<OrderLineItemRemoved>;
  OrderMessagePayload: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['OrderMessagePayload']>;
  OrderMyCartCommand: OrderMyCartCommand;
  OrderMyQuoteCommand: OrderMyQuoteCommand;
  OrderPaymentAdded: ResolverTypeWrapper<OrderPaymentAdded>;
  OrderPaymentRemoved: ResolverTypeWrapper<OrderPaymentRemoved>;
  OrderPaymentStateChanged: ResolverTypeWrapper<OrderPaymentStateChanged>;
  OrderQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['OrderQueryInterface']>;
  OrderQueryResult: ResolverTypeWrapper<OrderQueryResult>;
  OrderQuoteCommand: OrderQuoteCommand;
  OrderReturnShipmentStateChanged: ResolverTypeWrapper<OrderReturnShipmentStateChanged>;
  OrderSearchConfiguration: ResolverTypeWrapper<OrderSearchConfiguration>;
  OrderSearchStatus: OrderSearchStatus;
  OrderShipmentStateChanged: ResolverTypeWrapper<OrderShipmentStateChanged>;
  OrderShippingAddressSet: ResolverTypeWrapper<OrderShippingAddressSet>;
  OrderShippingInfoSet: ResolverTypeWrapper<OrderShippingInfoSet>;
  OrderShippingRateInputSet: ResolverTypeWrapper<OrderShippingRateInputSet>;
  OrderState: OrderState;
  OrderStateChanged: ResolverTypeWrapper<OrderStateChanged>;
  OrderStateTransition: ResolverTypeWrapper<OrderStateTransition>;
  OrderStoreSet: ResolverTypeWrapper<OrderStoreSet>;
  OrderUpdateAction: OrderUpdateAction;
  Parcel: ResolverTypeWrapper<Parcel>;
  ParcelAddedToDelivery: ResolverTypeWrapper<ParcelAddedToDelivery>;
  ParcelData: ResolverTypeWrapper<ParcelData>;
  ParcelDataDraftType: ParcelDataDraftType;
  ParcelDraft: ParcelDraft;
  ParcelItemsUpdated: ResolverTypeWrapper<ParcelItemsUpdated>;
  ParcelMeasurements: ResolverTypeWrapper<ParcelMeasurements>;
  ParcelMeasurementsDraftType: ParcelMeasurementsDraftType;
  ParcelMeasurementsUpdated: ResolverTypeWrapper<ParcelMeasurementsUpdated>;
  ParcelRemovedFromDelivery: ResolverTypeWrapper<ParcelRemovedFromDelivery>;
  ParcelTrackingDataUpdated: ResolverTypeWrapper<ParcelTrackingDataUpdated>;
  Payment: ResolverTypeWrapper<Payment>;
  PaymentCreated: ResolverTypeWrapper<PaymentCreated>;
  PaymentDraft: PaymentDraft;
  PaymentInfo: ResolverTypeWrapper<PaymentInfo>;
  PaymentInteractionAdded: ResolverTypeWrapper<PaymentInteractionAdded>;
  PaymentMethodInfo: ResolverTypeWrapper<PaymentMethodInfo>;
  PaymentMethodInfoInput: PaymentMethodInfoInput;
  PaymentQueryResult: ResolverTypeWrapper<PaymentQueryResult>;
  PaymentState: PaymentState;
  PaymentStatus: ResolverTypeWrapper<PaymentStatus>;
  PaymentStatusInput: PaymentStatusInput;
  PaymentStatusInterfaceCodeSet: ResolverTypeWrapper<PaymentStatusInterfaceCodeSet>;
  PaymentStatusStateTransition: ResolverTypeWrapper<PaymentStatusStateTransition>;
  PaymentTransactionAdded: ResolverTypeWrapper<PaymentTransactionAdded>;
  PaymentTransactionStateChanged: ResolverTypeWrapper<PaymentTransactionStateChanged>;
  PaymentUpdateAction: PaymentUpdateAction;
  Permission: Permission;
  PlainEnumValue: ResolverTypeWrapper<PlainEnumValue>;
  PlainEnumValueDraft: PlainEnumValueDraft;
  PlainEnumValueResult: ResolverTypeWrapper<PlainEnumValueResult>;
  PlatformFormat: ResolverTypeWrapper<PlatformFormat>;
  PlatformFormatInput: PlatformFormatInput;
  Point: ResolverTypeWrapper<Point>;
  PreviewFailure: ResolverTypeWrapper<PreviewFailure>;
  PreviewSuccess: ResolverTypeWrapper<PreviewSuccess>;
  PriceFunction: ResolverTypeWrapper<PriceFunction>;
  PriceFunctionDraft: PriceFunctionDraft;
  PriceMode: PriceMode;
  PriceSelectorInput: PriceSelectorInput;
  Product: ResolverTypeWrapper<Product>;
  ProductAddedToCategory: ResolverTypeWrapper<ProductAddedToCategory>;
  ProductAssignment: ResolverTypeWrapper<ProductAssignment>;
  ProductAssignmentQueryResult: ResolverTypeWrapper<ProductAssignmentQueryResult>;
  ProductAttributeInput: ProductAttributeInput;
  ProductCatalogData: ResolverTypeWrapper<ProductCatalogData>;
  ProductCreated: ResolverTypeWrapper<ProductCreated>;
  ProductData: ResolverTypeWrapper<ProductData>;
  ProductDeleted: ResolverTypeWrapper<ProductDeleted>;
  ProductDiscount: ResolverTypeWrapper<ProductDiscount>;
  ProductDiscountDraft: ProductDiscountDraft;
  ProductDiscountLimitWithCurrent: ResolverTypeWrapper<ProductDiscountLimitWithCurrent>;
  ProductDiscountLimitsProjection: ResolverTypeWrapper<ProductDiscountLimitsProjection>;
  ProductDiscountQueryResult: ResolverTypeWrapper<ProductDiscountQueryResult>;
  ProductDiscountUpdateAction: ProductDiscountUpdateAction;
  ProductDiscountValue: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProductDiscountValue']>;
  ProductDiscountValueInput: ProductDiscountValueInput;
  ProductDraft: ProductDraft;
  ProductImageAdded: ResolverTypeWrapper<ProductImageAdded>;
  ProductLimitsProjection: ResolverTypeWrapper<ProductLimitsProjection>;
  ProductOfSelection: ResolverTypeWrapper<ProductOfSelection>;
  ProductOfSelectionQueryResult: ResolverTypeWrapper<ProductOfSelectionQueryResult>;
  ProductPrice: ResolverTypeWrapper<ProductPrice>;
  ProductPriceAdded: ResolverTypeWrapper<ProductPriceAdded>;
  ProductPriceChanged: ResolverTypeWrapper<ProductPriceChanged>;
  ProductPriceDataInput: ProductPriceDataInput;
  ProductPriceDiscountUpdateMessagePayload: ResolverTypeWrapper<ProductPriceDiscountUpdateMessagePayload>;
  ProductPriceDiscountsSet: ResolverTypeWrapper<ProductPriceDiscountsSet>;
  ProductPriceExternalDiscountSet: ResolverTypeWrapper<ProductPriceExternalDiscountSet>;
  ProductPriceKeySet: ResolverTypeWrapper<ProductPriceKeySet>;
  ProductPriceModeSet: ResolverTypeWrapper<ProductPriceModeSet>;
  ProductPriceRemoved: ResolverTypeWrapper<ProductPriceRemoved>;
  ProductPriceSearch: ResolverTypeWrapper<ProductPriceSearch>;
  ProductPriceTier: ResolverTypeWrapper<ProductPriceTier>;
  ProductPriceTierInput: ProductPriceTierInput;
  ProductPricesSet: ResolverTypeWrapper<ProductPricesSet>;
  ProductProjection: ResolverTypeWrapper<ProductProjection>;
  ProductProjectionMessagePayload: ResolverTypeWrapper<ProductProjectionMessagePayload>;
  ProductProjectionSearchResult: ResolverTypeWrapper<ProductProjectionSearchResult>;
  ProductPublished: ResolverTypeWrapper<ProductPublished>;
  ProductQueryResult: ResolverTypeWrapper<ProductQueryResult>;
  ProductReferenceIdentifier: ResolverTypeWrapper<ProductReferenceIdentifier>;
  ProductRemovedFromCategory: ResolverTypeWrapper<ProductRemovedFromCategory>;
  ProductRevertedStagedChanges: ResolverTypeWrapper<ProductRevertedStagedChanges>;
  ProductSearchPriceTier: ResolverTypeWrapper<ProductSearchPriceTier>;
  ProductSearchVariant: ResolverTypeWrapper<ProductSearchVariant>;
  ProductSearchVariantAvailabilitiesResult: ResolverTypeWrapper<ProductSearchVariantAvailabilitiesResult>;
  ProductSearchVariantAvailability: ResolverTypeWrapper<ProductSearchVariantAvailability>;
  ProductSearchVariantAvailabilityWithChannel: ResolverTypeWrapper<ProductSearchVariantAvailabilityWithChannel>;
  ProductSearchVariantAvailabilityWithChannels: ResolverTypeWrapper<ProductSearchVariantAvailabilityWithChannels>;
  ProductSelection: ResolverTypeWrapper<ProductSelection>;
  ProductSelectionCreated: ResolverTypeWrapper<ProductSelectionCreated>;
  ProductSelectionDeleted: ResolverTypeWrapper<ProductSelectionDeleted>;
  ProductSelectionMode: ProductSelectionMode;
  ProductSelectionProductAdded: ResolverTypeWrapper<ProductSelectionProductAdded>;
  ProductSelectionProductExcluded: ResolverTypeWrapper<ProductSelectionProductExcluded>;
  ProductSelectionProductRemoved: ResolverTypeWrapper<ProductSelectionProductRemoved>;
  ProductSelectionQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProductSelectionQueryInterface']>;
  ProductSelectionQueryResult: ResolverTypeWrapper<ProductSelectionQueryResult>;
  ProductSelectionSetting: ResolverTypeWrapper<ProductSelectionSetting>;
  ProductSelectionSettingDraft: ProductSelectionSettingDraft;
  ProductSelectionSettingInActionInput: ProductSelectionSettingInActionInput;
  ProductSelectionUpdateAction: ProductSelectionUpdateAction;
  ProductSelectionVariantExclusionChanged: ResolverTypeWrapper<ProductSelectionVariantExclusionChanged>;
  ProductSelectionVariantSelectionChanged: ResolverTypeWrapper<ProductSelectionVariantSelectionChanged>;
  ProductSlugChanged: ResolverTypeWrapper<ProductSlugChanged>;
  ProductStateTransition: ResolverTypeWrapper<ProductStateTransition>;
  ProductTypeDefinition: ResolverTypeWrapper<ProductTypeDefinition>;
  ProductTypeDefinitionQueryResult: ResolverTypeWrapper<ProductTypeDefinitionQueryResult>;
  ProductTypeDraft: ProductTypeDraft;
  ProductTypeLimitWithCurrent: ResolverTypeWrapper<ProductTypeLimitWithCurrent>;
  ProductTypeLimitsProjection: ResolverTypeWrapper<ProductTypeLimitsProjection>;
  ProductTypeUpdateAction: ProductTypeUpdateAction;
  ProductUnpublished: ResolverTypeWrapper<ProductUnpublished>;
  ProductUpdateAction: ProductUpdateAction;
  ProductVariant: ResolverTypeWrapper<ProductVariant>;
  ProductVariantAdded: ResolverTypeWrapper<ProductVariantAdded>;
  ProductVariantAvailabilitiesResult: ResolverTypeWrapper<ProductVariantAvailabilitiesResult>;
  ProductVariantAvailability: ResolverTypeWrapper<ProductVariantAvailability>;
  ProductVariantAvailabilityWithChannel: ResolverTypeWrapper<ProductVariantAvailabilityWithChannel>;
  ProductVariantAvailabilityWithChannels: ResolverTypeWrapper<ProductVariantAvailabilityWithChannels>;
  ProductVariantDeleted: ResolverTypeWrapper<ProductVariantDeleted>;
  ProductVariantExclusion: ResolverTypeWrapper<ProductVariantExclusion>;
  ProductVariantExclusionDraft: ProductVariantExclusionDraft;
  ProductVariantImportDraft: ProductVariantImportDraft;
  ProductVariantInput: ProductVariantInput;
  ProductVariantSelection: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ProductVariantSelection']>;
  ProductVariantSelectionDraft: ProductVariantSelectionDraft;
  ProductVariantSelectionIncludeAllExcept: ResolverTypeWrapper<ProductVariantSelectionIncludeAllExcept>;
  ProductVariantSelectionIncludeOnly: ResolverTypeWrapper<ProductVariantSelectionIncludeOnly>;
  ProjectCustomLimitsProjection: ResolverTypeWrapper<ProjectCustomLimitsProjection>;
  ProjectProjection: ResolverTypeWrapper<ProjectProjection>;
  ProjectSettingsUpdateAction: ProjectSettingsUpdateAction;
  PublishProduct: PublishProduct;
  PublishScope: PublishScope;
  PurchaseOrderNumberSet: ResolverTypeWrapper<PurchaseOrderNumberSet>;
  Query: ResolverTypeWrapper<{}>;
  QueryLimitsProjection: ResolverTypeWrapper<QueryLimitsProjection>;
  Quote: ResolverTypeWrapper<Quote>;
  QuoteDraft: QuoteDraft;
  QuoteQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['QuoteQueryInterface']>;
  QuoteQueryResult: ResolverTypeWrapper<QuoteQueryResult>;
  QuoteRequest: ResolverTypeWrapper<QuoteRequest>;
  QuoteRequestDraft: QuoteRequestDraft;
  QuoteRequestQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['QuoteRequestQueryInterface']>;
  QuoteRequestQueryResult: ResolverTypeWrapper<QuoteRequestQueryResult>;
  QuoteRequestState: QuoteRequestState;
  QuoteRequestUpdateAction: QuoteRequestUpdateAction;
  QuoteState: QuoteState;
  QuoteUpdateAction: QuoteUpdateAction;
  RangeCount: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['RangeCount']>;
  RangeCountDouble: ResolverTypeWrapper<RangeCountDouble>;
  RangeCountLong: ResolverTypeWrapper<RangeCountLong>;
  RangeElementInput: RangeElementInput;
  RangeFacetInput: RangeFacetInput;
  RangeFacetResult: ResolverTypeWrapper<RangeFacetResult>;
  RangeFilterInput: RangeFilterInput;
  RawCustomField: ResolverTypeWrapper<RawCustomField>;
  RawProductAttribute: ResolverTypeWrapper<RawProductAttribute>;
  RawProductSearchAttribute: ResolverTypeWrapper<RawProductSearchAttribute>;
  RecalculateCart: RecalculateCart;
  RecalculateStagedOrder: RecalculateStagedOrder;
  RecalculateStagedOrderOutput: ResolverTypeWrapper<RecalculateStagedOrderOutput>;
  Reference: ResolverTypeWrapper<Reference>;
  ReferenceAttribute: ResolverTypeWrapper<ReferenceAttribute>;
  ReferenceAttributeDefinitionType: ResolverTypeWrapper<ReferenceAttributeDefinitionType>;
  ReferenceExpandable: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ReferenceExpandable']>;
  ReferenceField: ResolverTypeWrapper<ReferenceField>;
  ReferenceId: ResolverTypeWrapper<ReferenceId>;
  ReferenceInput: ReferenceInput;
  ReferenceType: ResolverTypeWrapper<ReferenceType>;
  ReferenceTypeDefinitionDraft: ReferenceTypeDefinitionDraft;
  RefreshTokenLimitWithCurrent: ResolverTypeWrapper<RefreshTokenLimitWithCurrent>;
  RefreshTokenLimitsProjection: ResolverTypeWrapper<RefreshTokenLimitsProjection>;
  RejectApprovalFlow: RejectApprovalFlow;
  RelativeDiscountValue: ResolverTypeWrapper<RelativeDiscountValue>;
  RelativeDiscountValueInput: RelativeDiscountValueInput;
  RemoveAssociateRolePermission: RemoveAssociateRolePermission;
  RemoveAttributeGroupAttribute: RemoveAttributeGroupAttribute;
  RemoveBusinessUnitAddress: RemoveBusinessUnitAddress;
  RemoveBusinessUnitAssociate: RemoveBusinessUnitAssociate;
  RemoveBusinessUnitBillingAddressId: RemoveBusinessUnitBillingAddressId;
  RemoveBusinessUnitShippingAddressId: RemoveBusinessUnitShippingAddressId;
  RemoveBusinessUnitStore: RemoveBusinessUnitStore;
  RemoveCartCustomLineItem: RemoveCartCustomLineItem;
  RemoveCartDiscountCode: RemoveCartDiscountCode;
  RemoveCartDiscountStore: RemoveCartDiscountStore;
  RemoveCartItemShippingAddress: RemoveCartItemShippingAddress;
  RemoveCartLineItem: RemoveCartLineItem;
  RemoveCartPayment: RemoveCartPayment;
  RemoveCartShippingMethod: RemoveCartShippingMethod;
  RemoveCategoryAsset: RemoveCategoryAsset;
  RemoveChannelRoles: RemoveChannelRoles;
  RemoveCustomerAddress: RemoveCustomerAddress;
  RemoveCustomerBillingAddressId: RemoveCustomerBillingAddressId;
  RemoveCustomerShippingAddressId: RemoveCustomerShippingAddressId;
  RemoveCustomerStore: RemoveCustomerStore;
  RemoveInventoryEntryQuantity: RemoveInventoryEntryQuantity;
  RemoveMyBusinessUnitAddress: RemoveMyBusinessUnitAddress;
  RemoveMyBusinessUnitAssociate: RemoveMyBusinessUnitAssociate;
  RemoveMyBusinessUnitBillingAddressId: RemoveMyBusinessUnitBillingAddressId;
  RemoveMyBusinessUnitShippingAddressId: RemoveMyBusinessUnitShippingAddressId;
  RemoveOrderDelivery: RemoveOrderDelivery;
  RemoveOrderItemShippingAddress: RemoveOrderItemShippingAddress;
  RemoveOrderParcelFromDelivery: RemoveOrderParcelFromDelivery;
  RemoveOrderPayment: RemoveOrderPayment;
  RemoveProductAsset: RemoveProductAsset;
  RemoveProductFromCategory: RemoveProductFromCategory;
  RemoveProductImage: RemoveProductImage;
  RemoveProductPrice: RemoveProductPrice;
  RemoveProductSelectionProduct: RemoveProductSelectionProduct;
  RemoveProductVariant: RemoveProductVariant;
  RemoveShippingMethodShippingRate: RemoveShippingMethodShippingRate;
  RemoveShippingMethodZone: RemoveShippingMethodZone;
  RemoveShoppingListLineItem: RemoveShoppingListLineItem;
  RemoveShoppingListTextLineItem: RemoveShoppingListTextLineItem;
  RemoveStagedChanges: RemoveStagedChanges;
  RemoveStagedOrderCustomLineItem: RemoveStagedOrderCustomLineItem;
  RemoveStagedOrderCustomLineItemOutput: ResolverTypeWrapper<RemoveStagedOrderCustomLineItemOutput>;
  RemoveStagedOrderDelivery: RemoveStagedOrderDelivery;
  RemoveStagedOrderDeliveryOutput: ResolverTypeWrapper<RemoveStagedOrderDeliveryOutput>;
  RemoveStagedOrderDiscountCode: RemoveStagedOrderDiscountCode;
  RemoveStagedOrderDiscountCodeOutput: ResolverTypeWrapper<RemoveStagedOrderDiscountCodeOutput>;
  RemoveStagedOrderItemShippingAddress: RemoveStagedOrderItemShippingAddress;
  RemoveStagedOrderItemShippingAddressOutput: ResolverTypeWrapper<RemoveStagedOrderItemShippingAddressOutput>;
  RemoveStagedOrderLineItem: RemoveStagedOrderLineItem;
  RemoveStagedOrderLineItemOutput: ResolverTypeWrapper<RemoveStagedOrderLineItemOutput>;
  RemoveStagedOrderParcelFromDelivery: RemoveStagedOrderParcelFromDelivery;
  RemoveStagedOrderParcelFromDeliveryOutput: ResolverTypeWrapper<RemoveStagedOrderParcelFromDeliveryOutput>;
  RemoveStagedOrderPayment: RemoveStagedOrderPayment;
  RemoveStagedOrderPaymentOutput: ResolverTypeWrapper<RemoveStagedOrderPaymentOutput>;
  RemoveStandalonePriceTier: RemoveStandalonePriceTier;
  RemoveStateRoles: RemoveStateRoles;
  RemoveStoreCountry: RemoveStoreCountry;
  RemoveStoreDistributionChannel: RemoveStoreDistributionChannel;
  RemoveStoreProductSelection: RemoveStoreProductSelection;
  RemoveStoreSupplyChannel: RemoveStoreSupplyChannel;
  RemoveTypeFieldDefinition: RemoveTypeFieldDefinition;
  RemoveZoneLocation: RemoveZoneLocation;
  RequestQuoteRenegotiation: RequestQuoteRenegotiation;
  ResourceIdentifier: ResolverTypeWrapper<ResourceIdentifier>;
  ResourceIdentifierInput: ResourceIdentifierInput;
  ReturnInfo: ResolverTypeWrapper<ReturnInfo>;
  ReturnInfoAdded: ResolverTypeWrapper<ReturnInfoAdded>;
  ReturnInfoDraftType: ReturnInfoDraftType;
  ReturnInfoDraftTypeOutput: ResolverTypeWrapper<ReturnInfoDraftTypeOutput>;
  ReturnInfoSet: ResolverTypeWrapper<ReturnInfoSet>;
  ReturnItem: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ReturnItem']>;
  ReturnItemDraftType: ReturnItemDraftType;
  ReturnItemDraftTypeOutput: ResolverTypeWrapper<ReturnItemDraftTypeOutput>;
  ReturnPaymentState: ReturnPaymentState;
  ReturnShipmentState: ReturnShipmentState;
  RevertStagedChanges: RevertStagedChanges;
  RevertStagedVariantChanges: RevertStagedVariantChanges;
  Review: ResolverTypeWrapper<Review>;
  ReviewCreated: ResolverTypeWrapper<ReviewCreated>;
  ReviewDraft: ReviewDraft;
  ReviewQueryResult: ResolverTypeWrapper<ReviewQueryResult>;
  ReviewRatingSet: ResolverTypeWrapper<ReviewRatingSet>;
  ReviewRatingStatistics: ResolverTypeWrapper<ReviewRatingStatistics>;
  ReviewStateTransition: ResolverTypeWrapper<ReviewStateTransition>;
  ReviewTarget: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ReviewTarget']>;
  ReviewUpdateAction: ReviewUpdateAction;
  RoundingMode: RoundingMode;
  RuleApprover: ResolverTypeWrapper<RuleApprover>;
  RuleApproverDraft: RuleApproverDraft;
  RuleInfo: ResolverTypeWrapper<RuleInfo>;
  RuleRequester: ResolverTypeWrapper<RuleRequester>;
  RuleRequesterDraft: RuleRequesterDraft;
  SNSDestination: ResolverTypeWrapper<SnsDestination>;
  SNSDestinationInput: SnsDestinationInput;
  SQSDestination: ResolverTypeWrapper<SqsDestination>;
  SQSDestinationInput: SqsDestinationInput;
  ScopedPrice: ResolverTypeWrapper<ScopedPrice>;
  ScoreShippingRateInput: ResolverTypeWrapper<ScoreShippingRateInput>;
  ScoreShippingRateInputDraft: ScoreShippingRateInputDraft;
  ScoreShippingRateInputDraftOutput: ResolverTypeWrapper<ScoreShippingRateInputDraftOutput>;
  SearchFacetInput: SearchFacetInput;
  SearchFacetModelInput: SearchFacetModelInput;
  SearchFilter: ResolverTypeWrapper<Scalars['SearchFilter']['output']>;
  SearchFilterInput: SearchFilterInput;
  SearchFilterModelInput: SearchFilterModelInput;
  SearchIndexingConfiguration: ResolverTypeWrapper<SearchIndexingConfiguration>;
  SearchIndexingConfigurationValues: ResolverTypeWrapper<SearchIndexingConfigurationValues>;
  SearchIndexingStatus: SearchIndexingStatus;
  SearchKeyword: ResolverTypeWrapper<SearchKeyword>;
  SearchKeywordArgument: SearchKeywordArgument;
  SearchKeywordInput: SearchKeywordInput;
  SearchKeywordItemInput: SearchKeywordItemInput;
  SearchKeywordProductSearch: ResolverTypeWrapper<SearchKeywordProductSearch>;
  SearchKeywords: ResolverTypeWrapper<SearchKeywords>;
  SearchKeywordsProductSearch: ResolverTypeWrapper<SearchKeywordsProductSearch>;
  SearchLimitsProjection: ResolverTypeWrapper<SearchLimitsProjection>;
  SearchSort: ResolverTypeWrapper<Scalars['SearchSort']['output']>;
  SelectionMode: SelectionMode;
  SelectionOfProduct: ResolverTypeWrapper<SelectionOfProduct>;
  SelectionOfProductQueryResult: ResolverTypeWrapper<SelectionOfProductQueryResult>;
  Set: ResolverTypeWrapper<Scalars['Set']['output']>;
  SetApprovalRuleApprovers: SetApprovalRuleApprovers;
  SetApprovalRuleDescription: SetApprovalRuleDescription;
  SetApprovalRuleKey: SetApprovalRuleKey;
  SetApprovalRuleName: SetApprovalRuleName;
  SetApprovalRulePredicate: SetApprovalRulePredicate;
  SetApprovalRuleRequesters: SetApprovalRuleRequesters;
  SetApprovalRuleStatus: SetApprovalRuleStatus;
  SetAssociateRoleCustomField: SetAssociateRoleCustomField;
  SetAssociateRoleCustomType: SetAssociateRoleCustomType;
  SetAssociateRoleName: SetAssociateRoleName;
  SetAssociateRolePermissions: SetAssociateRolePermissions;
  SetAttributeDefinitionType: ResolverTypeWrapper<SetAttributeDefinitionType>;
  SetAttributeGroupAttributes: SetAttributeGroupAttributes;
  SetAttributeGroupDescription: SetAttributeGroupDescription;
  SetAttributeGroupKey: SetAttributeGroupKey;
  SetBusinessUnitAddressCustomField: SetBusinessUnitAddressCustomField;
  SetBusinessUnitAddressCustomType: SetBusinessUnitAddressCustomType;
  SetBusinessUnitAssociates: SetBusinessUnitAssociates;
  SetBusinessUnitContactEmail: SetBusinessUnitContactEmail;
  SetBusinessUnitCustomField: SetBusinessUnitCustomField;
  SetBusinessUnitCustomType: SetBusinessUnitCustomType;
  SetBusinessUnitDefaultBillingAddress: SetBusinessUnitDefaultBillingAddress;
  SetBusinessUnitDefaultShippingAddress: SetBusinessUnitDefaultShippingAddress;
  SetBusinessUnitStoreMode: SetBusinessUnitStoreMode;
  SetBusinessUnitStores: SetBusinessUnitStores;
  SetCartAnonymousId: SetCartAnonymousId;
  SetCartBillingAddress: SetCartBillingAddress;
  SetCartBillingAddressCustomField: SetCartBillingAddressCustomField;
  SetCartBillingAddressCustomType: SetCartBillingAddressCustomType;
  SetCartBusinessUnit: SetCartBusinessUnit;
  SetCartCountry: SetCartCountry;
  SetCartCustomField: SetCartCustomField;
  SetCartCustomLineItemCustomField: SetCartCustomLineItemCustomField;
  SetCartCustomLineItemCustomType: SetCartCustomLineItemCustomType;
  SetCartCustomLineItemShippingDetails: SetCartCustomLineItemShippingDetails;
  SetCartCustomLineItemTaxAmount: SetCartCustomLineItemTaxAmount;
  SetCartCustomLineItemTaxRate: SetCartCustomLineItemTaxRate;
  SetCartCustomShippingMethod: SetCartCustomShippingMethod;
  SetCartCustomType: SetCartCustomType;
  SetCartCustomerEmail: SetCartCustomerEmail;
  SetCartCustomerGroup: SetCartCustomerGroup;
  SetCartCustomerId: SetCartCustomerId;
  SetCartDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification;
  SetCartDirectDiscounts: SetCartDirectDiscounts;
  SetCartDiscountCustomField: SetCartDiscountCustomField;
  SetCartDiscountCustomType: SetCartDiscountCustomType;
  SetCartDiscountDescription: SetCartDiscountDescription;
  SetCartDiscountKey: SetCartDiscountKey;
  SetCartDiscountStores: SetCartDiscountStores;
  SetCartDiscountValidFrom: SetCartDiscountValidFrom;
  SetCartDiscountValidFromAndUntil: SetCartDiscountValidFromAndUntil;
  SetCartDiscountValidUntil: SetCartDiscountValidUntil;
  SetCartItemShippingAddressCustomField: SetCartItemShippingAddressCustomField;
  SetCartItemShippingAddressCustomType: SetCartItemShippingAddressCustomType;
  SetCartKey: SetCartKey;
  SetCartLineItemCustomField: SetCartLineItemCustomField;
  SetCartLineItemCustomType: SetCartLineItemCustomType;
  SetCartLineItemDistributionChannel: SetCartLineItemDistributionChannel;
  SetCartLineItemInventoryMode: SetCartLineItemInventoryMode;
  SetCartLineItemPrice: SetCartLineItemPrice;
  SetCartLineItemShippingDetails: SetCartLineItemShippingDetails;
  SetCartLineItemSupplyChannel: SetCartLineItemSupplyChannel;
  SetCartLineItemTaxAmount: SetCartLineItemTaxAmount;
  SetCartLineItemTaxRate: SetCartLineItemTaxRate;
  SetCartLineItemTotalPrice: SetCartLineItemTotalPrice;
  SetCartLocale: SetCartLocale;
  SetCartShippingAddress: SetCartShippingAddress;
  SetCartShippingAddressCustomField: SetCartShippingAddressCustomField;
  SetCartShippingAddressCustomType: SetCartShippingAddressCustomType;
  SetCartShippingCustomField: SetCartShippingCustomField;
  SetCartShippingCustomType: SetCartShippingCustomType;
  SetCartShippingMethod: SetCartShippingMethod;
  SetCartShippingMethodTaxAmount: SetCartShippingMethodTaxAmount;
  SetCartShippingMethodTaxRate: SetCartShippingMethodTaxRate;
  SetCartShippingRateInput: SetCartShippingRateInput;
  SetCartTotalTax: SetCartTotalTax;
  SetCategoryAssetCustomField: SetCategoryAssetCustomField;
  SetCategoryAssetCustomType: SetCategoryAssetCustomType;
  SetCategoryAssetDescription: SetCategoryAssetDescription;
  SetCategoryAssetKey: SetCategoryAssetKey;
  SetCategoryAssetSources: SetCategoryAssetSources;
  SetCategoryAssetTags: SetCategoryAssetTags;
  SetCategoryCustomField: SetCategoryCustomField;
  SetCategoryCustomType: SetCategoryCustomType;
  SetCategoryDescription: SetCategoryDescription;
  SetCategoryExternalId: SetCategoryExternalId;
  SetCategoryKey: SetCategoryKey;
  SetCategoryMetaDescription: SetCategoryMetaDescription;
  SetCategoryMetaKeywords: SetCategoryMetaKeywords;
  SetCategoryMetaTitle: SetCategoryMetaTitle;
  SetChannelAddress: SetChannelAddress;
  SetChannelAddressCustomField: SetChannelAddressCustomField;
  SetChannelAddressCustomType: SetChannelAddressCustomType;
  SetChannelCustomField: SetChannelCustomField;
  SetChannelCustomType: SetChannelCustomType;
  SetChannelGeoLocation: SetChannelGeoLocation;
  SetChannelRoles: SetChannelRoles;
  SetCustomerAddressCustomField: SetCustomerAddressCustomField;
  SetCustomerAddressCustomType: SetCustomerAddressCustomType;
  SetCustomerAuthenticationMode: SetCustomerAuthenticationMode;
  SetCustomerCompanyName: SetCustomerCompanyName;
  SetCustomerCustomField: SetCustomerCustomField;
  SetCustomerCustomType: SetCustomerCustomType;
  SetCustomerDateOfBirth: SetCustomerDateOfBirth;
  SetCustomerDefaultBillingAddress: SetCustomerDefaultBillingAddress;
  SetCustomerDefaultShippingAddress: SetCustomerDefaultShippingAddress;
  SetCustomerExternalId: SetCustomerExternalId;
  SetCustomerFirstName: SetCustomerFirstName;
  SetCustomerGroup: SetCustomerGroup;
  SetCustomerGroupCustomField: SetCustomerGroupCustomField;
  SetCustomerGroupCustomType: SetCustomerGroupCustomType;
  SetCustomerGroupKey: SetCustomerGroupKey;
  SetCustomerKey: SetCustomerKey;
  SetCustomerLastName: SetCustomerLastName;
  SetCustomerLocale: SetCustomerLocale;
  SetCustomerMiddleName: SetCustomerMiddleName;
  SetCustomerNumber: SetCustomerNumber;
  SetCustomerSalutation: SetCustomerSalutation;
  SetCustomerStores: SetCustomerStores;
  SetCustomerTitle: SetCustomerTitle;
  SetCustomerVatId: SetCustomerVatId;
  SetDiscountCodeCartPredicate: SetDiscountCodeCartPredicate;
  SetDiscountCodeCustomField: SetDiscountCodeCustomField;
  SetDiscountCodeCustomType: SetDiscountCodeCustomType;
  SetDiscountCodeDescription: SetDiscountCodeDescription;
  SetDiscountCodeMaxApplications: SetDiscountCodeMaxApplications;
  SetDiscountCodeMaxApplicationsPerCustomer: SetDiscountCodeMaxApplicationsPerCustomer;
  SetDiscountCodeName: SetDiscountCodeName;
  SetDiscountCodeValidFrom: SetDiscountCodeValidFrom;
  SetDiscountCodeValidFromAndUntil: SetDiscountCodeValidFromAndUntil;
  SetDiscountCodeValidUntil: SetDiscountCodeValidUntil;
  SetExtensionKey: SetExtensionKey;
  SetExtensionTimeoutInMs: SetExtensionTimeoutInMs;
  SetInventoryEntryCustomField: SetInventoryEntryCustomField;
  SetInventoryEntryCustomType: SetInventoryEntryCustomType;
  SetInventoryEntryExpectedDelivery: SetInventoryEntryExpectedDelivery;
  SetInventoryEntryRestockableInDays: SetInventoryEntryRestockableInDays;
  SetInventoryEntrySupplyChannel: SetInventoryEntrySupplyChannel;
  SetMyBusinessUnitAddressCustomField: SetMyBusinessUnitAddressCustomField;
  SetMyBusinessUnitAddressCustomType: SetMyBusinessUnitAddressCustomType;
  SetMyBusinessUnitContactEmail: SetMyBusinessUnitContactEmail;
  SetMyBusinessUnitCustomField: SetMyBusinessUnitCustomField;
  SetMyBusinessUnitCustomType: SetMyBusinessUnitCustomType;
  SetMyBusinessUnitDefaultBillingAddress: SetMyBusinessUnitDefaultBillingAddress;
  SetMyBusinessUnitDefaultShippingAddress: SetMyBusinessUnitDefaultShippingAddress;
  SetMyCartShippingMethod: SetMyCartShippingMethod;
  SetMyQuoteRequestCustomField: SetMyQuoteRequestCustomField;
  SetMyQuoteRequestCustomType: SetMyQuoteRequestCustomType;
  SetOrderBillingAddress: SetOrderBillingAddress;
  SetOrderBillingAddressCustomField: SetOrderBillingAddressCustomField;
  SetOrderBillingAddressCustomType: SetOrderBillingAddressCustomType;
  SetOrderCustomField: SetOrderCustomField;
  SetOrderCustomLineItemCustomField: SetOrderCustomLineItemCustomField;
  SetOrderCustomLineItemCustomType: SetOrderCustomLineItemCustomType;
  SetOrderCustomLineItemShippingDetails: SetOrderCustomLineItemShippingDetails;
  SetOrderCustomType: SetOrderCustomType;
  SetOrderCustomerEmail: SetOrderCustomerEmail;
  SetOrderCustomerId: SetOrderCustomerId;
  SetOrderDeliveryAddress: SetOrderDeliveryAddress;
  SetOrderDeliveryAddressCustomField: SetOrderDeliveryAddressCustomField;
  SetOrderDeliveryAddressCustomType: SetOrderDeliveryAddressCustomType;
  SetOrderDeliveryCustomField: SetOrderDeliveryCustomField;
  SetOrderDeliveryCustomType: SetOrderDeliveryCustomType;
  SetOrderDeliveryItems: SetOrderDeliveryItems;
  SetOrderEditComment: SetOrderEditComment;
  SetOrderEditCustomField: SetOrderEditCustomField;
  SetOrderEditCustomType: SetOrderEditCustomType;
  SetOrderEditKey: SetOrderEditKey;
  SetOrderEditStagedActions: SetOrderEditStagedActions;
  SetOrderItemShippingAddressCustomField: SetOrderItemShippingAddressCustomField;
  SetOrderItemShippingAddressCustomType: SetOrderItemShippingAddressCustomType;
  SetOrderLineItemCustomField: SetOrderLineItemCustomField;
  SetOrderLineItemCustomType: SetOrderLineItemCustomType;
  SetOrderLineItemShippingDetails: SetOrderLineItemShippingDetails;
  SetOrderLocale: SetOrderLocale;
  SetOrderNumber: SetOrderNumber;
  SetOrderParcelCustomField: SetOrderParcelCustomField;
  SetOrderParcelCustomType: SetOrderParcelCustomType;
  SetOrderParcelItems: SetOrderParcelItems;
  SetOrderParcelMeasurements: SetOrderParcelMeasurements;
  SetOrderParcelTrackingData: SetOrderParcelTrackingData;
  SetOrderPurchaseOrderNumber: SetOrderPurchaseOrderNumber;
  SetOrderReturnInfo: SetOrderReturnInfo;
  SetOrderReturnItemCustomField: SetOrderReturnItemCustomField;
  SetOrderReturnItemCustomType: SetOrderReturnItemCustomType;
  SetOrderReturnPaymentState: SetOrderReturnPaymentState;
  SetOrderReturnShipmentState: SetOrderReturnShipmentState;
  SetOrderShippingAddress: SetOrderShippingAddress;
  SetOrderShippingAddressCustomField: SetOrderShippingAddressCustomField;
  SetOrderShippingAddressCustomType: SetOrderShippingAddressCustomType;
  SetOrderShippingCustomField: SetOrderShippingCustomField;
  SetOrderShippingCustomType: SetOrderShippingCustomType;
  SetOrderStore: SetOrderStore;
  SetPaymentAmountPaid: SetPaymentAmountPaid;
  SetPaymentAmountRefunded: SetPaymentAmountRefunded;
  SetPaymentAnonymousId: SetPaymentAnonymousId;
  SetPaymentAuthorization: SetPaymentAuthorization;
  SetPaymentCustomField: SetPaymentCustomField;
  SetPaymentCustomType: SetPaymentCustomType;
  SetPaymentCustomer: SetPaymentCustomer;
  SetPaymentExternalId: SetPaymentExternalId;
  SetPaymentInterfaceId: SetPaymentInterfaceId;
  SetPaymentKey: SetPaymentKey;
  SetPaymentMethodInfoInterface: SetPaymentMethodInfoInterface;
  SetPaymentMethodInfoMethod: SetPaymentMethodInfoMethod;
  SetPaymentMethodInfoName: SetPaymentMethodInfoName;
  SetPaymentStatusInterfaceCode: SetPaymentStatusInterfaceCode;
  SetPaymentStatusInterfaceText: SetPaymentStatusInterfaceText;
  SetPaymentTransactionCustomField: SetPaymentTransactionCustomField;
  SetPaymentTransactionCustomType: SetPaymentTransactionCustomType;
  SetProductAssetCustomField: SetProductAssetCustomField;
  SetProductAssetCustomType: SetProductAssetCustomType;
  SetProductAssetDescription: SetProductAssetDescription;
  SetProductAssetKey: SetProductAssetKey;
  SetProductAssetSources: SetProductAssetSources;
  SetProductAssetTags: SetProductAssetTags;
  SetProductAttribute: SetProductAttribute;
  SetProductAttributeInAllVariants: SetProductAttributeInAllVariants;
  SetProductCategoryOrderHint: SetProductCategoryOrderHint;
  SetProductDescription: SetProductDescription;
  SetProductDiscountDescription: SetProductDiscountDescription;
  SetProductDiscountKey: SetProductDiscountKey;
  SetProductDiscountValidFrom: SetProductDiscountValidFrom;
  SetProductDiscountValidFromAndUntil: SetProductDiscountValidFromAndUntil;
  SetProductDiscountValidUntil: SetProductDiscountValidUntil;
  SetProductDiscountedPrice: SetProductDiscountedPrice;
  SetProductImageLabel: SetProductImageLabel;
  SetProductKey: SetProductKey;
  SetProductMetaAttributes: SetProductMetaAttributes;
  SetProductMetaDescription: SetProductMetaDescription;
  SetProductMetaKeywords: SetProductMetaKeywords;
  SetProductMetaTitle: SetProductMetaTitle;
  SetProductPriceCustomField: SetProductPriceCustomField;
  SetProductPriceCustomType: SetProductPriceCustomType;
  SetProductPriceKey: SetProductPriceKey;
  SetProductPriceMode: SetProductPriceMode;
  SetProductPrices: SetProductPrices;
  SetProductSelectionCustomField: SetProductSelectionCustomField;
  SetProductSelectionCustomType: SetProductSelectionCustomType;
  SetProductSelectionKey: SetProductSelectionKey;
  SetProductSelectionVariantExclusion: SetProductSelectionVariantExclusion;
  SetProductSelectionVariantSelection: SetProductSelectionVariantSelection;
  SetProductSku: SetProductSku;
  SetProductTaxCategory: SetProductTaxCategory;
  SetProductVariantKey: SetProductVariantKey;
  SetProjectSettingsExternalOAuth: SetProjectSettingsExternalOAuth;
  SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation: SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation;
  SetProjectSettingsShippingRateInputType: SetProjectSettingsShippingRateInputType;
  SetQuoteCustomField: SetQuoteCustomField;
  SetQuoteCustomType: SetQuoteCustomType;
  SetQuoteRequestCustomField: SetQuoteRequestCustomField;
  SetQuoteRequestCustomType: SetQuoteRequestCustomType;
  SetReviewAuthorName: SetReviewAuthorName;
  SetReviewCustomField: SetReviewCustomField;
  SetReviewCustomType: SetReviewCustomType;
  SetReviewCustomer: SetReviewCustomer;
  SetReviewKey: SetReviewKey;
  SetReviewLocale: SetReviewLocale;
  SetReviewRating: SetReviewRating;
  SetReviewTarget: SetReviewTarget;
  SetReviewText: SetReviewText;
  SetReviewTitle: SetReviewTitle;
  SetSearchKeywords: SetSearchKeywords;
  SetShippingMethodCustomField: SetShippingMethodCustomField;
  SetShippingMethodCustomType: SetShippingMethodCustomType;
  SetShippingMethodDescription: SetShippingMethodDescription;
  SetShippingMethodKey: SetShippingMethodKey;
  SetShippingMethodLocalizedDescription: SetShippingMethodLocalizedDescription;
  SetShippingMethodLocalizedName: SetShippingMethodLocalizedName;
  SetShippingMethodPredicate: SetShippingMethodPredicate;
  SetShoppingListAnonymousId: SetShoppingListAnonymousId;
  SetShoppingListCustomField: SetShoppingListCustomField;
  SetShoppingListCustomType: SetShoppingListCustomType;
  SetShoppingListCustomer: SetShoppingListCustomer;
  SetShoppingListDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification;
  SetShoppingListDescription: SetShoppingListDescription;
  SetShoppingListKey: SetShoppingListKey;
  SetShoppingListLineItemCustomField: SetShoppingListLineItemCustomField;
  SetShoppingListLineItemCustomType: SetShoppingListLineItemCustomType;
  SetShoppingListSlug: SetShoppingListSlug;
  SetShoppingListStore: SetShoppingListStore;
  SetShoppingListTextLineItemCustomField: SetShoppingListTextLineItemCustomField;
  SetShoppingListTextLineItemCustomType: SetShoppingListTextLineItemCustomType;
  SetShoppingListTextLineItemDescription: SetShoppingListTextLineItemDescription;
  SetStagedOrderBillingAddress: SetStagedOrderBillingAddress;
  SetStagedOrderBillingAddressCustomField: SetStagedOrderBillingAddressCustomField;
  SetStagedOrderBillingAddressCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderBillingAddressCustomFieldOutput>;
  SetStagedOrderBillingAddressCustomType: SetStagedOrderBillingAddressCustomType;
  SetStagedOrderBillingAddressCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderBillingAddressCustomTypeOutput>;
  SetStagedOrderBillingAddressOutput: ResolverTypeWrapper<SetStagedOrderBillingAddressOutput>;
  SetStagedOrderCountry: SetStagedOrderCountry;
  SetStagedOrderCountryOutput: ResolverTypeWrapper<SetStagedOrderCountryOutput>;
  SetStagedOrderCustomField: SetStagedOrderCustomField;
  SetStagedOrderCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderCustomFieldOutput>;
  SetStagedOrderCustomLineItemCustomField: SetStagedOrderCustomLineItemCustomField;
  SetStagedOrderCustomLineItemCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderCustomLineItemCustomFieldOutput>;
  SetStagedOrderCustomLineItemCustomType: SetStagedOrderCustomLineItemCustomType;
  SetStagedOrderCustomLineItemCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderCustomLineItemCustomTypeOutput>;
  SetStagedOrderCustomLineItemShippingDetails: SetStagedOrderCustomLineItemShippingDetails;
  SetStagedOrderCustomLineItemShippingDetailsOutput: ResolverTypeWrapper<SetStagedOrderCustomLineItemShippingDetailsOutput>;
  SetStagedOrderCustomLineItemTaxAmount: SetStagedOrderCustomLineItemTaxAmount;
  SetStagedOrderCustomLineItemTaxAmountOutput: ResolverTypeWrapper<SetStagedOrderCustomLineItemTaxAmountOutput>;
  SetStagedOrderCustomLineItemTaxRate: SetStagedOrderCustomLineItemTaxRate;
  SetStagedOrderCustomLineItemTaxRateOutput: ResolverTypeWrapper<SetStagedOrderCustomLineItemTaxRateOutput>;
  SetStagedOrderCustomShippingMethod: SetStagedOrderCustomShippingMethod;
  SetStagedOrderCustomShippingMethodOutput: ResolverTypeWrapper<SetStagedOrderCustomShippingMethodOutput>;
  SetStagedOrderCustomType: SetStagedOrderCustomType;
  SetStagedOrderCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderCustomTypeOutput>;
  SetStagedOrderCustomerEmail: SetStagedOrderCustomerEmail;
  SetStagedOrderCustomerEmailOutput: ResolverTypeWrapper<SetStagedOrderCustomerEmailOutput>;
  SetStagedOrderCustomerGroup: SetStagedOrderCustomerGroup;
  SetStagedOrderCustomerGroupOutput: ResolverTypeWrapper<SetStagedOrderCustomerGroupOutput>;
  SetStagedOrderCustomerId: SetStagedOrderCustomerId;
  SetStagedOrderCustomerIdOutput: ResolverTypeWrapper<SetStagedOrderCustomerIdOutput>;
  SetStagedOrderDeliveryAddress: SetStagedOrderDeliveryAddress;
  SetStagedOrderDeliveryAddressCustomField: SetStagedOrderDeliveryAddressCustomField;
  SetStagedOrderDeliveryAddressCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderDeliveryAddressCustomFieldOutput>;
  SetStagedOrderDeliveryAddressCustomType: SetStagedOrderDeliveryAddressCustomType;
  SetStagedOrderDeliveryAddressCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderDeliveryAddressCustomTypeOutput>;
  SetStagedOrderDeliveryAddressOutput: ResolverTypeWrapper<SetStagedOrderDeliveryAddressOutput>;
  SetStagedOrderDeliveryCustomField: SetStagedOrderDeliveryCustomField;
  SetStagedOrderDeliveryCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderDeliveryCustomFieldOutput>;
  SetStagedOrderDeliveryCustomType: SetStagedOrderDeliveryCustomType;
  SetStagedOrderDeliveryCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderDeliveryCustomTypeOutput>;
  SetStagedOrderDeliveryItems: SetStagedOrderDeliveryItems;
  SetStagedOrderDeliveryItemsOutput: ResolverTypeWrapper<SetStagedOrderDeliveryItemsOutput>;
  SetStagedOrderDirectDiscounts: SetStagedOrderDirectDiscounts;
  SetStagedOrderDirectDiscountsOutput: ResolverTypeWrapper<SetStagedOrderDirectDiscountsOutput>;
  SetStagedOrderItemShippingAddressCustomField: SetStagedOrderItemShippingAddressCustomField;
  SetStagedOrderItemShippingAddressCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderItemShippingAddressCustomFieldOutput>;
  SetStagedOrderItemShippingAddressCustomType: SetStagedOrderItemShippingAddressCustomType;
  SetStagedOrderItemShippingAddressCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderItemShippingAddressCustomTypeOutput>;
  SetStagedOrderLineItemCustomField: SetStagedOrderLineItemCustomField;
  SetStagedOrderLineItemCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderLineItemCustomFieldOutput>;
  SetStagedOrderLineItemCustomType: SetStagedOrderLineItemCustomType;
  SetStagedOrderLineItemCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderLineItemCustomTypeOutput>;
  SetStagedOrderLineItemDistributionChannel: SetStagedOrderLineItemDistributionChannel;
  SetStagedOrderLineItemDistributionChannelOutput: ResolverTypeWrapper<SetStagedOrderLineItemDistributionChannelOutput>;
  SetStagedOrderLineItemPrice: SetStagedOrderLineItemPrice;
  SetStagedOrderLineItemPriceOutput: ResolverTypeWrapper<SetStagedOrderLineItemPriceOutput>;
  SetStagedOrderLineItemShippingDetails: SetStagedOrderLineItemShippingDetails;
  SetStagedOrderLineItemShippingDetailsOutput: ResolverTypeWrapper<SetStagedOrderLineItemShippingDetailsOutput>;
  SetStagedOrderLineItemTaxAmount: SetStagedOrderLineItemTaxAmount;
  SetStagedOrderLineItemTaxAmountOutput: ResolverTypeWrapper<SetStagedOrderLineItemTaxAmountOutput>;
  SetStagedOrderLineItemTaxRate: SetStagedOrderLineItemTaxRate;
  SetStagedOrderLineItemTaxRateOutput: ResolverTypeWrapper<SetStagedOrderLineItemTaxRateOutput>;
  SetStagedOrderLineItemTotalPrice: SetStagedOrderLineItemTotalPrice;
  SetStagedOrderLineItemTotalPriceOutput: ResolverTypeWrapper<SetStagedOrderLineItemTotalPriceOutput>;
  SetStagedOrderLocale: SetStagedOrderLocale;
  SetStagedOrderLocaleOutput: ResolverTypeWrapper<SetStagedOrderLocaleOutput>;
  SetStagedOrderOrderNumber: SetStagedOrderOrderNumber;
  SetStagedOrderOrderNumberOutput: ResolverTypeWrapper<SetStagedOrderOrderNumberOutput>;
  SetStagedOrderOrderTotalTax: SetStagedOrderOrderTotalTax;
  SetStagedOrderOrderTotalTaxOutput: ResolverTypeWrapper<SetStagedOrderOrderTotalTaxOutput>;
  SetStagedOrderParcelCustomField: SetStagedOrderParcelCustomField;
  SetStagedOrderParcelCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderParcelCustomFieldOutput>;
  SetStagedOrderParcelCustomType: SetStagedOrderParcelCustomType;
  SetStagedOrderParcelCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderParcelCustomTypeOutput>;
  SetStagedOrderParcelItems: SetStagedOrderParcelItems;
  SetStagedOrderParcelItemsOutput: ResolverTypeWrapper<SetStagedOrderParcelItemsOutput>;
  SetStagedOrderParcelMeasurements: SetStagedOrderParcelMeasurements;
  SetStagedOrderParcelMeasurementsOutput: ResolverTypeWrapper<SetStagedOrderParcelMeasurementsOutput>;
  SetStagedOrderParcelTrackingData: SetStagedOrderParcelTrackingData;
  SetStagedOrderParcelTrackingDataOutput: ResolverTypeWrapper<SetStagedOrderParcelTrackingDataOutput>;
  SetStagedOrderPurchaseOrderNumber: SetStagedOrderPurchaseOrderNumber;
  SetStagedOrderPurchaseOrderNumberOutput: ResolverTypeWrapper<SetStagedOrderPurchaseOrderNumberOutput>;
  SetStagedOrderReturnInfo: SetStagedOrderReturnInfo;
  SetStagedOrderReturnInfoOutput: ResolverTypeWrapper<SetStagedOrderReturnInfoOutput>;
  SetStagedOrderReturnItemCustomField: SetStagedOrderReturnItemCustomField;
  SetStagedOrderReturnItemCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderReturnItemCustomFieldOutput>;
  SetStagedOrderReturnItemCustomType: SetStagedOrderReturnItemCustomType;
  SetStagedOrderReturnItemCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderReturnItemCustomTypeOutput>;
  SetStagedOrderReturnPaymentState: SetStagedOrderReturnPaymentState;
  SetStagedOrderReturnPaymentStateOutput: ResolverTypeWrapper<SetStagedOrderReturnPaymentStateOutput>;
  SetStagedOrderReturnShipmentState: SetStagedOrderReturnShipmentState;
  SetStagedOrderReturnShipmentStateOutput: ResolverTypeWrapper<SetStagedOrderReturnShipmentStateOutput>;
  SetStagedOrderShippingAddress: SetStagedOrderShippingAddress;
  SetStagedOrderShippingAddressAndCustomShippingMethod: SetStagedOrderShippingAddressAndCustomShippingMethod;
  SetStagedOrderShippingAddressAndCustomShippingMethodOutput: ResolverTypeWrapper<SetStagedOrderShippingAddressAndCustomShippingMethodOutput>;
  SetStagedOrderShippingAddressAndShippingMethod: SetStagedOrderShippingAddressAndShippingMethod;
  SetStagedOrderShippingAddressAndShippingMethodOutput: ResolverTypeWrapper<SetStagedOrderShippingAddressAndShippingMethodOutput>;
  SetStagedOrderShippingAddressCustomField: SetStagedOrderShippingAddressCustomField;
  SetStagedOrderShippingAddressCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderShippingAddressCustomFieldOutput>;
  SetStagedOrderShippingAddressCustomType: SetStagedOrderShippingAddressCustomType;
  SetStagedOrderShippingAddressCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderShippingAddressCustomTypeOutput>;
  SetStagedOrderShippingAddressOutput: ResolverTypeWrapper<SetStagedOrderShippingAddressOutput>;
  SetStagedOrderShippingCustomField: SetStagedOrderShippingCustomField;
  SetStagedOrderShippingCustomFieldOutput: ResolverTypeWrapper<SetStagedOrderShippingCustomFieldOutput>;
  SetStagedOrderShippingCustomType: SetStagedOrderShippingCustomType;
  SetStagedOrderShippingCustomTypeOutput: ResolverTypeWrapper<SetStagedOrderShippingCustomTypeOutput>;
  SetStagedOrderShippingMethod: SetStagedOrderShippingMethod;
  SetStagedOrderShippingMethodOutput: ResolverTypeWrapper<SetStagedOrderShippingMethodOutput>;
  SetStagedOrderShippingMethodTaxAmount: SetStagedOrderShippingMethodTaxAmount;
  SetStagedOrderShippingMethodTaxAmountOutput: ResolverTypeWrapper<SetStagedOrderShippingMethodTaxAmountOutput>;
  SetStagedOrderShippingMethodTaxRate: SetStagedOrderShippingMethodTaxRate;
  SetStagedOrderShippingMethodTaxRateOutput: ResolverTypeWrapper<SetStagedOrderShippingMethodTaxRateOutput>;
  SetStagedOrderShippingRateInput: SetStagedOrderShippingRateInput;
  SetStagedOrderShippingRateInputOutput: ResolverTypeWrapper<SetStagedOrderShippingRateInputOutput>;
  SetStagedOrderStore: SetStagedOrderStore;
  SetStagedOrderStoreOutput: ResolverTypeWrapper<SetStagedOrderStoreOutput>;
  SetStagedQuoteCustomField: SetStagedQuoteCustomField;
  SetStagedQuoteCustomType: SetStagedQuoteCustomType;
  SetStagedQuoteSellerComment: SetStagedQuoteSellerComment;
  SetStagedQuoteValidTo: SetStagedQuoteValidTo;
  SetStandalonePriceCustomFields: SetStandalonePriceCustomFields;
  SetStandalonePriceDiscountedPrice: SetStandalonePriceDiscountedPrice;
  SetStandalonePriceKey: SetStandalonePriceKey;
  SetStandalonePriceTiers: SetStandalonePriceTiers;
  SetStandalonePriceValidFrom: SetStandalonePriceValidFrom;
  SetStandalonePriceValidFromAndUntil: SetStandalonePriceValidFromAndUntil;
  SetStandalonePriceValidUntil: SetStandalonePriceValidUntil;
  SetStateDescription: SetStateDescription;
  SetStateName: SetStateName;
  SetStateRoles: SetStateRoles;
  SetStateTransitions: SetStateTransitions;
  SetStoreCountries: SetStoreCountries;
  SetStoreCustomField: SetStoreCustomField;
  SetStoreCustomType: SetStoreCustomType;
  SetStoreDistributionChannels: SetStoreDistributionChannels;
  SetStoreLanguages: SetStoreLanguages;
  SetStoreName: SetStoreName;
  SetStoreProductSelections: SetStoreProductSelections;
  SetStoreSupplyChannels: SetStoreSupplyChannels;
  SetSubscriptionChanges: SetSubscriptionChanges;
  SetSubscriptionKey: SetSubscriptionKey;
  SetSubscriptionMessages: SetSubscriptionMessages;
  SetTaxCategoryKey: SetTaxCategoryKey;
  SetType: ResolverTypeWrapper<SetType>;
  SetTypeDescription: SetTypeDescription;
  SetZoneDescription: SetZoneDescription;
  SetZoneKey: SetZoneKey;
  ShipmentState: ShipmentState;
  Shipping: ResolverTypeWrapper<Shipping>;
  ShippingDraft: ShippingDraft;
  ShippingInfo: ResolverTypeWrapper<ShippingInfo>;
  ShippingInfoImportDraft: ShippingInfoImportDraft;
  ShippingMethod: ResolverTypeWrapper<ShippingMethod>;
  ShippingMethodDraft: ShippingMethodDraft;
  ShippingMethodLimitWithCurrent: ResolverTypeWrapper<ShippingMethodLimitWithCurrent>;
  ShippingMethodLimitsProjection: ResolverTypeWrapper<ShippingMethodLimitsProjection>;
  ShippingMethodQueryResult: ResolverTypeWrapper<ShippingMethodQueryResult>;
  ShippingMethodState: ShippingMethodState;
  ShippingMethodUpdateAction: ShippingMethodUpdateAction;
  ShippingMethodsByCartInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShippingMethodsByCartInterface']>;
  ShippingMode: ShippingMode;
  ShippingRate: ResolverTypeWrapper<ShippingRate>;
  ShippingRateCartClassificationPriceTier: ResolverTypeWrapper<ShippingRateCartClassificationPriceTier>;
  ShippingRateCartScorePriceTier: ResolverTypeWrapper<ShippingRateCartScorePriceTier>;
  ShippingRateCartValuePriceTier: ResolverTypeWrapper<ShippingRateCartValuePriceTier>;
  ShippingRateDraft: ShippingRateDraft;
  ShippingRateInput: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShippingRateInput']>;
  ShippingRateInputDraft: ShippingRateInputDraft;
  ShippingRateInputDraftOutput: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShippingRateInputDraftOutput']>;
  ShippingRateInputLocalizedEnumValue: ResolverTypeWrapper<ShippingRateInputLocalizedEnumValue>;
  ShippingRateInputType: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShippingRateInputType']>;
  ShippingRateInputTypeInput: ShippingRateInputTypeInput;
  ShippingRatePriceTier: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShippingRatePriceTier']>;
  ShippingRatePriceTierCartClassificationDraft: ShippingRatePriceTierCartClassificationDraft;
  ShippingRatePriceTierCartScoreDraft: ShippingRatePriceTierCartScoreDraft;
  ShippingRatePriceTierCartValueDraft: ShippingRatePriceTierCartValueDraft;
  ShippingRatePriceTierDraft: ShippingRatePriceTierDraft;
  ShippingTarget: ResolverTypeWrapper<ShippingTarget>;
  ShippingTargetDraft: ShippingTargetDraft;
  ShippingTargetDraftType: ShippingTargetDraftType;
  ShippingTargetInput: ShippingTargetInput;
  ShoppingList: ResolverTypeWrapper<ShoppingList>;
  ShoppingListDraft: ShoppingListDraft;
  ShoppingListLimitWithCurrent: ResolverTypeWrapper<ShoppingListLimitWithCurrent>;
  ShoppingListLimitsProjection: ResolverTypeWrapper<ShoppingListLimitsProjection>;
  ShoppingListLineItem: ResolverTypeWrapper<ShoppingListLineItem>;
  ShoppingListLineItemDraft: ShoppingListLineItemDraft;
  ShoppingListQueryInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['ShoppingListQueryInterface']>;
  ShoppingListQueryResult: ResolverTypeWrapper<ShoppingListQueryResult>;
  ShoppingListUpdateAction: ShoppingListUpdateAction;
  ShoppingListsConfiguration: ResolverTypeWrapper<ShoppingListsConfiguration>;
  ShoppingListsConfigurationInput: ShoppingListsConfigurationInput;
  SignUpInMyBusinessUnitDraft: SignUpInMyBusinessUnitDraft;
  SimpleAssociateRole: SimpleAssociateRole;
  SimpleAttributeTypeDraft: SimpleAttributeTypeDraft;
  SimpleFieldTypeDraft: SimpleFieldTypeDraft;
  StackingMode: StackingMode;
  StagedOrderUpdateAction: StagedOrderUpdateAction;
  StagedOrderUpdateActionOutput: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['StagedOrderUpdateActionOutput']>;
  StagedPriceDraft: StagedPriceDraft;
  StagedQuote: ResolverTypeWrapper<StagedQuote>;
  StagedQuoteDraft: StagedQuoteDraft;
  StagedQuoteQueryResult: ResolverTypeWrapper<StagedQuoteQueryResult>;
  StagedQuoteState: StagedQuoteState;
  StagedQuoteUpdateAction: StagedQuoteUpdateAction;
  StagedStandalonePrice: ResolverTypeWrapper<StagedStandalonePrice>;
  StandalonePrice: ResolverTypeWrapper<StandalonePrice>;
  StandalonePriceActiveChanged: ResolverTypeWrapper<StandalonePriceActiveChanged>;
  StandalonePriceCreated: ResolverTypeWrapper<StandalonePriceCreated>;
  StandalonePriceDeleted: ResolverTypeWrapper<StandalonePriceDeleted>;
  StandalonePriceDiscountSet: ResolverTypeWrapper<StandalonePriceDiscountSet>;
  StandalonePriceExpiresAtSet: ResolverTypeWrapper<StandalonePriceExpiresAtSet>;
  StandalonePriceExternalDiscountSet: ResolverTypeWrapper<StandalonePriceExternalDiscountSet>;
  StandalonePriceKeySet: ResolverTypeWrapper<StandalonePriceKeySet>;
  StandalonePriceQueryResult: ResolverTypeWrapper<StandalonePriceQueryResult>;
  StandalonePriceStagedChangesApplied: ResolverTypeWrapper<StandalonePriceStagedChangesApplied>;
  StandalonePriceStagedChangesRemoved: ResolverTypeWrapper<StandalonePriceStagedChangesRemoved>;
  StandalonePriceTierAdded: ResolverTypeWrapper<StandalonePriceTierAdded>;
  StandalonePriceTierRemoved: ResolverTypeWrapper<StandalonePriceTierRemoved>;
  StandalonePriceTiersSet: ResolverTypeWrapper<StandalonePriceTiersSet>;
  StandalonePriceUpdateAction: StandalonePriceUpdateAction;
  StandalonePriceValidFromAndUntilSet: ResolverTypeWrapper<StandalonePriceValidFromAndUntilSet>;
  StandalonePriceValidFromSet: ResolverTypeWrapper<StandalonePriceValidFromSet>;
  StandalonePriceValidUntilSet: ResolverTypeWrapper<StandalonePriceValidUntilSet>;
  StandalonePriceValueChanged: ResolverTypeWrapper<StandalonePriceValueChanged>;
  State: ResolverTypeWrapper<State>;
  StateDraft: StateDraft;
  StateQueryResult: ResolverTypeWrapper<StateQueryResult>;
  StateRole: StateRole;
  StateType: StateType;
  StateUpdateAction: StateUpdateAction;
  Store: ResolverTypeWrapper<Store>;
  StoreCountriesChanged: ResolverTypeWrapper<StoreCountriesChanged>;
  StoreCountry: ResolverTypeWrapper<StoreCountry>;
  StoreCountryInput: StoreCountryInput;
  StoreCreated: ResolverTypeWrapper<StoreCreated>;
  StoreDeleted: ResolverTypeWrapper<StoreDeleted>;
  StoreDistributionChannelsChanged: ResolverTypeWrapper<StoreDistributionChannelsChanged>;
  StoreLanguagesChanged: ResolverTypeWrapper<StoreLanguagesChanged>;
  StoreLimitWithCurrent: ResolverTypeWrapper<StoreLimitWithCurrent>;
  StoreLimitsProjection: ResolverTypeWrapper<StoreLimitsProjection>;
  StoreNameSet: ResolverTypeWrapper<StoreNameSet>;
  StoreProductSelectionsChanged: ResolverTypeWrapper<StoreProductSelectionsChanged>;
  StoreQueryResult: ResolverTypeWrapper<StoreQueryResult>;
  StoreSupplyChannelsChanged: ResolverTypeWrapper<StoreSupplyChannelsChanged>;
  StoreUpdateAction: StoreUpdateAction;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  StringAttribute: ResolverTypeWrapper<StringAttribute>;
  StringField: ResolverTypeWrapper<StringField>;
  StringType: ResolverTypeWrapper<StringType>;
  SubRate: ResolverTypeWrapper<SubRate>;
  SubRateDraft: SubRateDraft;
  SubscriptionDraft: SubscriptionDraft;
  SubscriptionFormatInput: SubscriptionFormatInput;
  SubscriptionHealthStatus: SubscriptionHealthStatus;
  SubscriptionUpdateAction: SubscriptionUpdateAction;
  SubscriptionsLimitsProjection: ResolverTypeWrapper<SubscriptionsLimitsProjection>;
  SuggestResult: ResolverTypeWrapper<SuggestResult>;
  SuggestResultEntry: ResolverTypeWrapper<SuggestResultEntry>;
  SuggestTokenizer: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['SuggestTokenizer']>;
  SuggestTokenizerProductSearch: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['SuggestTokenizerProductSearch']>;
  Suggestion: ResolverTypeWrapper<Suggestion>;
  SyncInfo: ResolverTypeWrapper<SyncInfo>;
  TargetReferenceInput: TargetReferenceInput;
  TaxCalculationMode: TaxCalculationMode;
  TaxCategory: ResolverTypeWrapper<TaxCategory>;
  TaxCategoryAddTaxRate: TaxCategoryAddTaxRate;
  TaxCategoryChangeName: TaxCategoryChangeName;
  TaxCategoryDraft: TaxCategoryDraft;
  TaxCategoryLimitWithCurrent: ResolverTypeWrapper<TaxCategoryLimitWithCurrent>;
  TaxCategoryLimitsProjection: ResolverTypeWrapper<TaxCategoryLimitsProjection>;
  TaxCategoryQueryResult: ResolverTypeWrapper<TaxCategoryQueryResult>;
  TaxCategoryRemoveTaxRate: TaxCategoryRemoveTaxRate;
  TaxCategoryReplaceTaxRate: TaxCategoryReplaceTaxRate;
  TaxCategorySetDescription: TaxCategorySetDescription;
  TaxCategoryUpdateAction: TaxCategoryUpdateAction;
  TaxMode: TaxMode;
  TaxPortion: ResolverTypeWrapper<TaxPortion>;
  TaxPortionDraft: TaxPortionDraft;
  TaxRate: ResolverTypeWrapper<TaxRate>;
  TaxRateDraft: TaxRateDraft;
  TaxRateInput: TaxRateInput;
  TaxedItemPrice: ResolverTypeWrapper<TaxedItemPrice>;
  TaxedPrice: ResolverTypeWrapper<TaxedPrice>;
  TaxedPriceDraft: TaxedPriceDraft;
  TermCount: ResolverTypeWrapper<TermCount>;
  TermsFacetInput: TermsFacetInput;
  TermsFacetResult: ResolverTypeWrapper<TermsFacetResult>;
  TextAttributeDefinitionType: ResolverTypeWrapper<TextAttributeDefinitionType>;
  TextInputHint: TextInputHint;
  TextLineItem: ResolverTypeWrapper<TextLineItem>;
  TextLineItemDraft: TextLineItemDraft;
  Time: ResolverTypeWrapper<Scalars['Time']['output']>;
  TimeAttribute: ResolverTypeWrapper<TimeAttribute>;
  TimeAttributeDefinitionType: ResolverTypeWrapper<TimeAttributeDefinitionType>;
  TimeField: ResolverTypeWrapper<TimeField>;
  TimeType: ResolverTypeWrapper<TimeType>;
  TrackingData: ResolverTypeWrapper<TrackingData>;
  TrackingDataDraftType: TrackingDataDraftType;
  Transaction: ResolverTypeWrapper<Transaction>;
  TransactionDraft: TransactionDraft;
  TransactionState: TransactionState;
  TransactionType: TransactionType;
  TransitionOrderCustomLineItemState: TransitionOrderCustomLineItemState;
  TransitionOrderLineItemState: TransitionOrderLineItemState;
  TransitionOrderState: TransitionOrderState;
  TransitionPaymentState: TransitionPaymentState;
  TransitionProductState: TransitionProductState;
  TransitionQuoteRequestState: TransitionQuoteRequestState;
  TransitionQuoteState: TransitionQuoteState;
  TransitionReviewState: TransitionReviewState;
  TransitionStagedOrderCustomLineItemState: TransitionStagedOrderCustomLineItemState;
  TransitionStagedOrderCustomLineItemStateOutput: ResolverTypeWrapper<TransitionStagedOrderCustomLineItemStateOutput>;
  TransitionStagedOrderLineItemState: TransitionStagedOrderLineItemState;
  TransitionStagedOrderLineItemStateOutput: ResolverTypeWrapper<TransitionStagedOrderLineItemStateOutput>;
  TransitionStagedOrderState: TransitionStagedOrderState;
  TransitionStagedOrderStateOutput: ResolverTypeWrapper<TransitionStagedOrderStateOutput>;
  TransitionStagedQuoteState: TransitionStagedQuoteState;
  TreeFilterInput: TreeFilterInput;
  Trigger: ResolverTypeWrapper<Trigger>;
  TriggerInput: TriggerInput;
  TypeDefinition: ResolverTypeWrapper<TypeDefinition>;
  TypeDefinitionDraft: TypeDefinitionDraft;
  TypeDefinitionQueryResult: ResolverTypeWrapper<TypeDefinitionQueryResult>;
  TypeUpdateAction: TypeUpdateAction;
  UnfreezeCart: UnfreezeCart;
  UnpublishProduct: UnpublishProduct;
  UpdateCartItemShippingAddress: UpdateCartItemShippingAddress;
  UpdateOrderItemShippingAddress: UpdateOrderItemShippingAddress;
  UpdateOrderSyncInfo: UpdateOrderSyncInfo;
  UpdateStagedOrderItemShippingAddress: UpdateStagedOrderItemShippingAddress;
  UpdateStagedOrderItemShippingAddressOutput: ResolverTypeWrapper<UpdateStagedOrderItemShippingAddressOutput>;
  UpdateStagedOrderSyncInfo: UpdateStagedOrderSyncInfo;
  UpdateStagedOrderSyncInfoOutput: ResolverTypeWrapper<UpdateStagedOrderSyncInfoOutput>;
  UserProvidedIdentifiers: ResolverTypeWrapper<UserProvidedIdentifiers>;
  ValueFacetResult: ResolverTypeWrapper<ValueFacetResult>;
  ValueFilterInput: ValueFilterInput;
  Versioned: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Versioned']>;
  WhitespaceSuggestTokenizer: ResolverTypeWrapper<WhitespaceSuggestTokenizer>;
  WhitespaceSuggestTokenizerInput: WhitespaceSuggestTokenizerInput;
  WhitespaceSuggestTokenizerProductSearch: ResolverTypeWrapper<WhitespaceSuggestTokenizerProductSearch>;
  YearMonth: ResolverTypeWrapper<Scalars['YearMonth']['output']>;
  Zone: ResolverTypeWrapper<Zone>;
  ZoneLimitWithCurrent: ResolverTypeWrapper<ZoneLimitWithCurrent>;
  ZoneLimitsProjection: ResolverTypeWrapper<ZoneLimitsProjection>;
  ZoneLocation: ZoneLocation;
  ZoneQueryResult: ResolverTypeWrapper<ZoneQueryResult>;
  ZoneRate: ResolverTypeWrapper<ZoneRate>;
  ZoneRateDraft: ZoneRateDraft;
  ZoneUpdateAction: ZoneUpdateAction;
  addAttributeDefinition: AddAttributeDefinition;
  addLocalizedEnumValue: AddLocalizedEnumValue;
  addPlainEnumValue: AddPlainEnumValue;
  changeAttributeName: ChangeAttributeName;
  changeAttributeOrder: ChangeAttributeOrder;
  changeAttributeOrderByName: ChangeAttributeOrderByName;
  changeDescription: ChangeDescription;
  changeEnumKey: ChangeEnumKey;
  changeInputHint: ChangeInputHint;
  changeIsSearchable: ChangeIsSearchable;
  changeLabel: ChangeLabel;
  changeLocalizedEnumValueLabel: ChangeLocalizedEnumValueLabel;
  changeLocalizedEnumValueOrder: ChangeLocalizedEnumValueOrder;
  changeName: ChangeName;
  changePlainEnumValueLabel: ChangePlainEnumValueLabel;
  changePlainEnumValueOrder: ChangePlainEnumValueOrder;
  removeAttributeDefinition: RemoveAttributeDefinition;
  removeEnumValues: RemoveEnumValues;
  setInputTip: SetInputTip;
  setKey: SetKey;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  APIClientWithSecret: ApiClientWithSecret;
  APIClientWithoutSecret: ApiClientWithoutSecret;
  APIClientWithoutSecretQueryResult: ApiClientWithoutSecretQueryResult;
  AWSLambdaDestination: AwsLambdaDestination;
  AWSLambdaDestinationInput: AwsLambdaDestinationInput;
  AbsoluteDiscountValue: AbsoluteDiscountValue;
  AbsoluteDiscountValueInput: AbsoluteDiscountValueInput;
  ActiveCartInterface: ResolversInterfaceTypes<ResolversParentTypes>['ActiveCartInterface'];
  AddAssociateRolePermission: AddAssociateRolePermission;
  AddAttributeGroupAttribute: AddAttributeGroupAttribute;
  AddBusinessUnitAddress: AddBusinessUnitAddress;
  AddBusinessUnitAssociate: AddBusinessUnitAssociate;
  AddBusinessUnitBillingAddressId: AddBusinessUnitBillingAddressId;
  AddBusinessUnitShippingAddressId: AddBusinessUnitShippingAddressId;
  AddBusinessUnitStore: AddBusinessUnitStore;
  AddCartCustomLineItem: AddCartCustomLineItem;
  AddCartCustomShippingMethod: AddCartCustomShippingMethod;
  AddCartDiscountCode: AddCartDiscountCode;
  AddCartDiscountStore: AddCartDiscountStore;
  AddCartItemShippingAddress: AddCartItemShippingAddress;
  AddCartLineItem: AddCartLineItem;
  AddCartPayment: AddCartPayment;
  AddCartShippingMethod: AddCartShippingMethod;
  AddCartShoppingList: AddCartShoppingList;
  AddCategoryAsset: AddCategoryAsset;
  AddChannelRoles: AddChannelRoles;
  AddCustomerAddress: AddCustomerAddress;
  AddCustomerBillingAddressId: AddCustomerBillingAddressId;
  AddCustomerShippingAddressId: AddCustomerShippingAddressId;
  AddCustomerStore: AddCustomerStore;
  AddInventoryEntryQuantity: AddInventoryEntryQuantity;
  AddMyBusinessUnitAddress: AddMyBusinessUnitAddress;
  AddMyBusinessUnitBillingAddressId: AddMyBusinessUnitBillingAddressId;
  AddMyBusinessUnitShippingAddressId: AddMyBusinessUnitShippingAddressId;
  AddMyCartLineItem: AddMyCartLineItem;
  AddMyPaymentTransaction: AddMyPaymentTransaction;
  AddOrderDelivery: AddOrderDelivery;
  AddOrderEditStagedAction: AddOrderEditStagedAction;
  AddOrderItemShippingAddress: AddOrderItemShippingAddress;
  AddOrderParcelToDelivery: AddOrderParcelToDelivery;
  AddOrderPayment: AddOrderPayment;
  AddOrderReturnInfo: AddOrderReturnInfo;
  AddPaymentInterfaceInteraction: AddPaymentInterfaceInteraction;
  AddPaymentTransaction: AddPaymentTransaction;
  AddProductAsset: AddProductAsset;
  AddProductExternalImage: AddProductExternalImage;
  AddProductPrice: AddProductPrice;
  AddProductSelectionProduct: AddProductSelectionProduct;
  AddProductToCategory: AddProductToCategory;
  AddProductVariant: AddProductVariant;
  AddShippingMethodShippingRate: AddShippingMethodShippingRate;
  AddShippingMethodZone: AddShippingMethodZone;
  AddShoppingListLineItem: AddShoppingListLineItem;
  AddShoppingListTextLineItem: AddShoppingListTextLineItem;
  AddStagedOrderCustomLineItem: AddStagedOrderCustomLineItem;
  AddStagedOrderCustomLineItemOutput: AddStagedOrderCustomLineItemOutput;
  AddStagedOrderDelivery: AddStagedOrderDelivery;
  AddStagedOrderDeliveryOutput: AddStagedOrderDeliveryOutput;
  AddStagedOrderDiscountCode: AddStagedOrderDiscountCode;
  AddStagedOrderDiscountCodeOutput: AddStagedOrderDiscountCodeOutput;
  AddStagedOrderItemShippingAddress: AddStagedOrderItemShippingAddress;
  AddStagedOrderItemShippingAddressOutput: AddStagedOrderItemShippingAddressOutput;
  AddStagedOrderLineItem: AddStagedOrderLineItem;
  AddStagedOrderLineItemOutput: AddStagedOrderLineItemOutput;
  AddStagedOrderParcelToDelivery: AddStagedOrderParcelToDelivery;
  AddStagedOrderParcelToDeliveryOutput: AddStagedOrderParcelToDeliveryOutput;
  AddStagedOrderPayment: AddStagedOrderPayment;
  AddStagedOrderPaymentOutput: AddStagedOrderPaymentOutput;
  AddStagedOrderReturnInfo: AddStagedOrderReturnInfo;
  AddStagedOrderReturnInfoOutput: AddStagedOrderReturnInfoOutput;
  AddStagedOrderShoppingList: AddStagedOrderShoppingList;
  AddStagedOrderShoppingListOutput: AddStagedOrderShoppingListOutput;
  AddStandalonePriceTier: AddStandalonePriceTier;
  AddStateRoles: AddStateRoles;
  AddStoreCountry: AddStoreCountry;
  AddStoreDistributionChannel: AddStoreDistributionChannel;
  AddStoreProductSelection: AddStoreProductSelection;
  AddStoreSupplyChannel: AddStoreSupplyChannel;
  AddTypeEnumValue: AddTypeEnumValue;
  AddTypeFieldDefinition: AddTypeFieldDefinition;
  AddTypeLocalizedEnumValue: AddTypeLocalizedEnumValue;
  AddZoneLocation: AddZoneLocation;
  Address: Address;
  AddressDraft: AddressDraft;
  AddressInput: AddressInput;
  Applied: Applied;
  ApplyCartDeltaToCustomLineItemShippingDetailsTargets: ApplyCartDeltaToCustomLineItemShippingDetailsTargets;
  ApplyCartDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets;
  ApplyStagedChanges: ApplyStagedChanges;
  ApprovalFlow: ApprovalFlow;
  ApprovalFlowApproval: ApprovalFlowApproval;
  ApprovalFlowApproved: ApprovalFlowApproved;
  ApprovalFlowCompleted: ApprovalFlowCompleted;
  ApprovalFlowCreated: ApprovalFlowCreated;
  ApprovalFlowQueryResult: ApprovalFlowQueryResult;
  ApprovalFlowRejected: ApprovalFlowRejected;
  ApprovalFlowRejection: ApprovalFlowRejection;
  ApprovalFlowUpdateAction: ApprovalFlowUpdateAction;
  ApprovalRule: ApprovalRule;
  ApprovalRuleDraft: ApprovalRuleDraft;
  ApprovalRuleQueryResult: ApprovalRuleQueryResult;
  ApprovalRuleUpdateAction: ApprovalRuleUpdateAction;
  ApproveApprovalFlow: ApproveApprovalFlow;
  ApproverConjunction: ApproverConjunction;
  ApproverConjunctionDraft: ApproverConjunctionDraft;
  ApproverDisjunction: ApproverDisjunction;
  ApproverDisjunctionDraft: ApproverDisjunctionDraft;
  ApproverHierarchy: ApproverHierarchy;
  ApproverHierarchyDraft: ApproverHierarchyDraft;
  AsAssociate: AsAssociate;
  AsAssociateArgument: AsAssociateArgument;
  Asset: Asset;
  AssetDimensions: AssetDimensions;
  AssetDimensionsInput: AssetDimensionsInput;
  AssetDraftInput: AssetDraftInput;
  AssetSource: AssetSource;
  AssetSourceInput: AssetSourceInput;
  Associate: Associate;
  AssociateDraft: AssociateDraft;
  AssociateRole: AssociateRole;
  AssociateRoleAssignment: AssociateRoleAssignment;
  AssociateRoleAssignmentDraft: AssociateRoleAssignmentDraft;
  AssociateRoleBuyerAssignableChanged: AssociateRoleBuyerAssignableChanged;
  AssociateRoleCreated: AssociateRoleCreated;
  AssociateRoleDeleted: AssociateRoleDeleted;
  AssociateRoleDraft: AssociateRoleDraft;
  AssociateRoleNameSet: AssociateRoleNameSet;
  AssociateRolePermissionAdded: AssociateRolePermissionAdded;
  AssociateRolePermissionRemoved: AssociateRolePermissionRemoved;
  AssociateRolePermissionsSet: AssociateRolePermissionsSet;
  AssociateRoleQueryResult: AssociateRoleQueryResult;
  AssociateRoleUpdateAction: AssociateRoleUpdateAction;
  Attribute: ResolversInterfaceTypes<ResolversParentTypes>['Attribute'];
  AttributeDefinition: AttributeDefinition;
  AttributeDefinitionDraft: AttributeDefinitionDraft;
  AttributeDefinitionResult: AttributeDefinitionResult;
  AttributeDefinitionType: ResolversInterfaceTypes<ResolversParentTypes>['AttributeDefinitionType'];
  AttributeGroup: AttributeGroup;
  AttributeGroupDraft: AttributeGroupDraft;
  AttributeGroupLimitWithCurrent: AttributeGroupLimitWithCurrent;
  AttributeGroupLimitsProjection: AttributeGroupLimitsProjection;
  AttributeGroupQueryResult: AttributeGroupQueryResult;
  AttributeGroupUpdateAction: AttributeGroupUpdateAction;
  AttributeReference: AttributeReference;
  AttributeReferenceInput: AttributeReferenceInput;
  AttributeSetElementTypeDraft: AttributeSetElementTypeDraft;
  AttributeSetTypeDraft: AttributeSetTypeDraft;
  AttributeTypeDraft: AttributeTypeDraft;
  AuthorizationHeader: AuthorizationHeader;
  AuthorizationHeaderInput: AuthorizationHeaderInput;
  AzureFunctionsAuthentication: AzureFunctionsAuthentication;
  AzureFunctionsAuthenticationInput: AzureFunctionsAuthenticationInput;
  AzureServiceBusDestination: AzureServiceBusDestination;
  AzureServiceBusDestinationInput: AzureServiceBusDestinationInput;
  BaseMoney: ResolversInterfaceTypes<ResolversParentTypes>['BaseMoney'];
  BaseMoneyInput: BaseMoneyInput;
  BaseSearchKeywordInput: BaseSearchKeywordInput;
  BigDecimal: Scalars['BigDecimal']['output'];
  Boolean: Scalars['Boolean']['output'];
  BooleanAttribute: BooleanAttribute;
  BooleanAttributeDefinitionType: BooleanAttributeDefinitionType;
  BooleanField: BooleanField;
  BooleanType: BooleanType;
  BusinessUnit: BusinessUnit;
  BusinessUnitAddressAdded: BusinessUnitAddressAdded;
  BusinessUnitAddressChanged: BusinessUnitAddressChanged;
  BusinessUnitAddressRemoved: BusinessUnitAddressRemoved;
  BusinessUnitAssociateAdded: BusinessUnitAssociateAdded;
  BusinessUnitAssociateChanged: BusinessUnitAssociateChanged;
  BusinessUnitAssociateModeChanged: BusinessUnitAssociateModeChanged;
  BusinessUnitAssociateRemoved: BusinessUnitAssociateRemoved;
  BusinessUnitAssociatesSet: BusinessUnitAssociatesSet;
  BusinessUnitBillingAddressAdded: BusinessUnitBillingAddressAdded;
  BusinessUnitBillingAddressRemoved: BusinessUnitBillingAddressRemoved;
  BusinessUnitConfiguration: BusinessUnitConfiguration;
  BusinessUnitContactEmailSet: BusinessUnitContactEmailSet;
  BusinessUnitCreated: BusinessUnitCreated;
  BusinessUnitDefaultBillingAddressSet: BusinessUnitDefaultBillingAddressSet;
  BusinessUnitDefaultShippingAddressSet: BusinessUnitDefaultShippingAddressSet;
  BusinessUnitDeleted: BusinessUnitDeleted;
  BusinessUnitDraft: BusinessUnitDraft;
  BusinessUnitNameChanged: BusinessUnitNameChanged;
  BusinessUnitParentChanged: BusinessUnitParentChanged;
  BusinessUnitQueryResult: BusinessUnitQueryResult;
  BusinessUnitShippingAddressAdded: BusinessUnitShippingAddressAdded;
  BusinessUnitShippingAddressRemoved: BusinessUnitShippingAddressRemoved;
  BusinessUnitStatusChanged: BusinessUnitStatusChanged;
  BusinessUnitStoreAdded: BusinessUnitStoreAdded;
  BusinessUnitStoreModeChanged: BusinessUnitStoreModeChanged;
  BusinessUnitStoreRemoved: BusinessUnitStoreRemoved;
  BusinessUnitStoresSet: BusinessUnitStoresSet;
  BusinessUnitUpdateAction: BusinessUnitUpdateAction;
  CancelQuoteRequest: CancelQuoteRequest;
  Cart: Cart;
  CartClassificationInput: CartClassificationInput;
  CartClassificationType: CartClassificationType;
  CartCreated: CartCreated;
  CartDiscount: CartDiscount;
  CartDiscountDraft: CartDiscountDraft;
  CartDiscountLimitWithCurrent: CartDiscountLimitWithCurrent;
  CartDiscountLimitsProjection: CartDiscountLimitsProjection;
  CartDiscountQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['CartDiscountQueryInterface'];
  CartDiscountQueryResult: CartDiscountQueryResult;
  CartDiscountTarget: ResolversInterfaceTypes<ResolversParentTypes>['CartDiscountTarget'];
  CartDiscountTargetInput: CartDiscountTargetInput;
  CartDiscountUpdateAction: CartDiscountUpdateAction;
  CartDiscountValue: ResolversInterfaceTypes<ResolversParentTypes>['CartDiscountValue'];
  CartDiscountValueBaseMoneyInput: CartDiscountValueBaseMoneyInput;
  CartDiscountValueInput: CartDiscountValueInput;
  CartDraft: CartDraft;
  CartLimitWithCurrent: CartLimitWithCurrent;
  CartLimitsProjection: CartLimitsProjection;
  CartQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['CartQueryInterface'];
  CartQueryResult: CartQueryResult;
  CartScoreInput: CartScoreInput;
  CartScoreType: CartScoreType;
  CartUpdateAction: CartUpdateAction;
  CartValueInput: CartValueInput;
  CartValueType: CartValueType;
  CartsConfiguration: CartsConfiguration;
  CartsConfigurationInput: CartsConfigurationInput;
  Category: Category;
  CategoryCreated: CategoryCreated;
  CategoryDraft: CategoryDraft;
  CategoryLimitsProjection: CategoryLimitsProjection;
  CategoryOrderHint: CategoryOrderHint;
  CategoryOrderHintInput: CategoryOrderHintInput;
  CategoryOrderHintProductSearch: CategoryOrderHintProductSearch;
  CategoryQueryResult: CategoryQueryResult;
  CategorySearch: CategorySearch;
  CategorySearchResult: CategorySearchResult;
  CategorySlugChanged: CategorySlugChanged;
  CategoryUpdateAction: CategoryUpdateAction;
  ChangeAssociateRoleBuyerAssignable: ChangeAssociateRoleBuyerAssignable;
  ChangeAttributeGroupName: ChangeAttributeGroupName;
  ChangeBusinessUnitAddress: ChangeBusinessUnitAddress;
  ChangeBusinessUnitAssociate: ChangeBusinessUnitAssociate;
  ChangeBusinessUnitAssociateMode: ChangeBusinessUnitAssociateMode;
  ChangeBusinessUnitName: ChangeBusinessUnitName;
  ChangeBusinessUnitParentUnit: ChangeBusinessUnitParentUnit;
  ChangeBusinessUnitStatus: ChangeBusinessUnitStatus;
  ChangeCartCustomLineItemMoney: ChangeCartCustomLineItemMoney;
  ChangeCartCustomLineItemPriceMode: ChangeCartCustomLineItemPriceMode;
  ChangeCartCustomLineItemQuantity: ChangeCartCustomLineItemQuantity;
  ChangeCartDiscountCartPredicate: ChangeCartDiscountCartPredicate;
  ChangeCartDiscountIsActive: ChangeCartDiscountIsActive;
  ChangeCartDiscountName: ChangeCartDiscountName;
  ChangeCartDiscountRequiresDiscountCode: ChangeCartDiscountRequiresDiscountCode;
  ChangeCartDiscountSortOrder: ChangeCartDiscountSortOrder;
  ChangeCartDiscountStackingMode: ChangeCartDiscountStackingMode;
  ChangeCartDiscountTarget: ChangeCartDiscountTarget;
  ChangeCartDiscountValue: ChangeCartDiscountValue;
  ChangeCartLineItemQuantity: ChangeCartLineItemQuantity;
  ChangeCartTaxCalculationMode: ChangeCartTaxCalculationMode;
  ChangeCartTaxMode: ChangeCartTaxMode;
  ChangeCartTaxRoundingMode: ChangeCartTaxRoundingMode;
  ChangeCategoryAssetName: ChangeCategoryAssetName;
  ChangeCategoryAssetOrder: ChangeCategoryAssetOrder;
  ChangeCategoryName: ChangeCategoryName;
  ChangeCategoryOrderHint: ChangeCategoryOrderHint;
  ChangeCategoryParent: ChangeCategoryParent;
  ChangeCategorySlug: ChangeCategorySlug;
  ChangeChannelDescription: ChangeChannelDescription;
  ChangeChannelKey: ChangeChannelKey;
  ChangeChannelName: ChangeChannelName;
  ChangeCustomerAddress: ChangeCustomerAddress;
  ChangeCustomerEmail: ChangeCustomerEmail;
  ChangeCustomerGroupName: ChangeCustomerGroupName;
  ChangeDiscountCodeCartDiscounts: ChangeDiscountCodeCartDiscounts;
  ChangeDiscountCodeGroups: ChangeDiscountCodeGroups;
  ChangeDiscountCodeIsActive: ChangeDiscountCodeIsActive;
  ChangeExtensionDestination: ChangeExtensionDestination;
  ChangeExtensionTriggers: ChangeExtensionTriggers;
  ChangeInventoryEntryQuantity: ChangeInventoryEntryQuantity;
  ChangeMyBusinessUnitAddress: ChangeMyBusinessUnitAddress;
  ChangeMyBusinessUnitAssociate: ChangeMyBusinessUnitAssociate;
  ChangeMyBusinessUnitName: ChangeMyBusinessUnitName;
  ChangeMyBusinessUnitParentUnit: ChangeMyBusinessUnitParentUnit;
  ChangeMyCartTaxMode: ChangeMyCartTaxMode;
  ChangeMyQuoteMyQuoteState: ChangeMyQuoteMyQuoteState;
  ChangeOrderPaymentState: ChangeOrderPaymentState;
  ChangeOrderShipmentState: ChangeOrderShipmentState;
  ChangeOrderState: ChangeOrderState;
  ChangePaymentAmountPlanned: ChangePaymentAmountPlanned;
  ChangePaymentTransactionInteractionId: ChangePaymentTransactionInteractionId;
  ChangePaymentTransactionState: ChangePaymentTransactionState;
  ChangePaymentTransactionTimestamp: ChangePaymentTransactionTimestamp;
  ChangeProductAssetName: ChangeProductAssetName;
  ChangeProductAssetOrder: ChangeProductAssetOrder;
  ChangeProductDiscountIsActive: ChangeProductDiscountIsActive;
  ChangeProductDiscountName: ChangeProductDiscountName;
  ChangeProductDiscountPredicate: ChangeProductDiscountPredicate;
  ChangeProductDiscountSortOrder: ChangeProductDiscountSortOrder;
  ChangeProductDiscountValue: ChangeProductDiscountValue;
  ChangeProductImageLabel: ChangeProductImageLabel;
  ChangeProductMasterVariant: ChangeProductMasterVariant;
  ChangeProductName: ChangeProductName;
  ChangeProductPrice: ChangeProductPrice;
  ChangeProductSelectionName: ChangeProductSelectionName;
  ChangeProductSlug: ChangeProductSlug;
  ChangeProjectSettingsCartsConfiguration: ChangeProjectSettingsCartsConfiguration;
  ChangeProjectSettingsCountries: ChangeProjectSettingsCountries;
  ChangeProjectSettingsCountryTaxRateFallbackEnabled: ChangeProjectSettingsCountryTaxRateFallbackEnabled;
  ChangeProjectSettingsCurrencies: ChangeProjectSettingsCurrencies;
  ChangeProjectSettingsCustomerSearchStatus: ChangeProjectSettingsCustomerSearchStatus;
  ChangeProjectSettingsLanguages: ChangeProjectSettingsLanguages;
  ChangeProjectSettingsMessagesConfiguration: ChangeProjectSettingsMessagesConfiguration;
  ChangeProjectSettingsMessagesEnabled: ChangeProjectSettingsMessagesEnabled;
  ChangeProjectSettingsMyBusinessUnitStatusOnCreation: ChangeProjectSettingsMyBusinessUnitStatusOnCreation;
  ChangeProjectSettingsName: ChangeProjectSettingsName;
  ChangeProjectSettingsOrderSearchStatus: ChangeProjectSettingsOrderSearchStatus;
  ChangeProjectSettingsProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled;
  ChangeProjectSettingsShoppingListsConfiguration: ChangeProjectSettingsShoppingListsConfiguration;
  ChangeProjectSettingsStandalonePriceSearchIndexingEnabled: ChangeProjectSettingsStandalonePriceSearchIndexingEnabled;
  ChangeQuoteCustomer: ChangeQuoteCustomer;
  ChangeQuoteRequestCustomer: ChangeQuoteRequestCustomer;
  ChangeQuoteRequestState: ChangeQuoteRequestState;
  ChangeQuoteState: ChangeQuoteState;
  ChangeShippingMethodIsDefault: ChangeShippingMethodIsDefault;
  ChangeShippingMethodName: ChangeShippingMethodName;
  ChangeShippingMethodTaxCategory: ChangeShippingMethodTaxCategory;
  ChangeShoppingListLineItemQuantity: ChangeShoppingListLineItemQuantity;
  ChangeShoppingListLineItemsOrder: ChangeShoppingListLineItemsOrder;
  ChangeShoppingListName: ChangeShoppingListName;
  ChangeShoppingListTextLineItemName: ChangeShoppingListTextLineItemName;
  ChangeShoppingListTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity;
  ChangeShoppingListTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder;
  ChangeStagedOrderCustomLineItemMoney: ChangeStagedOrderCustomLineItemMoney;
  ChangeStagedOrderCustomLineItemMoneyOutput: ChangeStagedOrderCustomLineItemMoneyOutput;
  ChangeStagedOrderCustomLineItemQuantity: ChangeStagedOrderCustomLineItemQuantity;
  ChangeStagedOrderCustomLineItemQuantityOutput: ChangeStagedOrderCustomLineItemQuantityOutput;
  ChangeStagedOrderLineItemQuantity: ChangeStagedOrderLineItemQuantity;
  ChangeStagedOrderLineItemQuantityOutput: ChangeStagedOrderLineItemQuantityOutput;
  ChangeStagedOrderOrderState: ChangeStagedOrderOrderState;
  ChangeStagedOrderOrderStateOutput: ChangeStagedOrderOrderStateOutput;
  ChangeStagedOrderPaymentState: ChangeStagedOrderPaymentState;
  ChangeStagedOrderPaymentStateOutput: ChangeStagedOrderPaymentStateOutput;
  ChangeStagedOrderShipmentState: ChangeStagedOrderShipmentState;
  ChangeStagedOrderShipmentStateOutput: ChangeStagedOrderShipmentStateOutput;
  ChangeStagedOrderTaxCalculationMode: ChangeStagedOrderTaxCalculationMode;
  ChangeStagedOrderTaxCalculationModeOutput: ChangeStagedOrderTaxCalculationModeOutput;
  ChangeStagedOrderTaxMode: ChangeStagedOrderTaxMode;
  ChangeStagedOrderTaxModeOutput: ChangeStagedOrderTaxModeOutput;
  ChangeStagedOrderTaxRoundingMode: ChangeStagedOrderTaxRoundingMode;
  ChangeStagedOrderTaxRoundingModeOutput: ChangeStagedOrderTaxRoundingModeOutput;
  ChangeStagedQuoteState: ChangeStagedQuoteState;
  ChangeStandalonePriceActive: ChangeStandalonePriceActive;
  ChangeStandalonePriceValue: ChangeStandalonePriceValue;
  ChangeStateInitial: ChangeStateInitial;
  ChangeStateKey: ChangeStateKey;
  ChangeStateType: ChangeStateType;
  ChangeStoreProductSelectionActive: ChangeStoreProductSelectionActive;
  ChangeSubscription: ChangeSubscription;
  ChangeSubscriptionDestination: ChangeSubscriptionDestination;
  ChangeSubscriptionInput: ChangeSubscriptionInput;
  ChangeTypeEnumValueLabel: ChangeTypeEnumValueLabel;
  ChangeTypeEnumValueOrder: ChangeTypeEnumValueOrder;
  ChangeTypeFieldDefinitionOrder: ChangeTypeFieldDefinitionOrder;
  ChangeTypeInputHint: ChangeTypeInputHint;
  ChangeTypeKey: ChangeTypeKey;
  ChangeTypeLabel: ChangeTypeLabel;
  ChangeTypeLocalizedEnumValueLabel: ChangeTypeLocalizedEnumValueLabel;
  ChangeTypeLocalizedEnumValueOrder: ChangeTypeLocalizedEnumValueOrder;
  ChangeTypeName: ChangeTypeName;
  ChangeZoneName: ChangeZoneName;
  Channel: Channel;
  ChannelDraft: ChannelDraft;
  ChannelQueryResult: ChannelQueryResult;
  ChannelReferenceIdentifier: ChannelReferenceIdentifier;
  ChannelUpdateAction: ChannelUpdateAction;
  ClassificationShippingRateInput: ClassificationShippingRateInput;
  ClassificationShippingRateInputDraft: ClassificationShippingRateInputDraft;
  ClassificationShippingRateInputDraftOutput: ClassificationShippingRateInputDraftOutput;
  CloudEventsSubscriptionsFormat: CloudEventsSubscriptionsFormat;
  CloudEventsSubscriptionsFormatInput: CloudEventsSubscriptionsFormatInput;
  CommercetoolsSubscription: CommercetoolsSubscription;
  CommercetoolsSubscriptionQueryResult: CommercetoolsSubscriptionQueryResult;
  ConfluentCloudDestination: ConfluentCloudDestination;
  ConfluentCloudDestinationInput: ConfluentCloudDestinationInput;
  Country: Scalars['Country']['output'];
  CreateApiClient: CreateApiClient;
  CreateProductSelectionDraft: CreateProductSelectionDraft;
  CreateStandalonePrice: CreateStandalonePrice;
  CreateStore: CreateStore;
  CreateZone: CreateZone;
  Currency: Scalars['Currency']['output'];
  CustomField: ResolversInterfaceTypes<ResolversParentTypes>['CustomField'];
  CustomFieldInput: CustomFieldInput;
  CustomFieldsCommand: CustomFieldsCommand;
  CustomFieldsDraft: CustomFieldsDraft;
  CustomFieldsType: CustomFieldsType;
  CustomLineItem: CustomLineItem;
  CustomLineItemDraft: CustomLineItemDraft;
  CustomLineItemDraftOutput: CustomLineItemDraftOutput;
  CustomLineItemImportDraft: CustomLineItemImportDraft;
  CustomLineItemReturnItem: CustomLineItemReturnItem;
  CustomLineItemStateTransition: CustomLineItemStateTransition;
  CustomLineItemsTarget: CustomLineItemsTarget;
  CustomLineItemsTargetInput: CustomLineItemsTargetInput;
  CustomObject: CustomObject;
  CustomObjectDraft: CustomObjectDraft;
  CustomObjectLimitWithCurrent: CustomObjectLimitWithCurrent;
  CustomObjectLimitsProjection: CustomObjectLimitsProjection;
  CustomObjectQueryResult: CustomObjectQueryResult;
  CustomShippingDraft: CustomShippingDraft;
  CustomSuggestTokenizer: CustomSuggestTokenizer;
  CustomSuggestTokenizerInput: CustomSuggestTokenizerInput;
  CustomSuggestTokenizerProductSearch: CustomSuggestTokenizerProductSearch;
  Customer: Customer;
  CustomerActiveCartInterface: ResolversInterfaceTypes<ResolversParentTypes>['CustomerActiveCartInterface'];
  CustomerAddressAdded: CustomerAddressAdded;
  CustomerAddressChanged: CustomerAddressChanged;
  CustomerAddressRemoved: CustomerAddressRemoved;
  CustomerCompanyNameSet: CustomerCompanyNameSet;
  CustomerCreated: CustomerCreated;
  CustomerDateOfBirthSet: CustomerDateOfBirthSet;
  CustomerDeleted: CustomerDeleted;
  CustomerEmailChanged: CustomerEmailChanged;
  CustomerEmailToken: CustomerEmailToken;
  CustomerEmailTokenCreated: CustomerEmailTokenCreated;
  CustomerEmailVerified: CustomerEmailVerified;
  CustomerFirstNameSet: CustomerFirstNameSet;
  CustomerGroup: CustomerGroup;
  CustomerGroupDraft: CustomerGroupDraft;
  CustomerGroupLimitWithCurrent: CustomerGroupLimitWithCurrent;
  CustomerGroupLimitsProjection: CustomerGroupLimitsProjection;
  CustomerGroupQueryResult: CustomerGroupQueryResult;
  CustomerGroupReferenceIdentifier: CustomerGroupReferenceIdentifier;
  CustomerGroupSet: CustomerGroupSet;
  CustomerGroupUpdateAction: CustomerGroupUpdateAction;
  CustomerLastNameSet: CustomerLastNameSet;
  CustomerLimitWithCurrent: CustomerLimitWithCurrent;
  CustomerLimitsProjection: CustomerLimitsProjection;
  CustomerPasswordToken: CustomerPasswordToken;
  CustomerPasswordTokenCreated: CustomerPasswordTokenCreated;
  CustomerPasswordUpdated: CustomerPasswordUpdated;
  CustomerQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['CustomerQueryInterface'];
  CustomerQueryResult: CustomerQueryResult;
  CustomerSearchConfiguration: CustomerSearchConfiguration;
  CustomerSignInDraft: CustomerSignInDraft;
  CustomerSignInResult: CustomerSignInResult;
  CustomerSignMeInDraft: CustomerSignMeInDraft;
  CustomerSignMeUpDraft: CustomerSignMeUpDraft;
  CustomerSignUpDraft: CustomerSignUpDraft;
  CustomerTitleSet: CustomerTitleSet;
  CustomerUpdateAction: CustomerUpdateAction;
  Date: Scalars['Date']['output'];
  DateAttribute: DateAttribute;
  DateAttributeDefinitionType: DateAttributeDefinitionType;
  DateField: DateField;
  DateTime: Scalars['DateTime']['output'];
  DateTimeAttribute: DateTimeAttribute;
  DateTimeAttributeDefinitionType: DateTimeAttributeDefinitionType;
  DateTimeField: DateTimeField;
  DateTimeType: DateTimeType;
  DateType: DateType;
  Delivery: Delivery;
  DeliveryAdded: DeliveryAdded;
  DeliveryAddressSet: DeliveryAddressSet;
  DeliveryDraft: DeliveryDraft;
  DeliveryItem: DeliveryItem;
  DeliveryItemDraftType: DeliveryItemDraftType;
  DeliveryItemsUpdated: DeliveryItemsUpdated;
  DeliveryRemoved: DeliveryRemoved;
  Destination: ResolversInterfaceTypes<ResolversParentTypes>['Destination'];
  DestinationInput: DestinationInput;
  Dimensions: Dimensions;
  DimensionsInput: DimensionsInput;
  DimensionsProductSearch: DimensionsProductSearch;
  DirectDiscount: DirectDiscount;
  DirectDiscountDraft: DirectDiscountDraft;
  DirectDiscountDraftOutput: DirectDiscountDraftOutput;
  DiscountCode: DiscountCode;
  DiscountCodeDraft: DiscountCodeDraft;
  DiscountCodeInfo: DiscountCodeInfo;
  DiscountCodeQueryResult: DiscountCodeQueryResult;
  DiscountCodeUpdateAction: DiscountCodeUpdateAction;
  DiscountedLineItemPortion: DiscountedLineItemPortion;
  DiscountedLineItemPortionDraft: DiscountedLineItemPortionDraft;
  DiscountedLineItemPrice: DiscountedLineItemPrice;
  DiscountedLineItemPriceDraft: DiscountedLineItemPriceDraft;
  DiscountedLineItemPriceForQuantity: DiscountedLineItemPriceForQuantity;
  DiscountedProductPriceValue: DiscountedProductPriceValue;
  DiscountedProductPriceValueInput: DiscountedProductPriceValueInput;
  DiscountedProductSearchPriceValue: DiscountedProductSearchPriceValue;
  EnumAttribute: EnumAttribute;
  EnumAttributeDefinitionType: EnumAttributeDefinitionType;
  EnumField: EnumField;
  EnumType: EnumType;
  EnumTypeDraft: EnumTypeDraft;
  EnumValue: EnumValue;
  EnumValueInput: EnumValueInput;
  EventBridgeDestination: EventBridgeDestination;
  EventBridgeDestinationInput: EventBridgeDestinationInput;
  EventGridDestination: EventGridDestination;
  EventGridDestinationInput: EventGridDestinationInput;
  ExcludeProductSelectionProduct: ExcludeProductSelectionProduct;
  ExistsFilterInput: ExistsFilterInput;
  Extension: Extension;
  ExtensionDestination: ResolversInterfaceTypes<ResolversParentTypes>['ExtensionDestination'];
  ExtensionDestinationInput: ExtensionDestinationInput;
  ExtensionDraft: ExtensionDraft;
  ExtensionLimitsProjection: ExtensionLimitsProjection;
  ExtensionQueryResult: ExtensionQueryResult;
  ExtensionUpdateAction: ExtensionUpdateAction;
  ExternalDiscountValue: ExternalDiscountValue;
  ExternalDiscountValueInput: ExternalDiscountValueInput;
  ExternalLineItemTotalPrice: ExternalLineItemTotalPrice;
  ExternalLineItemTotalPriceDraft: ExternalLineItemTotalPriceDraft;
  ExternalOAuth: ExternalOAuth;
  ExternalOAuthDraft: ExternalOAuthDraft;
  ExternalTaxAmountDraft: ExternalTaxAmountDraft;
  ExternalTaxAmountDraftOutput: ExternalTaxAmountDraftOutput;
  ExternalTaxRateDraft: ExternalTaxRateDraft;
  ExternalTaxRateDraftOutput: ExternalTaxRateDraftOutput;
  FacetResult: ResolversInterfaceTypes<ResolversParentTypes>['FacetResult'];
  FacetResultValue: FacetResultValue;
  FieldDefinition: FieldDefinition;
  FieldDefinitionInput: FieldDefinitionInput;
  FieldType: ResolversInterfaceTypes<ResolversParentTypes>['FieldType'];
  FieldTypeEnumTypeDraft: FieldTypeEnumTypeDraft;
  FieldTypeInput: FieldTypeInput;
  FieldTypeLocalizedEnumTypeDraft: FieldTypeLocalizedEnumTypeDraft;
  FieldTypeReferenceTypeDraft: FieldTypeReferenceTypeDraft;
  FieldTypeSetElementTypeDraft: FieldTypeSetElementTypeDraft;
  FieldTypeSetTypeDraft: FieldTypeSetTypeDraft;
  FixedPriceDiscountValue: FixedPriceDiscountValue;
  FixedPriceDiscountValueInput: FixedPriceDiscountValueInput;
  Float: Scalars['Float']['output'];
  FreezeCart: FreezeCart;
  Geometry: ResolversInterfaceTypes<ResolversParentTypes>['Geometry'];
  GeometryInput: GeometryInput;
  GiftLineItemValue: GiftLineItemValue;
  GiftLineItemValueInput: GiftLineItemValueInput;
  GoogleCloudFunctionDestination: GoogleCloudFunctionDestination;
  GoogleCloudFunctionDestinationInput: GoogleCloudFunctionDestinationInput;
  GoogleCloudPubSubDestination: GoogleCloudPubSubDestination;
  GoogleCloudPubSubDestinationInput: GoogleCloudPubSubDestinationInput;
  HighPrecisionMoney: HighPrecisionMoney;
  HighPrecisionMoneyInput: HighPrecisionMoneyInput;
  HttpDestination: HttpDestination;
  HttpDestinationAuthentication: ResolversInterfaceTypes<ResolversParentTypes>['HttpDestinationAuthentication'];
  HttpDestinationAuthenticationInput: HttpDestinationAuthenticationInput;
  HttpDestinationInput: HttpDestinationInput;
  Image: Image;
  ImageInput: ImageInput;
  ImageProductSearch: ImageProductSearch;
  ImportOrderCustomLineItemState: ImportOrderCustomLineItemState;
  ImportOrderDraft: ImportOrderDraft;
  ImportOrderLineItemState: ImportOrderLineItemState;
  ImportStagedOrderCustomLineItemState: ImportStagedOrderCustomLineItemState;
  ImportStagedOrderCustomLineItemStateOutput: ImportStagedOrderCustomLineItemStateOutput;
  ImportStagedOrderLineItemState: ImportStagedOrderLineItemState;
  ImportStagedOrderLineItemStateOutput: ImportStagedOrderLineItemStateOutput;
  InStore: InStore;
  InStoreMe: InStoreMe;
  InheritedAssociate: InheritedAssociate;
  InheritedAssociateRoleAssignment: InheritedAssociateRoleAssignment;
  InheritedStore: InheritedStore;
  Initiator: Initiator;
  Int: Scalars['Int']['output'];
  InterfaceInteractionsRaw: InterfaceInteractionsRaw;
  InterfaceInteractionsRawResult: InterfaceInteractionsRawResult;
  InventoryEntry: InventoryEntry;
  InventoryEntryCreated: InventoryEntryCreated;
  InventoryEntryDeleted: InventoryEntryDeleted;
  InventoryEntryDraft: InventoryEntryDraft;
  InventoryEntryQuantitySet: InventoryEntryQuantitySet;
  InventoryEntryQueryResult: InventoryEntryQueryResult;
  InventoryEntryUpdateAction: InventoryEntryUpdateAction;
  ItemShippingDetails: ItemShippingDetails;
  ItemShippingDetailsDraft: ItemShippingDetailsDraft;
  ItemShippingDetailsDraftOutput: ItemShippingDetailsDraftOutput;
  ItemShippingDetailsDraftType: ItemShippingDetailsDraftType;
  ItemShippingTarget: ItemShippingTarget;
  ItemState: ItemState;
  ItemStateDraftType: ItemStateDraftType;
  Json: Scalars['Json']['output'];
  KeyReference: KeyReference;
  KeyReferenceInput: Scalars['KeyReferenceInput']['output'];
  Limit: Limit;
  LimitWithCurrent: ResolversInterfaceTypes<ResolversParentTypes>['LimitWithCurrent'];
  LineItem: LineItem;
  LineItemDraft: LineItemDraft;
  LineItemDraftOutput: LineItemDraftOutput;
  LineItemImportDraft: LineItemImportDraft;
  LineItemReturnItem: LineItemReturnItem;
  LineItemStateTransition: LineItemStateTransition;
  LineItemsTarget: LineItemsTarget;
  LineItemsTargetInput: LineItemsTargetInput;
  Locale: Scalars['Locale']['output'];
  LocalizableEnumAttributeDefinitionType: LocalizableEnumAttributeDefinitionType;
  LocalizableEnumTypeDraft: LocalizableEnumTypeDraft;
  LocalizableEnumValueType: LocalizableEnumValueType;
  LocalizableEnumValueTypeResult: LocalizableEnumValueTypeResult;
  LocalizableTextAttributeDefinitionType: LocalizableTextAttributeDefinitionType;
  LocalizedEnumAttribute: LocalizedEnumAttribute;
  LocalizedEnumField: LocalizedEnumField;
  LocalizedEnumType: LocalizedEnumType;
  LocalizedEnumValue: LocalizedEnumValue;
  LocalizedEnumValueDraft: LocalizedEnumValueDraft;
  LocalizedEnumValueInput: LocalizedEnumValueInput;
  LocalizedString: LocalizedString;
  LocalizedStringAttribute: LocalizedStringAttribute;
  LocalizedStringField: LocalizedStringField;
  LocalizedStringItemInputType: LocalizedStringItemInputType;
  LocalizedStringType: LocalizedStringType;
  LocalizedText: LocalizedText;
  Location: Location;
  Long: Scalars['Long']['output'];
  Me: Me;
  MeFieldInterface: ResolversInterfaceTypes<ResolversParentTypes>['MeFieldInterface'];
  MeQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['MeQueryInterface'];
  Message: Message;
  MessagePayload: ResolversInterfaceTypes<ResolversParentTypes>['MessagePayload'];
  MessageQueryResult: MessageQueryResult;
  MessageSubscription: MessageSubscription;
  MessageSubscriptionInput: MessageSubscriptionInput;
  MessagesConfiguration: MessagesConfiguration;
  MessagesConfigurationDraft: MessagesConfigurationDraft;
  MethodTaxRate: MethodTaxRate;
  MethodTaxedPrice: MethodTaxedPrice;
  MissingFilterInput: MissingFilterInput;
  Money: Money;
  MoneyAttribute: MoneyAttribute;
  MoneyAttributeDefinitionType: MoneyAttributeDefinitionType;
  MoneyDraft: MoneyDraft;
  MoneyField: MoneyField;
  MoneyInput: MoneyInput;
  MoneyType: MoneyType;
  MoveProductImageToPosition: MoveProductImageToPosition;
  MultiBuyCustomLineItemsTarget: MultiBuyCustomLineItemsTarget;
  MultiBuyCustomLineItemsTargetInput: MultiBuyCustomLineItemsTargetInput;
  MultiBuyLineItemsTarget: MultiBuyLineItemsTarget;
  MultiBuyLineItemsTargetInput: MultiBuyLineItemsTargetInput;
  Mutation: {};
  MyBusinessUnitDraft: MyBusinessUnitDraft;
  MyBusinessUnitUpdateAction: MyBusinessUnitUpdateAction;
  MyCartDraft: MyCartDraft;
  MyCartUpdateAction: MyCartUpdateAction;
  MyCustomerUpdateAction: MyCustomerUpdateAction;
  MyLineItemDraft: MyLineItemDraft;
  MyPayment: MyPayment;
  MyPaymentDraft: MyPaymentDraft;
  MyPaymentQueryResult: MyPaymentQueryResult;
  MyPaymentUpdateAction: MyPaymentUpdateAction;
  MyQuoteRequestDraft: MyQuoteRequestDraft;
  MyQuoteRequestUpdateAction: MyQuoteRequestUpdateAction;
  MyQuoteUpdateAction: MyQuoteUpdateAction;
  MyShoppingListDraft: MyShoppingListDraft;
  MyShoppingListUpdateAction: MyShoppingListUpdateAction;
  MyTransactionDraft: MyTransactionDraft;
  NestedAttributeDefinitionType: NestedAttributeDefinitionType;
  NotProcessed: NotProcessed;
  NotificationFormat: ResolversInterfaceTypes<ResolversParentTypes>['NotificationFormat'];
  NumberAttribute: NumberAttribute;
  NumberAttributeDefinitionType: NumberAttributeDefinitionType;
  NumberField: NumberField;
  NumberType: NumberType;
  Order: Order;
  OrderBillingAddressSet: OrderBillingAddressSet;
  OrderCartCommand: OrderCartCommand;
  OrderCreated: OrderCreated;
  OrderCustomFieldAdded: OrderCustomFieldAdded;
  OrderCustomFieldChanged: OrderCustomFieldChanged;
  OrderCustomFieldRemoved: OrderCustomFieldRemoved;
  OrderCustomLineItemAdded: OrderCustomLineItemAdded;
  OrderCustomLineItemDiscountSet: OrderCustomLineItemDiscountSet;
  OrderCustomLineItemQuantityChanged: OrderCustomLineItemQuantityChanged;
  OrderCustomLineItemRemoved: OrderCustomLineItemRemoved;
  OrderCustomTypeRemoved: OrderCustomTypeRemoved;
  OrderCustomTypeSet: OrderCustomTypeSet;
  OrderCustomerEmailSet: OrderCustomerEmailSet;
  OrderCustomerGroupSet: OrderCustomerGroupSet;
  OrderCustomerSet: OrderCustomerSet;
  OrderDeleted: OrderDeleted;
  OrderDiscountCodeAdded: OrderDiscountCodeAdded;
  OrderDiscountCodeRemoved: OrderDiscountCodeRemoved;
  OrderDiscountCodeStateSet: OrderDiscountCodeStateSet;
  OrderEdit: OrderEdit;
  OrderEditApplied: OrderEditApplied;
  OrderEditDraft: OrderEditDraft;
  OrderEditLimitWithCurrent: OrderEditLimitWithCurrent;
  OrderEditLimitsProjection: OrderEditLimitsProjection;
  OrderEditQueryResult: OrderEditQueryResult;
  OrderEditResult: ResolversInterfaceTypes<ResolversParentTypes>['OrderEditResult'];
  OrderEditUpdateAction: OrderEditUpdateAction;
  OrderExcerpt: OrderExcerpt;
  OrderImported: OrderImported;
  OrderLineItemAdded: OrderLineItemAdded;
  OrderLineItemDiscountSet: OrderLineItemDiscountSet;
  OrderLineItemDistributionChannelSet: OrderLineItemDistributionChannelSet;
  OrderLineItemRemoved: OrderLineItemRemoved;
  OrderMessagePayload: ResolversInterfaceTypes<ResolversParentTypes>['OrderMessagePayload'];
  OrderMyCartCommand: OrderMyCartCommand;
  OrderMyQuoteCommand: OrderMyQuoteCommand;
  OrderPaymentAdded: OrderPaymentAdded;
  OrderPaymentRemoved: OrderPaymentRemoved;
  OrderPaymentStateChanged: OrderPaymentStateChanged;
  OrderQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['OrderQueryInterface'];
  OrderQueryResult: OrderQueryResult;
  OrderQuoteCommand: OrderQuoteCommand;
  OrderReturnShipmentStateChanged: OrderReturnShipmentStateChanged;
  OrderSearchConfiguration: OrderSearchConfiguration;
  OrderShipmentStateChanged: OrderShipmentStateChanged;
  OrderShippingAddressSet: OrderShippingAddressSet;
  OrderShippingInfoSet: OrderShippingInfoSet;
  OrderShippingRateInputSet: OrderShippingRateInputSet;
  OrderStateChanged: OrderStateChanged;
  OrderStateTransition: OrderStateTransition;
  OrderStoreSet: OrderStoreSet;
  OrderUpdateAction: OrderUpdateAction;
  Parcel: Parcel;
  ParcelAddedToDelivery: ParcelAddedToDelivery;
  ParcelData: ParcelData;
  ParcelDataDraftType: ParcelDataDraftType;
  ParcelDraft: ParcelDraft;
  ParcelItemsUpdated: ParcelItemsUpdated;
  ParcelMeasurements: ParcelMeasurements;
  ParcelMeasurementsDraftType: ParcelMeasurementsDraftType;
  ParcelMeasurementsUpdated: ParcelMeasurementsUpdated;
  ParcelRemovedFromDelivery: ParcelRemovedFromDelivery;
  ParcelTrackingDataUpdated: ParcelTrackingDataUpdated;
  Payment: Payment;
  PaymentCreated: PaymentCreated;
  PaymentDraft: PaymentDraft;
  PaymentInfo: PaymentInfo;
  PaymentInteractionAdded: PaymentInteractionAdded;
  PaymentMethodInfo: PaymentMethodInfo;
  PaymentMethodInfoInput: PaymentMethodInfoInput;
  PaymentQueryResult: PaymentQueryResult;
  PaymentStatus: PaymentStatus;
  PaymentStatusInput: PaymentStatusInput;
  PaymentStatusInterfaceCodeSet: PaymentStatusInterfaceCodeSet;
  PaymentStatusStateTransition: PaymentStatusStateTransition;
  PaymentTransactionAdded: PaymentTransactionAdded;
  PaymentTransactionStateChanged: PaymentTransactionStateChanged;
  PaymentUpdateAction: PaymentUpdateAction;
  PlainEnumValue: PlainEnumValue;
  PlainEnumValueDraft: PlainEnumValueDraft;
  PlainEnumValueResult: PlainEnumValueResult;
  PlatformFormat: PlatformFormat;
  PlatformFormatInput: PlatformFormatInput;
  Point: Point;
  PreviewFailure: PreviewFailure;
  PreviewSuccess: PreviewSuccess;
  PriceFunction: PriceFunction;
  PriceFunctionDraft: PriceFunctionDraft;
  PriceSelectorInput: PriceSelectorInput;
  Product: Product;
  ProductAddedToCategory: ProductAddedToCategory;
  ProductAssignment: ProductAssignment;
  ProductAssignmentQueryResult: ProductAssignmentQueryResult;
  ProductAttributeInput: ProductAttributeInput;
  ProductCatalogData: ProductCatalogData;
  ProductCreated: ProductCreated;
  ProductData: ProductData;
  ProductDeleted: ProductDeleted;
  ProductDiscount: ProductDiscount;
  ProductDiscountDraft: ProductDiscountDraft;
  ProductDiscountLimitWithCurrent: ProductDiscountLimitWithCurrent;
  ProductDiscountLimitsProjection: ProductDiscountLimitsProjection;
  ProductDiscountQueryResult: ProductDiscountQueryResult;
  ProductDiscountUpdateAction: ProductDiscountUpdateAction;
  ProductDiscountValue: ResolversInterfaceTypes<ResolversParentTypes>['ProductDiscountValue'];
  ProductDiscountValueInput: ProductDiscountValueInput;
  ProductDraft: ProductDraft;
  ProductImageAdded: ProductImageAdded;
  ProductLimitsProjection: ProductLimitsProjection;
  ProductOfSelection: ProductOfSelection;
  ProductOfSelectionQueryResult: ProductOfSelectionQueryResult;
  ProductPrice: ProductPrice;
  ProductPriceAdded: ProductPriceAdded;
  ProductPriceChanged: ProductPriceChanged;
  ProductPriceDataInput: ProductPriceDataInput;
  ProductPriceDiscountUpdateMessagePayload: ProductPriceDiscountUpdateMessagePayload;
  ProductPriceDiscountsSet: ProductPriceDiscountsSet;
  ProductPriceExternalDiscountSet: ProductPriceExternalDiscountSet;
  ProductPriceKeySet: ProductPriceKeySet;
  ProductPriceModeSet: ProductPriceModeSet;
  ProductPriceRemoved: ProductPriceRemoved;
  ProductPriceSearch: ProductPriceSearch;
  ProductPriceTier: ProductPriceTier;
  ProductPriceTierInput: ProductPriceTierInput;
  ProductPricesSet: ProductPricesSet;
  ProductProjection: ProductProjection;
  ProductProjectionMessagePayload: ProductProjectionMessagePayload;
  ProductProjectionSearchResult: ProductProjectionSearchResult;
  ProductPublished: ProductPublished;
  ProductQueryResult: ProductQueryResult;
  ProductReferenceIdentifier: ProductReferenceIdentifier;
  ProductRemovedFromCategory: ProductRemovedFromCategory;
  ProductRevertedStagedChanges: ProductRevertedStagedChanges;
  ProductSearchPriceTier: ProductSearchPriceTier;
  ProductSearchVariant: ProductSearchVariant;
  ProductSearchVariantAvailabilitiesResult: ProductSearchVariantAvailabilitiesResult;
  ProductSearchVariantAvailability: ProductSearchVariantAvailability;
  ProductSearchVariantAvailabilityWithChannel: ProductSearchVariantAvailabilityWithChannel;
  ProductSearchVariantAvailabilityWithChannels: ProductSearchVariantAvailabilityWithChannels;
  ProductSelection: ProductSelection;
  ProductSelectionCreated: ProductSelectionCreated;
  ProductSelectionDeleted: ProductSelectionDeleted;
  ProductSelectionProductAdded: ProductSelectionProductAdded;
  ProductSelectionProductExcluded: ProductSelectionProductExcluded;
  ProductSelectionProductRemoved: ProductSelectionProductRemoved;
  ProductSelectionQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['ProductSelectionQueryInterface'];
  ProductSelectionQueryResult: ProductSelectionQueryResult;
  ProductSelectionSetting: ProductSelectionSetting;
  ProductSelectionSettingDraft: ProductSelectionSettingDraft;
  ProductSelectionSettingInActionInput: ProductSelectionSettingInActionInput;
  ProductSelectionUpdateAction: ProductSelectionUpdateAction;
  ProductSelectionVariantExclusionChanged: ProductSelectionVariantExclusionChanged;
  ProductSelectionVariantSelectionChanged: ProductSelectionVariantSelectionChanged;
  ProductSlugChanged: ProductSlugChanged;
  ProductStateTransition: ProductStateTransition;
  ProductTypeDefinition: ProductTypeDefinition;
  ProductTypeDefinitionQueryResult: ProductTypeDefinitionQueryResult;
  ProductTypeDraft: ProductTypeDraft;
  ProductTypeLimitWithCurrent: ProductTypeLimitWithCurrent;
  ProductTypeLimitsProjection: ProductTypeLimitsProjection;
  ProductTypeUpdateAction: ProductTypeUpdateAction;
  ProductUnpublished: ProductUnpublished;
  ProductUpdateAction: ProductUpdateAction;
  ProductVariant: ProductVariant;
  ProductVariantAdded: ProductVariantAdded;
  ProductVariantAvailabilitiesResult: ProductVariantAvailabilitiesResult;
  ProductVariantAvailability: ProductVariantAvailability;
  ProductVariantAvailabilityWithChannel: ProductVariantAvailabilityWithChannel;
  ProductVariantAvailabilityWithChannels: ProductVariantAvailabilityWithChannels;
  ProductVariantDeleted: ProductVariantDeleted;
  ProductVariantExclusion: ProductVariantExclusion;
  ProductVariantExclusionDraft: ProductVariantExclusionDraft;
  ProductVariantImportDraft: ProductVariantImportDraft;
  ProductVariantInput: ProductVariantInput;
  ProductVariantSelection: ResolversInterfaceTypes<ResolversParentTypes>['ProductVariantSelection'];
  ProductVariantSelectionDraft: ProductVariantSelectionDraft;
  ProductVariantSelectionIncludeAllExcept: ProductVariantSelectionIncludeAllExcept;
  ProductVariantSelectionIncludeOnly: ProductVariantSelectionIncludeOnly;
  ProjectCustomLimitsProjection: ProjectCustomLimitsProjection;
  ProjectProjection: ProjectProjection;
  ProjectSettingsUpdateAction: ProjectSettingsUpdateAction;
  PublishProduct: PublishProduct;
  PurchaseOrderNumberSet: PurchaseOrderNumberSet;
  Query: {};
  QueryLimitsProjection: QueryLimitsProjection;
  Quote: Quote;
  QuoteDraft: QuoteDraft;
  QuoteQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['QuoteQueryInterface'];
  QuoteQueryResult: QuoteQueryResult;
  QuoteRequest: QuoteRequest;
  QuoteRequestDraft: QuoteRequestDraft;
  QuoteRequestQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['QuoteRequestQueryInterface'];
  QuoteRequestQueryResult: QuoteRequestQueryResult;
  QuoteRequestUpdateAction: QuoteRequestUpdateAction;
  QuoteUpdateAction: QuoteUpdateAction;
  RangeCount: ResolversInterfaceTypes<ResolversParentTypes>['RangeCount'];
  RangeCountDouble: RangeCountDouble;
  RangeCountLong: RangeCountLong;
  RangeElementInput: RangeElementInput;
  RangeFacetInput: RangeFacetInput;
  RangeFacetResult: RangeFacetResult;
  RangeFilterInput: RangeFilterInput;
  RawCustomField: RawCustomField;
  RawProductAttribute: RawProductAttribute;
  RawProductSearchAttribute: RawProductSearchAttribute;
  RecalculateCart: RecalculateCart;
  RecalculateStagedOrder: RecalculateStagedOrder;
  RecalculateStagedOrderOutput: RecalculateStagedOrderOutput;
  Reference: Reference;
  ReferenceAttribute: ReferenceAttribute;
  ReferenceAttributeDefinitionType: ReferenceAttributeDefinitionType;
  ReferenceExpandable: ResolversInterfaceTypes<ResolversParentTypes>['ReferenceExpandable'];
  ReferenceField: ReferenceField;
  ReferenceId: ReferenceId;
  ReferenceInput: ReferenceInput;
  ReferenceType: ReferenceType;
  ReferenceTypeDefinitionDraft: ReferenceTypeDefinitionDraft;
  RefreshTokenLimitWithCurrent: RefreshTokenLimitWithCurrent;
  RefreshTokenLimitsProjection: RefreshTokenLimitsProjection;
  RejectApprovalFlow: RejectApprovalFlow;
  RelativeDiscountValue: RelativeDiscountValue;
  RelativeDiscountValueInput: RelativeDiscountValueInput;
  RemoveAssociateRolePermission: RemoveAssociateRolePermission;
  RemoveAttributeGroupAttribute: RemoveAttributeGroupAttribute;
  RemoveBusinessUnitAddress: RemoveBusinessUnitAddress;
  RemoveBusinessUnitAssociate: RemoveBusinessUnitAssociate;
  RemoveBusinessUnitBillingAddressId: RemoveBusinessUnitBillingAddressId;
  RemoveBusinessUnitShippingAddressId: RemoveBusinessUnitShippingAddressId;
  RemoveBusinessUnitStore: RemoveBusinessUnitStore;
  RemoveCartCustomLineItem: RemoveCartCustomLineItem;
  RemoveCartDiscountCode: RemoveCartDiscountCode;
  RemoveCartDiscountStore: RemoveCartDiscountStore;
  RemoveCartItemShippingAddress: RemoveCartItemShippingAddress;
  RemoveCartLineItem: RemoveCartLineItem;
  RemoveCartPayment: RemoveCartPayment;
  RemoveCartShippingMethod: RemoveCartShippingMethod;
  RemoveCategoryAsset: RemoveCategoryAsset;
  RemoveChannelRoles: RemoveChannelRoles;
  RemoveCustomerAddress: RemoveCustomerAddress;
  RemoveCustomerBillingAddressId: RemoveCustomerBillingAddressId;
  RemoveCustomerShippingAddressId: RemoveCustomerShippingAddressId;
  RemoveCustomerStore: RemoveCustomerStore;
  RemoveInventoryEntryQuantity: RemoveInventoryEntryQuantity;
  RemoveMyBusinessUnitAddress: RemoveMyBusinessUnitAddress;
  RemoveMyBusinessUnitAssociate: RemoveMyBusinessUnitAssociate;
  RemoveMyBusinessUnitBillingAddressId: RemoveMyBusinessUnitBillingAddressId;
  RemoveMyBusinessUnitShippingAddressId: RemoveMyBusinessUnitShippingAddressId;
  RemoveOrderDelivery: RemoveOrderDelivery;
  RemoveOrderItemShippingAddress: RemoveOrderItemShippingAddress;
  RemoveOrderParcelFromDelivery: RemoveOrderParcelFromDelivery;
  RemoveOrderPayment: RemoveOrderPayment;
  RemoveProductAsset: RemoveProductAsset;
  RemoveProductFromCategory: RemoveProductFromCategory;
  RemoveProductImage: RemoveProductImage;
  RemoveProductPrice: RemoveProductPrice;
  RemoveProductSelectionProduct: RemoveProductSelectionProduct;
  RemoveProductVariant: RemoveProductVariant;
  RemoveShippingMethodShippingRate: RemoveShippingMethodShippingRate;
  RemoveShippingMethodZone: RemoveShippingMethodZone;
  RemoveShoppingListLineItem: RemoveShoppingListLineItem;
  RemoveShoppingListTextLineItem: RemoveShoppingListTextLineItem;
  RemoveStagedChanges: RemoveStagedChanges;
  RemoveStagedOrderCustomLineItem: RemoveStagedOrderCustomLineItem;
  RemoveStagedOrderCustomLineItemOutput: RemoveStagedOrderCustomLineItemOutput;
  RemoveStagedOrderDelivery: RemoveStagedOrderDelivery;
  RemoveStagedOrderDeliveryOutput: RemoveStagedOrderDeliveryOutput;
  RemoveStagedOrderDiscountCode: RemoveStagedOrderDiscountCode;
  RemoveStagedOrderDiscountCodeOutput: RemoveStagedOrderDiscountCodeOutput;
  RemoveStagedOrderItemShippingAddress: RemoveStagedOrderItemShippingAddress;
  RemoveStagedOrderItemShippingAddressOutput: RemoveStagedOrderItemShippingAddressOutput;
  RemoveStagedOrderLineItem: RemoveStagedOrderLineItem;
  RemoveStagedOrderLineItemOutput: RemoveStagedOrderLineItemOutput;
  RemoveStagedOrderParcelFromDelivery: RemoveStagedOrderParcelFromDelivery;
  RemoveStagedOrderParcelFromDeliveryOutput: RemoveStagedOrderParcelFromDeliveryOutput;
  RemoveStagedOrderPayment: RemoveStagedOrderPayment;
  RemoveStagedOrderPaymentOutput: RemoveStagedOrderPaymentOutput;
  RemoveStandalonePriceTier: RemoveStandalonePriceTier;
  RemoveStateRoles: RemoveStateRoles;
  RemoveStoreCountry: RemoveStoreCountry;
  RemoveStoreDistributionChannel: RemoveStoreDistributionChannel;
  RemoveStoreProductSelection: RemoveStoreProductSelection;
  RemoveStoreSupplyChannel: RemoveStoreSupplyChannel;
  RemoveTypeFieldDefinition: RemoveTypeFieldDefinition;
  RemoveZoneLocation: RemoveZoneLocation;
  RequestQuoteRenegotiation: RequestQuoteRenegotiation;
  ResourceIdentifier: ResourceIdentifier;
  ResourceIdentifierInput: ResourceIdentifierInput;
  ReturnInfo: ReturnInfo;
  ReturnInfoAdded: ReturnInfoAdded;
  ReturnInfoDraftType: ReturnInfoDraftType;
  ReturnInfoDraftTypeOutput: ReturnInfoDraftTypeOutput;
  ReturnInfoSet: ReturnInfoSet;
  ReturnItem: ResolversInterfaceTypes<ResolversParentTypes>['ReturnItem'];
  ReturnItemDraftType: ReturnItemDraftType;
  ReturnItemDraftTypeOutput: ReturnItemDraftTypeOutput;
  RevertStagedChanges: RevertStagedChanges;
  RevertStagedVariantChanges: RevertStagedVariantChanges;
  Review: Review;
  ReviewCreated: ReviewCreated;
  ReviewDraft: ReviewDraft;
  ReviewQueryResult: ReviewQueryResult;
  ReviewRatingSet: ReviewRatingSet;
  ReviewRatingStatistics: ReviewRatingStatistics;
  ReviewStateTransition: ReviewStateTransition;
  ReviewTarget: ResolversInterfaceTypes<ResolversParentTypes>['ReviewTarget'];
  ReviewUpdateAction: ReviewUpdateAction;
  RuleApprover: RuleApprover;
  RuleApproverDraft: RuleApproverDraft;
  RuleInfo: RuleInfo;
  RuleRequester: RuleRequester;
  RuleRequesterDraft: RuleRequesterDraft;
  SNSDestination: SnsDestination;
  SNSDestinationInput: SnsDestinationInput;
  SQSDestination: SqsDestination;
  SQSDestinationInput: SqsDestinationInput;
  ScopedPrice: ScopedPrice;
  ScoreShippingRateInput: ScoreShippingRateInput;
  ScoreShippingRateInputDraft: ScoreShippingRateInputDraft;
  ScoreShippingRateInputDraftOutput: ScoreShippingRateInputDraftOutput;
  SearchFacetInput: SearchFacetInput;
  SearchFacetModelInput: SearchFacetModelInput;
  SearchFilter: Scalars['SearchFilter']['output'];
  SearchFilterInput: SearchFilterInput;
  SearchFilterModelInput: SearchFilterModelInput;
  SearchIndexingConfiguration: SearchIndexingConfiguration;
  SearchIndexingConfigurationValues: SearchIndexingConfigurationValues;
  SearchKeyword: SearchKeyword;
  SearchKeywordArgument: SearchKeywordArgument;
  SearchKeywordInput: SearchKeywordInput;
  SearchKeywordItemInput: SearchKeywordItemInput;
  SearchKeywordProductSearch: SearchKeywordProductSearch;
  SearchKeywords: SearchKeywords;
  SearchKeywordsProductSearch: SearchKeywordsProductSearch;
  SearchLimitsProjection: SearchLimitsProjection;
  SearchSort: Scalars['SearchSort']['output'];
  SelectionOfProduct: SelectionOfProduct;
  SelectionOfProductQueryResult: SelectionOfProductQueryResult;
  Set: Scalars['Set']['output'];
  SetApprovalRuleApprovers: SetApprovalRuleApprovers;
  SetApprovalRuleDescription: SetApprovalRuleDescription;
  SetApprovalRuleKey: SetApprovalRuleKey;
  SetApprovalRuleName: SetApprovalRuleName;
  SetApprovalRulePredicate: SetApprovalRulePredicate;
  SetApprovalRuleRequesters: SetApprovalRuleRequesters;
  SetApprovalRuleStatus: SetApprovalRuleStatus;
  SetAssociateRoleCustomField: SetAssociateRoleCustomField;
  SetAssociateRoleCustomType: SetAssociateRoleCustomType;
  SetAssociateRoleName: SetAssociateRoleName;
  SetAssociateRolePermissions: SetAssociateRolePermissions;
  SetAttributeDefinitionType: SetAttributeDefinitionType;
  SetAttributeGroupAttributes: SetAttributeGroupAttributes;
  SetAttributeGroupDescription: SetAttributeGroupDescription;
  SetAttributeGroupKey: SetAttributeGroupKey;
  SetBusinessUnitAddressCustomField: SetBusinessUnitAddressCustomField;
  SetBusinessUnitAddressCustomType: SetBusinessUnitAddressCustomType;
  SetBusinessUnitAssociates: SetBusinessUnitAssociates;
  SetBusinessUnitContactEmail: SetBusinessUnitContactEmail;
  SetBusinessUnitCustomField: SetBusinessUnitCustomField;
  SetBusinessUnitCustomType: SetBusinessUnitCustomType;
  SetBusinessUnitDefaultBillingAddress: SetBusinessUnitDefaultBillingAddress;
  SetBusinessUnitDefaultShippingAddress: SetBusinessUnitDefaultShippingAddress;
  SetBusinessUnitStoreMode: SetBusinessUnitStoreMode;
  SetBusinessUnitStores: SetBusinessUnitStores;
  SetCartAnonymousId: SetCartAnonymousId;
  SetCartBillingAddress: SetCartBillingAddress;
  SetCartBillingAddressCustomField: SetCartBillingAddressCustomField;
  SetCartBillingAddressCustomType: SetCartBillingAddressCustomType;
  SetCartBusinessUnit: SetCartBusinessUnit;
  SetCartCountry: SetCartCountry;
  SetCartCustomField: SetCartCustomField;
  SetCartCustomLineItemCustomField: SetCartCustomLineItemCustomField;
  SetCartCustomLineItemCustomType: SetCartCustomLineItemCustomType;
  SetCartCustomLineItemShippingDetails: SetCartCustomLineItemShippingDetails;
  SetCartCustomLineItemTaxAmount: SetCartCustomLineItemTaxAmount;
  SetCartCustomLineItemTaxRate: SetCartCustomLineItemTaxRate;
  SetCartCustomShippingMethod: SetCartCustomShippingMethod;
  SetCartCustomType: SetCartCustomType;
  SetCartCustomerEmail: SetCartCustomerEmail;
  SetCartCustomerGroup: SetCartCustomerGroup;
  SetCartCustomerId: SetCartCustomerId;
  SetCartDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification;
  SetCartDirectDiscounts: SetCartDirectDiscounts;
  SetCartDiscountCustomField: SetCartDiscountCustomField;
  SetCartDiscountCustomType: SetCartDiscountCustomType;
  SetCartDiscountDescription: SetCartDiscountDescription;
  SetCartDiscountKey: SetCartDiscountKey;
  SetCartDiscountStores: SetCartDiscountStores;
  SetCartDiscountValidFrom: SetCartDiscountValidFrom;
  SetCartDiscountValidFromAndUntil: SetCartDiscountValidFromAndUntil;
  SetCartDiscountValidUntil: SetCartDiscountValidUntil;
  SetCartItemShippingAddressCustomField: SetCartItemShippingAddressCustomField;
  SetCartItemShippingAddressCustomType: SetCartItemShippingAddressCustomType;
  SetCartKey: SetCartKey;
  SetCartLineItemCustomField: SetCartLineItemCustomField;
  SetCartLineItemCustomType: SetCartLineItemCustomType;
  SetCartLineItemDistributionChannel: SetCartLineItemDistributionChannel;
  SetCartLineItemInventoryMode: SetCartLineItemInventoryMode;
  SetCartLineItemPrice: SetCartLineItemPrice;
  SetCartLineItemShippingDetails: SetCartLineItemShippingDetails;
  SetCartLineItemSupplyChannel: SetCartLineItemSupplyChannel;
  SetCartLineItemTaxAmount: SetCartLineItemTaxAmount;
  SetCartLineItemTaxRate: SetCartLineItemTaxRate;
  SetCartLineItemTotalPrice: SetCartLineItemTotalPrice;
  SetCartLocale: SetCartLocale;
  SetCartShippingAddress: SetCartShippingAddress;
  SetCartShippingAddressCustomField: SetCartShippingAddressCustomField;
  SetCartShippingAddressCustomType: SetCartShippingAddressCustomType;
  SetCartShippingCustomField: SetCartShippingCustomField;
  SetCartShippingCustomType: SetCartShippingCustomType;
  SetCartShippingMethod: SetCartShippingMethod;
  SetCartShippingMethodTaxAmount: SetCartShippingMethodTaxAmount;
  SetCartShippingMethodTaxRate: SetCartShippingMethodTaxRate;
  SetCartShippingRateInput: SetCartShippingRateInput;
  SetCartTotalTax: SetCartTotalTax;
  SetCategoryAssetCustomField: SetCategoryAssetCustomField;
  SetCategoryAssetCustomType: SetCategoryAssetCustomType;
  SetCategoryAssetDescription: SetCategoryAssetDescription;
  SetCategoryAssetKey: SetCategoryAssetKey;
  SetCategoryAssetSources: SetCategoryAssetSources;
  SetCategoryAssetTags: SetCategoryAssetTags;
  SetCategoryCustomField: SetCategoryCustomField;
  SetCategoryCustomType: SetCategoryCustomType;
  SetCategoryDescription: SetCategoryDescription;
  SetCategoryExternalId: SetCategoryExternalId;
  SetCategoryKey: SetCategoryKey;
  SetCategoryMetaDescription: SetCategoryMetaDescription;
  SetCategoryMetaKeywords: SetCategoryMetaKeywords;
  SetCategoryMetaTitle: SetCategoryMetaTitle;
  SetChannelAddress: SetChannelAddress;
  SetChannelAddressCustomField: SetChannelAddressCustomField;
  SetChannelAddressCustomType: SetChannelAddressCustomType;
  SetChannelCustomField: SetChannelCustomField;
  SetChannelCustomType: SetChannelCustomType;
  SetChannelGeoLocation: SetChannelGeoLocation;
  SetChannelRoles: SetChannelRoles;
  SetCustomerAddressCustomField: SetCustomerAddressCustomField;
  SetCustomerAddressCustomType: SetCustomerAddressCustomType;
  SetCustomerAuthenticationMode: SetCustomerAuthenticationMode;
  SetCustomerCompanyName: SetCustomerCompanyName;
  SetCustomerCustomField: SetCustomerCustomField;
  SetCustomerCustomType: SetCustomerCustomType;
  SetCustomerDateOfBirth: SetCustomerDateOfBirth;
  SetCustomerDefaultBillingAddress: SetCustomerDefaultBillingAddress;
  SetCustomerDefaultShippingAddress: SetCustomerDefaultShippingAddress;
  SetCustomerExternalId: SetCustomerExternalId;
  SetCustomerFirstName: SetCustomerFirstName;
  SetCustomerGroup: SetCustomerGroup;
  SetCustomerGroupCustomField: SetCustomerGroupCustomField;
  SetCustomerGroupCustomType: SetCustomerGroupCustomType;
  SetCustomerGroupKey: SetCustomerGroupKey;
  SetCustomerKey: SetCustomerKey;
  SetCustomerLastName: SetCustomerLastName;
  SetCustomerLocale: SetCustomerLocale;
  SetCustomerMiddleName: SetCustomerMiddleName;
  SetCustomerNumber: SetCustomerNumber;
  SetCustomerSalutation: SetCustomerSalutation;
  SetCustomerStores: SetCustomerStores;
  SetCustomerTitle: SetCustomerTitle;
  SetCustomerVatId: SetCustomerVatId;
  SetDiscountCodeCartPredicate: SetDiscountCodeCartPredicate;
  SetDiscountCodeCustomField: SetDiscountCodeCustomField;
  SetDiscountCodeCustomType: SetDiscountCodeCustomType;
  SetDiscountCodeDescription: SetDiscountCodeDescription;
  SetDiscountCodeMaxApplications: SetDiscountCodeMaxApplications;
  SetDiscountCodeMaxApplicationsPerCustomer: SetDiscountCodeMaxApplicationsPerCustomer;
  SetDiscountCodeName: SetDiscountCodeName;
  SetDiscountCodeValidFrom: SetDiscountCodeValidFrom;
  SetDiscountCodeValidFromAndUntil: SetDiscountCodeValidFromAndUntil;
  SetDiscountCodeValidUntil: SetDiscountCodeValidUntil;
  SetExtensionKey: SetExtensionKey;
  SetExtensionTimeoutInMs: SetExtensionTimeoutInMs;
  SetInventoryEntryCustomField: SetInventoryEntryCustomField;
  SetInventoryEntryCustomType: SetInventoryEntryCustomType;
  SetInventoryEntryExpectedDelivery: SetInventoryEntryExpectedDelivery;
  SetInventoryEntryRestockableInDays: SetInventoryEntryRestockableInDays;
  SetInventoryEntrySupplyChannel: SetInventoryEntrySupplyChannel;
  SetMyBusinessUnitAddressCustomField: SetMyBusinessUnitAddressCustomField;
  SetMyBusinessUnitAddressCustomType: SetMyBusinessUnitAddressCustomType;
  SetMyBusinessUnitContactEmail: SetMyBusinessUnitContactEmail;
  SetMyBusinessUnitCustomField: SetMyBusinessUnitCustomField;
  SetMyBusinessUnitCustomType: SetMyBusinessUnitCustomType;
  SetMyBusinessUnitDefaultBillingAddress: SetMyBusinessUnitDefaultBillingAddress;
  SetMyBusinessUnitDefaultShippingAddress: SetMyBusinessUnitDefaultShippingAddress;
  SetMyCartShippingMethod: SetMyCartShippingMethod;
  SetMyQuoteRequestCustomField: SetMyQuoteRequestCustomField;
  SetMyQuoteRequestCustomType: SetMyQuoteRequestCustomType;
  SetOrderBillingAddress: SetOrderBillingAddress;
  SetOrderBillingAddressCustomField: SetOrderBillingAddressCustomField;
  SetOrderBillingAddressCustomType: SetOrderBillingAddressCustomType;
  SetOrderCustomField: SetOrderCustomField;
  SetOrderCustomLineItemCustomField: SetOrderCustomLineItemCustomField;
  SetOrderCustomLineItemCustomType: SetOrderCustomLineItemCustomType;
  SetOrderCustomLineItemShippingDetails: SetOrderCustomLineItemShippingDetails;
  SetOrderCustomType: SetOrderCustomType;
  SetOrderCustomerEmail: SetOrderCustomerEmail;
  SetOrderCustomerId: SetOrderCustomerId;
  SetOrderDeliveryAddress: SetOrderDeliveryAddress;
  SetOrderDeliveryAddressCustomField: SetOrderDeliveryAddressCustomField;
  SetOrderDeliveryAddressCustomType: SetOrderDeliveryAddressCustomType;
  SetOrderDeliveryCustomField: SetOrderDeliveryCustomField;
  SetOrderDeliveryCustomType: SetOrderDeliveryCustomType;
  SetOrderDeliveryItems: SetOrderDeliveryItems;
  SetOrderEditComment: SetOrderEditComment;
  SetOrderEditCustomField: SetOrderEditCustomField;
  SetOrderEditCustomType: SetOrderEditCustomType;
  SetOrderEditKey: SetOrderEditKey;
  SetOrderEditStagedActions: SetOrderEditStagedActions;
  SetOrderItemShippingAddressCustomField: SetOrderItemShippingAddressCustomField;
  SetOrderItemShippingAddressCustomType: SetOrderItemShippingAddressCustomType;
  SetOrderLineItemCustomField: SetOrderLineItemCustomField;
  SetOrderLineItemCustomType: SetOrderLineItemCustomType;
  SetOrderLineItemShippingDetails: SetOrderLineItemShippingDetails;
  SetOrderLocale: SetOrderLocale;
  SetOrderNumber: SetOrderNumber;
  SetOrderParcelCustomField: SetOrderParcelCustomField;
  SetOrderParcelCustomType: SetOrderParcelCustomType;
  SetOrderParcelItems: SetOrderParcelItems;
  SetOrderParcelMeasurements: SetOrderParcelMeasurements;
  SetOrderParcelTrackingData: SetOrderParcelTrackingData;
  SetOrderPurchaseOrderNumber: SetOrderPurchaseOrderNumber;
  SetOrderReturnInfo: SetOrderReturnInfo;
  SetOrderReturnItemCustomField: SetOrderReturnItemCustomField;
  SetOrderReturnItemCustomType: SetOrderReturnItemCustomType;
  SetOrderReturnPaymentState: SetOrderReturnPaymentState;
  SetOrderReturnShipmentState: SetOrderReturnShipmentState;
  SetOrderShippingAddress: SetOrderShippingAddress;
  SetOrderShippingAddressCustomField: SetOrderShippingAddressCustomField;
  SetOrderShippingAddressCustomType: SetOrderShippingAddressCustomType;
  SetOrderShippingCustomField: SetOrderShippingCustomField;
  SetOrderShippingCustomType: SetOrderShippingCustomType;
  SetOrderStore: SetOrderStore;
  SetPaymentAmountPaid: SetPaymentAmountPaid;
  SetPaymentAmountRefunded: SetPaymentAmountRefunded;
  SetPaymentAnonymousId: SetPaymentAnonymousId;
  SetPaymentAuthorization: SetPaymentAuthorization;
  SetPaymentCustomField: SetPaymentCustomField;
  SetPaymentCustomType: SetPaymentCustomType;
  SetPaymentCustomer: SetPaymentCustomer;
  SetPaymentExternalId: SetPaymentExternalId;
  SetPaymentInterfaceId: SetPaymentInterfaceId;
  SetPaymentKey: SetPaymentKey;
  SetPaymentMethodInfoInterface: SetPaymentMethodInfoInterface;
  SetPaymentMethodInfoMethod: SetPaymentMethodInfoMethod;
  SetPaymentMethodInfoName: SetPaymentMethodInfoName;
  SetPaymentStatusInterfaceCode: SetPaymentStatusInterfaceCode;
  SetPaymentStatusInterfaceText: SetPaymentStatusInterfaceText;
  SetPaymentTransactionCustomField: SetPaymentTransactionCustomField;
  SetPaymentTransactionCustomType: SetPaymentTransactionCustomType;
  SetProductAssetCustomField: SetProductAssetCustomField;
  SetProductAssetCustomType: SetProductAssetCustomType;
  SetProductAssetDescription: SetProductAssetDescription;
  SetProductAssetKey: SetProductAssetKey;
  SetProductAssetSources: SetProductAssetSources;
  SetProductAssetTags: SetProductAssetTags;
  SetProductAttribute: SetProductAttribute;
  SetProductAttributeInAllVariants: SetProductAttributeInAllVariants;
  SetProductCategoryOrderHint: SetProductCategoryOrderHint;
  SetProductDescription: SetProductDescription;
  SetProductDiscountDescription: SetProductDiscountDescription;
  SetProductDiscountKey: SetProductDiscountKey;
  SetProductDiscountValidFrom: SetProductDiscountValidFrom;
  SetProductDiscountValidFromAndUntil: SetProductDiscountValidFromAndUntil;
  SetProductDiscountValidUntil: SetProductDiscountValidUntil;
  SetProductDiscountedPrice: SetProductDiscountedPrice;
  SetProductImageLabel: SetProductImageLabel;
  SetProductKey: SetProductKey;
  SetProductMetaAttributes: SetProductMetaAttributes;
  SetProductMetaDescription: SetProductMetaDescription;
  SetProductMetaKeywords: SetProductMetaKeywords;
  SetProductMetaTitle: SetProductMetaTitle;
  SetProductPriceCustomField: SetProductPriceCustomField;
  SetProductPriceCustomType: SetProductPriceCustomType;
  SetProductPriceKey: SetProductPriceKey;
  SetProductPriceMode: SetProductPriceMode;
  SetProductPrices: SetProductPrices;
  SetProductSelectionCustomField: SetProductSelectionCustomField;
  SetProductSelectionCustomType: SetProductSelectionCustomType;
  SetProductSelectionKey: SetProductSelectionKey;
  SetProductSelectionVariantExclusion: SetProductSelectionVariantExclusion;
  SetProductSelectionVariantSelection: SetProductSelectionVariantSelection;
  SetProductSku: SetProductSku;
  SetProductTaxCategory: SetProductTaxCategory;
  SetProductVariantKey: SetProductVariantKey;
  SetProjectSettingsExternalOAuth: SetProjectSettingsExternalOAuth;
  SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation: SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation;
  SetProjectSettingsShippingRateInputType: SetProjectSettingsShippingRateInputType;
  SetQuoteCustomField: SetQuoteCustomField;
  SetQuoteCustomType: SetQuoteCustomType;
  SetQuoteRequestCustomField: SetQuoteRequestCustomField;
  SetQuoteRequestCustomType: SetQuoteRequestCustomType;
  SetReviewAuthorName: SetReviewAuthorName;
  SetReviewCustomField: SetReviewCustomField;
  SetReviewCustomType: SetReviewCustomType;
  SetReviewCustomer: SetReviewCustomer;
  SetReviewKey: SetReviewKey;
  SetReviewLocale: SetReviewLocale;
  SetReviewRating: SetReviewRating;
  SetReviewTarget: SetReviewTarget;
  SetReviewText: SetReviewText;
  SetReviewTitle: SetReviewTitle;
  SetSearchKeywords: SetSearchKeywords;
  SetShippingMethodCustomField: SetShippingMethodCustomField;
  SetShippingMethodCustomType: SetShippingMethodCustomType;
  SetShippingMethodDescription: SetShippingMethodDescription;
  SetShippingMethodKey: SetShippingMethodKey;
  SetShippingMethodLocalizedDescription: SetShippingMethodLocalizedDescription;
  SetShippingMethodLocalizedName: SetShippingMethodLocalizedName;
  SetShippingMethodPredicate: SetShippingMethodPredicate;
  SetShoppingListAnonymousId: SetShoppingListAnonymousId;
  SetShoppingListCustomField: SetShoppingListCustomField;
  SetShoppingListCustomType: SetShoppingListCustomType;
  SetShoppingListCustomer: SetShoppingListCustomer;
  SetShoppingListDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification;
  SetShoppingListDescription: SetShoppingListDescription;
  SetShoppingListKey: SetShoppingListKey;
  SetShoppingListLineItemCustomField: SetShoppingListLineItemCustomField;
  SetShoppingListLineItemCustomType: SetShoppingListLineItemCustomType;
  SetShoppingListSlug: SetShoppingListSlug;
  SetShoppingListStore: SetShoppingListStore;
  SetShoppingListTextLineItemCustomField: SetShoppingListTextLineItemCustomField;
  SetShoppingListTextLineItemCustomType: SetShoppingListTextLineItemCustomType;
  SetShoppingListTextLineItemDescription: SetShoppingListTextLineItemDescription;
  SetStagedOrderBillingAddress: SetStagedOrderBillingAddress;
  SetStagedOrderBillingAddressCustomField: SetStagedOrderBillingAddressCustomField;
  SetStagedOrderBillingAddressCustomFieldOutput: SetStagedOrderBillingAddressCustomFieldOutput;
  SetStagedOrderBillingAddressCustomType: SetStagedOrderBillingAddressCustomType;
  SetStagedOrderBillingAddressCustomTypeOutput: SetStagedOrderBillingAddressCustomTypeOutput;
  SetStagedOrderBillingAddressOutput: SetStagedOrderBillingAddressOutput;
  SetStagedOrderCountry: SetStagedOrderCountry;
  SetStagedOrderCountryOutput: SetStagedOrderCountryOutput;
  SetStagedOrderCustomField: SetStagedOrderCustomField;
  SetStagedOrderCustomFieldOutput: SetStagedOrderCustomFieldOutput;
  SetStagedOrderCustomLineItemCustomField: SetStagedOrderCustomLineItemCustomField;
  SetStagedOrderCustomLineItemCustomFieldOutput: SetStagedOrderCustomLineItemCustomFieldOutput;
  SetStagedOrderCustomLineItemCustomType: SetStagedOrderCustomLineItemCustomType;
  SetStagedOrderCustomLineItemCustomTypeOutput: SetStagedOrderCustomLineItemCustomTypeOutput;
  SetStagedOrderCustomLineItemShippingDetails: SetStagedOrderCustomLineItemShippingDetails;
  SetStagedOrderCustomLineItemShippingDetailsOutput: SetStagedOrderCustomLineItemShippingDetailsOutput;
  SetStagedOrderCustomLineItemTaxAmount: SetStagedOrderCustomLineItemTaxAmount;
  SetStagedOrderCustomLineItemTaxAmountOutput: SetStagedOrderCustomLineItemTaxAmountOutput;
  SetStagedOrderCustomLineItemTaxRate: SetStagedOrderCustomLineItemTaxRate;
  SetStagedOrderCustomLineItemTaxRateOutput: SetStagedOrderCustomLineItemTaxRateOutput;
  SetStagedOrderCustomShippingMethod: SetStagedOrderCustomShippingMethod;
  SetStagedOrderCustomShippingMethodOutput: SetStagedOrderCustomShippingMethodOutput;
  SetStagedOrderCustomType: SetStagedOrderCustomType;
  SetStagedOrderCustomTypeOutput: SetStagedOrderCustomTypeOutput;
  SetStagedOrderCustomerEmail: SetStagedOrderCustomerEmail;
  SetStagedOrderCustomerEmailOutput: SetStagedOrderCustomerEmailOutput;
  SetStagedOrderCustomerGroup: SetStagedOrderCustomerGroup;
  SetStagedOrderCustomerGroupOutput: SetStagedOrderCustomerGroupOutput;
  SetStagedOrderCustomerId: SetStagedOrderCustomerId;
  SetStagedOrderCustomerIdOutput: SetStagedOrderCustomerIdOutput;
  SetStagedOrderDeliveryAddress: SetStagedOrderDeliveryAddress;
  SetStagedOrderDeliveryAddressCustomField: SetStagedOrderDeliveryAddressCustomField;
  SetStagedOrderDeliveryAddressCustomFieldOutput: SetStagedOrderDeliveryAddressCustomFieldOutput;
  SetStagedOrderDeliveryAddressCustomType: SetStagedOrderDeliveryAddressCustomType;
  SetStagedOrderDeliveryAddressCustomTypeOutput: SetStagedOrderDeliveryAddressCustomTypeOutput;
  SetStagedOrderDeliveryAddressOutput: SetStagedOrderDeliveryAddressOutput;
  SetStagedOrderDeliveryCustomField: SetStagedOrderDeliveryCustomField;
  SetStagedOrderDeliveryCustomFieldOutput: SetStagedOrderDeliveryCustomFieldOutput;
  SetStagedOrderDeliveryCustomType: SetStagedOrderDeliveryCustomType;
  SetStagedOrderDeliveryCustomTypeOutput: SetStagedOrderDeliveryCustomTypeOutput;
  SetStagedOrderDeliveryItems: SetStagedOrderDeliveryItems;
  SetStagedOrderDeliveryItemsOutput: SetStagedOrderDeliveryItemsOutput;
  SetStagedOrderDirectDiscounts: SetStagedOrderDirectDiscounts;
  SetStagedOrderDirectDiscountsOutput: SetStagedOrderDirectDiscountsOutput;
  SetStagedOrderItemShippingAddressCustomField: SetStagedOrderItemShippingAddressCustomField;
  SetStagedOrderItemShippingAddressCustomFieldOutput: SetStagedOrderItemShippingAddressCustomFieldOutput;
  SetStagedOrderItemShippingAddressCustomType: SetStagedOrderItemShippingAddressCustomType;
  SetStagedOrderItemShippingAddressCustomTypeOutput: SetStagedOrderItemShippingAddressCustomTypeOutput;
  SetStagedOrderLineItemCustomField: SetStagedOrderLineItemCustomField;
  SetStagedOrderLineItemCustomFieldOutput: SetStagedOrderLineItemCustomFieldOutput;
  SetStagedOrderLineItemCustomType: SetStagedOrderLineItemCustomType;
  SetStagedOrderLineItemCustomTypeOutput: SetStagedOrderLineItemCustomTypeOutput;
  SetStagedOrderLineItemDistributionChannel: SetStagedOrderLineItemDistributionChannel;
  SetStagedOrderLineItemDistributionChannelOutput: SetStagedOrderLineItemDistributionChannelOutput;
  SetStagedOrderLineItemPrice: SetStagedOrderLineItemPrice;
  SetStagedOrderLineItemPriceOutput: SetStagedOrderLineItemPriceOutput;
  SetStagedOrderLineItemShippingDetails: SetStagedOrderLineItemShippingDetails;
  SetStagedOrderLineItemShippingDetailsOutput: SetStagedOrderLineItemShippingDetailsOutput;
  SetStagedOrderLineItemTaxAmount: SetStagedOrderLineItemTaxAmount;
  SetStagedOrderLineItemTaxAmountOutput: SetStagedOrderLineItemTaxAmountOutput;
  SetStagedOrderLineItemTaxRate: SetStagedOrderLineItemTaxRate;
  SetStagedOrderLineItemTaxRateOutput: SetStagedOrderLineItemTaxRateOutput;
  SetStagedOrderLineItemTotalPrice: SetStagedOrderLineItemTotalPrice;
  SetStagedOrderLineItemTotalPriceOutput: SetStagedOrderLineItemTotalPriceOutput;
  SetStagedOrderLocale: SetStagedOrderLocale;
  SetStagedOrderLocaleOutput: SetStagedOrderLocaleOutput;
  SetStagedOrderOrderNumber: SetStagedOrderOrderNumber;
  SetStagedOrderOrderNumberOutput: SetStagedOrderOrderNumberOutput;
  SetStagedOrderOrderTotalTax: SetStagedOrderOrderTotalTax;
  SetStagedOrderOrderTotalTaxOutput: SetStagedOrderOrderTotalTaxOutput;
  SetStagedOrderParcelCustomField: SetStagedOrderParcelCustomField;
  SetStagedOrderParcelCustomFieldOutput: SetStagedOrderParcelCustomFieldOutput;
  SetStagedOrderParcelCustomType: SetStagedOrderParcelCustomType;
  SetStagedOrderParcelCustomTypeOutput: SetStagedOrderParcelCustomTypeOutput;
  SetStagedOrderParcelItems: SetStagedOrderParcelItems;
  SetStagedOrderParcelItemsOutput: SetStagedOrderParcelItemsOutput;
  SetStagedOrderParcelMeasurements: SetStagedOrderParcelMeasurements;
  SetStagedOrderParcelMeasurementsOutput: SetStagedOrderParcelMeasurementsOutput;
  SetStagedOrderParcelTrackingData: SetStagedOrderParcelTrackingData;
  SetStagedOrderParcelTrackingDataOutput: SetStagedOrderParcelTrackingDataOutput;
  SetStagedOrderPurchaseOrderNumber: SetStagedOrderPurchaseOrderNumber;
  SetStagedOrderPurchaseOrderNumberOutput: SetStagedOrderPurchaseOrderNumberOutput;
  SetStagedOrderReturnInfo: SetStagedOrderReturnInfo;
  SetStagedOrderReturnInfoOutput: SetStagedOrderReturnInfoOutput;
  SetStagedOrderReturnItemCustomField: SetStagedOrderReturnItemCustomField;
  SetStagedOrderReturnItemCustomFieldOutput: SetStagedOrderReturnItemCustomFieldOutput;
  SetStagedOrderReturnItemCustomType: SetStagedOrderReturnItemCustomType;
  SetStagedOrderReturnItemCustomTypeOutput: SetStagedOrderReturnItemCustomTypeOutput;
  SetStagedOrderReturnPaymentState: SetStagedOrderReturnPaymentState;
  SetStagedOrderReturnPaymentStateOutput: SetStagedOrderReturnPaymentStateOutput;
  SetStagedOrderReturnShipmentState: SetStagedOrderReturnShipmentState;
  SetStagedOrderReturnShipmentStateOutput: SetStagedOrderReturnShipmentStateOutput;
  SetStagedOrderShippingAddress: SetStagedOrderShippingAddress;
  SetStagedOrderShippingAddressAndCustomShippingMethod: SetStagedOrderShippingAddressAndCustomShippingMethod;
  SetStagedOrderShippingAddressAndCustomShippingMethodOutput: SetStagedOrderShippingAddressAndCustomShippingMethodOutput;
  SetStagedOrderShippingAddressAndShippingMethod: SetStagedOrderShippingAddressAndShippingMethod;
  SetStagedOrderShippingAddressAndShippingMethodOutput: SetStagedOrderShippingAddressAndShippingMethodOutput;
  SetStagedOrderShippingAddressCustomField: SetStagedOrderShippingAddressCustomField;
  SetStagedOrderShippingAddressCustomFieldOutput: SetStagedOrderShippingAddressCustomFieldOutput;
  SetStagedOrderShippingAddressCustomType: SetStagedOrderShippingAddressCustomType;
  SetStagedOrderShippingAddressCustomTypeOutput: SetStagedOrderShippingAddressCustomTypeOutput;
  SetStagedOrderShippingAddressOutput: SetStagedOrderShippingAddressOutput;
  SetStagedOrderShippingCustomField: SetStagedOrderShippingCustomField;
  SetStagedOrderShippingCustomFieldOutput: SetStagedOrderShippingCustomFieldOutput;
  SetStagedOrderShippingCustomType: SetStagedOrderShippingCustomType;
  SetStagedOrderShippingCustomTypeOutput: SetStagedOrderShippingCustomTypeOutput;
  SetStagedOrderShippingMethod: SetStagedOrderShippingMethod;
  SetStagedOrderShippingMethodOutput: SetStagedOrderShippingMethodOutput;
  SetStagedOrderShippingMethodTaxAmount: SetStagedOrderShippingMethodTaxAmount;
  SetStagedOrderShippingMethodTaxAmountOutput: SetStagedOrderShippingMethodTaxAmountOutput;
  SetStagedOrderShippingMethodTaxRate: SetStagedOrderShippingMethodTaxRate;
  SetStagedOrderShippingMethodTaxRateOutput: SetStagedOrderShippingMethodTaxRateOutput;
  SetStagedOrderShippingRateInput: SetStagedOrderShippingRateInput;
  SetStagedOrderShippingRateInputOutput: SetStagedOrderShippingRateInputOutput;
  SetStagedOrderStore: SetStagedOrderStore;
  SetStagedOrderStoreOutput: SetStagedOrderStoreOutput;
  SetStagedQuoteCustomField: SetStagedQuoteCustomField;
  SetStagedQuoteCustomType: SetStagedQuoteCustomType;
  SetStagedQuoteSellerComment: SetStagedQuoteSellerComment;
  SetStagedQuoteValidTo: SetStagedQuoteValidTo;
  SetStandalonePriceCustomFields: SetStandalonePriceCustomFields;
  SetStandalonePriceDiscountedPrice: SetStandalonePriceDiscountedPrice;
  SetStandalonePriceKey: SetStandalonePriceKey;
  SetStandalonePriceTiers: SetStandalonePriceTiers;
  SetStandalonePriceValidFrom: SetStandalonePriceValidFrom;
  SetStandalonePriceValidFromAndUntil: SetStandalonePriceValidFromAndUntil;
  SetStandalonePriceValidUntil: SetStandalonePriceValidUntil;
  SetStateDescription: SetStateDescription;
  SetStateName: SetStateName;
  SetStateRoles: SetStateRoles;
  SetStateTransitions: SetStateTransitions;
  SetStoreCountries: SetStoreCountries;
  SetStoreCustomField: SetStoreCustomField;
  SetStoreCustomType: SetStoreCustomType;
  SetStoreDistributionChannels: SetStoreDistributionChannels;
  SetStoreLanguages: SetStoreLanguages;
  SetStoreName: SetStoreName;
  SetStoreProductSelections: SetStoreProductSelections;
  SetStoreSupplyChannels: SetStoreSupplyChannels;
  SetSubscriptionChanges: SetSubscriptionChanges;
  SetSubscriptionKey: SetSubscriptionKey;
  SetSubscriptionMessages: SetSubscriptionMessages;
  SetTaxCategoryKey: SetTaxCategoryKey;
  SetType: SetType;
  SetTypeDescription: SetTypeDescription;
  SetZoneDescription: SetZoneDescription;
  SetZoneKey: SetZoneKey;
  Shipping: Shipping;
  ShippingDraft: ShippingDraft;
  ShippingInfo: ShippingInfo;
  ShippingInfoImportDraft: ShippingInfoImportDraft;
  ShippingMethod: ShippingMethod;
  ShippingMethodDraft: ShippingMethodDraft;
  ShippingMethodLimitWithCurrent: ShippingMethodLimitWithCurrent;
  ShippingMethodLimitsProjection: ShippingMethodLimitsProjection;
  ShippingMethodQueryResult: ShippingMethodQueryResult;
  ShippingMethodUpdateAction: ShippingMethodUpdateAction;
  ShippingMethodsByCartInterface: ResolversInterfaceTypes<ResolversParentTypes>['ShippingMethodsByCartInterface'];
  ShippingRate: ShippingRate;
  ShippingRateCartClassificationPriceTier: ShippingRateCartClassificationPriceTier;
  ShippingRateCartScorePriceTier: ShippingRateCartScorePriceTier;
  ShippingRateCartValuePriceTier: ShippingRateCartValuePriceTier;
  ShippingRateDraft: ShippingRateDraft;
  ShippingRateInput: ResolversInterfaceTypes<ResolversParentTypes>['ShippingRateInput'];
  ShippingRateInputDraft: ShippingRateInputDraft;
  ShippingRateInputDraftOutput: ResolversInterfaceTypes<ResolversParentTypes>['ShippingRateInputDraftOutput'];
  ShippingRateInputLocalizedEnumValue: ShippingRateInputLocalizedEnumValue;
  ShippingRateInputType: ResolversInterfaceTypes<ResolversParentTypes>['ShippingRateInputType'];
  ShippingRateInputTypeInput: ShippingRateInputTypeInput;
  ShippingRatePriceTier: ResolversInterfaceTypes<ResolversParentTypes>['ShippingRatePriceTier'];
  ShippingRatePriceTierCartClassificationDraft: ShippingRatePriceTierCartClassificationDraft;
  ShippingRatePriceTierCartScoreDraft: ShippingRatePriceTierCartScoreDraft;
  ShippingRatePriceTierCartValueDraft: ShippingRatePriceTierCartValueDraft;
  ShippingRatePriceTierDraft: ShippingRatePriceTierDraft;
  ShippingTarget: ShippingTarget;
  ShippingTargetDraft: ShippingTargetDraft;
  ShippingTargetDraftType: ShippingTargetDraftType;
  ShippingTargetInput: ShippingTargetInput;
  ShoppingList: ShoppingList;
  ShoppingListDraft: ShoppingListDraft;
  ShoppingListLimitWithCurrent: ShoppingListLimitWithCurrent;
  ShoppingListLimitsProjection: ShoppingListLimitsProjection;
  ShoppingListLineItem: ShoppingListLineItem;
  ShoppingListLineItemDraft: ShoppingListLineItemDraft;
  ShoppingListQueryInterface: ResolversInterfaceTypes<ResolversParentTypes>['ShoppingListQueryInterface'];
  ShoppingListQueryResult: ShoppingListQueryResult;
  ShoppingListUpdateAction: ShoppingListUpdateAction;
  ShoppingListsConfiguration: ShoppingListsConfiguration;
  ShoppingListsConfigurationInput: ShoppingListsConfigurationInput;
  SignUpInMyBusinessUnitDraft: SignUpInMyBusinessUnitDraft;
  SimpleAttributeTypeDraft: SimpleAttributeTypeDraft;
  SimpleFieldTypeDraft: SimpleFieldTypeDraft;
  StagedOrderUpdateAction: StagedOrderUpdateAction;
  StagedOrderUpdateActionOutput: ResolversInterfaceTypes<ResolversParentTypes>['StagedOrderUpdateActionOutput'];
  StagedPriceDraft: StagedPriceDraft;
  StagedQuote: StagedQuote;
  StagedQuoteDraft: StagedQuoteDraft;
  StagedQuoteQueryResult: StagedQuoteQueryResult;
  StagedQuoteUpdateAction: StagedQuoteUpdateAction;
  StagedStandalonePrice: StagedStandalonePrice;
  StandalonePrice: StandalonePrice;
  StandalonePriceActiveChanged: StandalonePriceActiveChanged;
  StandalonePriceCreated: StandalonePriceCreated;
  StandalonePriceDeleted: StandalonePriceDeleted;
  StandalonePriceDiscountSet: StandalonePriceDiscountSet;
  StandalonePriceExpiresAtSet: StandalonePriceExpiresAtSet;
  StandalonePriceExternalDiscountSet: StandalonePriceExternalDiscountSet;
  StandalonePriceKeySet: StandalonePriceKeySet;
  StandalonePriceQueryResult: StandalonePriceQueryResult;
  StandalonePriceStagedChangesApplied: StandalonePriceStagedChangesApplied;
  StandalonePriceStagedChangesRemoved: StandalonePriceStagedChangesRemoved;
  StandalonePriceTierAdded: StandalonePriceTierAdded;
  StandalonePriceTierRemoved: StandalonePriceTierRemoved;
  StandalonePriceTiersSet: StandalonePriceTiersSet;
  StandalonePriceUpdateAction: StandalonePriceUpdateAction;
  StandalonePriceValidFromAndUntilSet: StandalonePriceValidFromAndUntilSet;
  StandalonePriceValidFromSet: StandalonePriceValidFromSet;
  StandalonePriceValidUntilSet: StandalonePriceValidUntilSet;
  StandalonePriceValueChanged: StandalonePriceValueChanged;
  State: State;
  StateDraft: StateDraft;
  StateQueryResult: StateQueryResult;
  StateUpdateAction: StateUpdateAction;
  Store: Store;
  StoreCountriesChanged: StoreCountriesChanged;
  StoreCountry: StoreCountry;
  StoreCountryInput: StoreCountryInput;
  StoreCreated: StoreCreated;
  StoreDeleted: StoreDeleted;
  StoreDistributionChannelsChanged: StoreDistributionChannelsChanged;
  StoreLanguagesChanged: StoreLanguagesChanged;
  StoreLimitWithCurrent: StoreLimitWithCurrent;
  StoreLimitsProjection: StoreLimitsProjection;
  StoreNameSet: StoreNameSet;
  StoreProductSelectionsChanged: StoreProductSelectionsChanged;
  StoreQueryResult: StoreQueryResult;
  StoreSupplyChannelsChanged: StoreSupplyChannelsChanged;
  StoreUpdateAction: StoreUpdateAction;
  String: Scalars['String']['output'];
  StringAttribute: StringAttribute;
  StringField: StringField;
  StringType: StringType;
  SubRate: SubRate;
  SubRateDraft: SubRateDraft;
  SubscriptionDraft: SubscriptionDraft;
  SubscriptionFormatInput: SubscriptionFormatInput;
  SubscriptionUpdateAction: SubscriptionUpdateAction;
  SubscriptionsLimitsProjection: SubscriptionsLimitsProjection;
  SuggestResult: SuggestResult;
  SuggestResultEntry: SuggestResultEntry;
  SuggestTokenizer: ResolversInterfaceTypes<ResolversParentTypes>['SuggestTokenizer'];
  SuggestTokenizerProductSearch: ResolversInterfaceTypes<ResolversParentTypes>['SuggestTokenizerProductSearch'];
  Suggestion: Suggestion;
  SyncInfo: SyncInfo;
  TargetReferenceInput: TargetReferenceInput;
  TaxCategory: TaxCategory;
  TaxCategoryAddTaxRate: TaxCategoryAddTaxRate;
  TaxCategoryChangeName: TaxCategoryChangeName;
  TaxCategoryDraft: TaxCategoryDraft;
  TaxCategoryLimitWithCurrent: TaxCategoryLimitWithCurrent;
  TaxCategoryLimitsProjection: TaxCategoryLimitsProjection;
  TaxCategoryQueryResult: TaxCategoryQueryResult;
  TaxCategoryRemoveTaxRate: TaxCategoryRemoveTaxRate;
  TaxCategoryReplaceTaxRate: TaxCategoryReplaceTaxRate;
  TaxCategorySetDescription: TaxCategorySetDescription;
  TaxCategoryUpdateAction: TaxCategoryUpdateAction;
  TaxPortion: TaxPortion;
  TaxPortionDraft: TaxPortionDraft;
  TaxRate: TaxRate;
  TaxRateDraft: TaxRateDraft;
  TaxRateInput: TaxRateInput;
  TaxedItemPrice: TaxedItemPrice;
  TaxedPrice: TaxedPrice;
  TaxedPriceDraft: TaxedPriceDraft;
  TermCount: TermCount;
  TermsFacetInput: TermsFacetInput;
  TermsFacetResult: TermsFacetResult;
  TextAttributeDefinitionType: TextAttributeDefinitionType;
  TextLineItem: TextLineItem;
  TextLineItemDraft: TextLineItemDraft;
  Time: Scalars['Time']['output'];
  TimeAttribute: TimeAttribute;
  TimeAttributeDefinitionType: TimeAttributeDefinitionType;
  TimeField: TimeField;
  TimeType: TimeType;
  TrackingData: TrackingData;
  TrackingDataDraftType: TrackingDataDraftType;
  Transaction: Transaction;
  TransactionDraft: TransactionDraft;
  TransitionOrderCustomLineItemState: TransitionOrderCustomLineItemState;
  TransitionOrderLineItemState: TransitionOrderLineItemState;
  TransitionOrderState: TransitionOrderState;
  TransitionPaymentState: TransitionPaymentState;
  TransitionProductState: TransitionProductState;
  TransitionQuoteRequestState: TransitionQuoteRequestState;
  TransitionQuoteState: TransitionQuoteState;
  TransitionReviewState: TransitionReviewState;
  TransitionStagedOrderCustomLineItemState: TransitionStagedOrderCustomLineItemState;
  TransitionStagedOrderCustomLineItemStateOutput: TransitionStagedOrderCustomLineItemStateOutput;
  TransitionStagedOrderLineItemState: TransitionStagedOrderLineItemState;
  TransitionStagedOrderLineItemStateOutput: TransitionStagedOrderLineItemStateOutput;
  TransitionStagedOrderState: TransitionStagedOrderState;
  TransitionStagedOrderStateOutput: TransitionStagedOrderStateOutput;
  TransitionStagedQuoteState: TransitionStagedQuoteState;
  TreeFilterInput: TreeFilterInput;
  Trigger: Trigger;
  TriggerInput: TriggerInput;
  TypeDefinition: TypeDefinition;
  TypeDefinitionDraft: TypeDefinitionDraft;
  TypeDefinitionQueryResult: TypeDefinitionQueryResult;
  TypeUpdateAction: TypeUpdateAction;
  UnfreezeCart: UnfreezeCart;
  UnpublishProduct: UnpublishProduct;
  UpdateCartItemShippingAddress: UpdateCartItemShippingAddress;
  UpdateOrderItemShippingAddress: UpdateOrderItemShippingAddress;
  UpdateOrderSyncInfo: UpdateOrderSyncInfo;
  UpdateStagedOrderItemShippingAddress: UpdateStagedOrderItemShippingAddress;
  UpdateStagedOrderItemShippingAddressOutput: UpdateStagedOrderItemShippingAddressOutput;
  UpdateStagedOrderSyncInfo: UpdateStagedOrderSyncInfo;
  UpdateStagedOrderSyncInfoOutput: UpdateStagedOrderSyncInfoOutput;
  UserProvidedIdentifiers: UserProvidedIdentifiers;
  ValueFacetResult: ValueFacetResult;
  ValueFilterInput: ValueFilterInput;
  Versioned: ResolversInterfaceTypes<ResolversParentTypes>['Versioned'];
  WhitespaceSuggestTokenizer: WhitespaceSuggestTokenizer;
  WhitespaceSuggestTokenizerInput: WhitespaceSuggestTokenizerInput;
  WhitespaceSuggestTokenizerProductSearch: WhitespaceSuggestTokenizerProductSearch;
  YearMonth: Scalars['YearMonth']['output'];
  Zone: Zone;
  ZoneLimitWithCurrent: ZoneLimitWithCurrent;
  ZoneLimitsProjection: ZoneLimitsProjection;
  ZoneLocation: ZoneLocation;
  ZoneQueryResult: ZoneQueryResult;
  ZoneRate: ZoneRate;
  ZoneRateDraft: ZoneRateDraft;
  ZoneUpdateAction: ZoneUpdateAction;
  addAttributeDefinition: AddAttributeDefinition;
  addLocalizedEnumValue: AddLocalizedEnumValue;
  addPlainEnumValue: AddPlainEnumValue;
  changeAttributeName: ChangeAttributeName;
  changeAttributeOrder: ChangeAttributeOrder;
  changeAttributeOrderByName: ChangeAttributeOrderByName;
  changeDescription: ChangeDescription;
  changeEnumKey: ChangeEnumKey;
  changeInputHint: ChangeInputHint;
  changeIsSearchable: ChangeIsSearchable;
  changeLabel: ChangeLabel;
  changeLocalizedEnumValueLabel: ChangeLocalizedEnumValueLabel;
  changeLocalizedEnumValueOrder: ChangeLocalizedEnumValueOrder;
  changeName: ChangeName;
  changePlainEnumValueLabel: ChangePlainEnumValueLabel;
  changePlainEnumValueOrder: ChangePlainEnumValueOrder;
  removeAttributeDefinition: RemoveAttributeDefinition;
  removeEnumValues: RemoveEnumValues;
  setInputTip: SetInputTip;
  setKey: SetKey;
};

export type ApiClientWithSecretResolvers<ContextType = any, ParentType extends ResolversParentTypes['APIClientWithSecret'] = ResolversParentTypes['APIClientWithSecret']> = {
  accessTokenValiditySeconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deleteAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastUsedAt?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refreshTokenValiditySeconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  secret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApiClientWithoutSecretResolvers<ContextType = any, ParentType extends ResolversParentTypes['APIClientWithoutSecret'] = ResolversParentTypes['APIClientWithoutSecret']> = {
  accessTokenValiditySeconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  deleteAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastUsedAt?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  refreshTokenValiditySeconds?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApiClientWithoutSecretQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['APIClientWithoutSecretQueryResult'] = ResolversParentTypes['APIClientWithoutSecretQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['APIClientWithoutSecret']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AwsLambdaDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AWSLambdaDestination'] = ResolversParentTypes['AWSLambdaDestination']> = {
  accessKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  accessSecret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  arn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AbsoluteDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['AbsoluteDiscountValue'] = ResolversParentTypes['AbsoluteDiscountValue']> = {
  money?: Resolver<Array<ResolversTypes['Money']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActiveCartInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActiveCartInterface'] = ResolversParentTypes['ActiveCartInterface']> = {
  __resolveType: TypeResolveFn<'InStoreMe' | 'Me', ParentType, ContextType>;
  activeCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
};

export type AddStagedOrderCustomLineItemOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderCustomLineItemOutput'] = ResolversParentTypes['AddStagedOrderCustomLineItemOutput']> = {
  draft?: Resolver<ResolversTypes['CustomLineItemDraftOutput'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderDeliveryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderDeliveryOutput'] = ResolversParentTypes['AddStagedOrderDeliveryOutput']> = {
  address?: Resolver<Maybe<ResolversTypes['AddressDraft']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  parcels?: Resolver<Array<ResolversTypes['ParcelData']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderDiscountCodeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderDiscountCodeOutput'] = ResolversParentTypes['AddStagedOrderDiscountCodeOutput']> = {
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validateDuplicates?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderItemShippingAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderItemShippingAddressOutput'] = ResolversParentTypes['AddStagedOrderItemShippingAddressOutput']> = {
  address?: Resolver<ResolversTypes['AddressDraft'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderLineItemOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderLineItemOutput'] = ResolversParentTypes['AddStagedOrderLineItemOutput']> = {
  draft?: Resolver<ResolversTypes['LineItemDraftOutput'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderParcelToDeliveryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderParcelToDeliveryOutput'] = ResolversParentTypes['AddStagedOrderParcelToDeliveryOutput']> = {
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  measurements?: Resolver<Maybe<ResolversTypes['ParcelMeasurements']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingData?: Resolver<Maybe<ResolversTypes['TrackingData']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderPaymentOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderPaymentOutput'] = ResolversParentTypes['AddStagedOrderPaymentOutput']> = {
  paymentResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderReturnInfoOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderReturnInfoOutput'] = ResolversParentTypes['AddStagedOrderReturnInfoOutput']> = {
  items?: Resolver<Array<ResolversTypes['ReturnItemDraftTypeOutput']>, ParentType, ContextType>;
  returnDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  returnTrackingId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddStagedOrderShoppingListOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddStagedOrderShoppingListOutput'] = ResolversParentTypes['AddStagedOrderShoppingListOutput']> = {
  distributionChannelResId?: Resolver<Maybe<ResolversTypes['ChannelReferenceIdentifier']>, ParentType, ContextType>;
  shoppingListResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  supplyChannelResId?: Resolver<Maybe<ResolversTypes['ChannelReferenceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressResolvers<ContextType = any, ParentType extends ResolversParentTypes['Address'] = ResolversParentTypes['Address']> = {
  additionalAddressInfo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalStreetInfo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apartment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  building?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  department?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mobile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pOBox?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  salutation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  streetName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  streetNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressDraftResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressDraft'] = ResolversParentTypes['AddressDraft']> = {
  additionalAddressInfo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  additionalStreetInfo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  apartment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  building?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  company?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  department?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fax?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mobile?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  pOBox?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  salutation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  streetName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  streetNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppliedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Applied'] = ResolversParentTypes['Applied']> = {
  appliedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  excerptAfterEdit?: Resolver<ResolversTypes['OrderExcerpt'], ParentType, ContextType>;
  excerptBeforeEdit?: Resolver<ResolversTypes['OrderExcerpt'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlow'] = ResolversParentTypes['ApprovalFlow']> = {
  approvals?: Resolver<Array<ResolversTypes['ApprovalFlowApproval']>, ParentType, ContextType>;
  businessUnit?: Resolver<ResolversTypes['BusinessUnit'], ParentType, ContextType>;
  businessUnitRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  rejection?: Resolver<Maybe<ResolversTypes['ApprovalFlowRejection']>, ParentType, ContextType>;
  rules?: Resolver<Array<ResolversTypes['ApprovalRule']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowApprovalResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowApproval'] = ResolversParentTypes['ApprovalFlowApproval']> = {
  approvedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  approver?: Resolver<ResolversTypes['Associate'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowApprovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowApproved'] = ResolversParentTypes['ApprovalFlowApproved']> = {
  associateId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  immediatePendingApprovers?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingApprovers?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  ruleInfos?: Resolver<Array<ResolversTypes['RuleInfo']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowCompletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowCompleted'] = ResolversParentTypes['ApprovalFlowCompleted']> = {
  orderId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowCreated'] = ResolversParentTypes['ApprovalFlowCreated']> = {
  immediatePendingApprovers?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pendingApprovers?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  ruleInfos?: Resolver<Array<ResolversTypes['RuleInfo']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowQueryResult'] = ResolversParentTypes['ApprovalFlowQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ApprovalFlow']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowRejectedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowRejected'] = ResolversParentTypes['ApprovalFlowRejected']> = {
  associateId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  ruleInfos?: Resolver<Array<ResolversTypes['RuleInfo']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalFlowRejectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalFlowRejection'] = ResolversParentTypes['ApprovalFlowRejection']> = {
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rejectedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  rejecter?: Resolver<ResolversTypes['Associate'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalRuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalRule'] = ResolversParentTypes['ApprovalRule']> = {
  approvers?: Resolver<ResolversTypes['ApproverHierarchy'], ParentType, ContextType>;
  businessUnit?: Resolver<ResolversTypes['BusinessUnit'], ParentType, ContextType>;
  businessUnitRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requesters?: Resolver<Array<ResolversTypes['RuleRequester']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ApprovalRuleStatus'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApprovalRuleQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApprovalRuleQueryResult'] = ResolversParentTypes['ApprovalRuleQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ApprovalRule']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApproverConjunctionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApproverConjunction'] = ResolversParentTypes['ApproverConjunction']> = {
  and?: Resolver<Array<ResolversTypes['ApproverDisjunction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApproverDisjunctionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApproverDisjunction'] = ResolversParentTypes['ApproverDisjunction']> = {
  or?: Resolver<Array<ResolversTypes['RuleApprover']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApproverHierarchyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApproverHierarchy'] = ResolversParentTypes['ApproverHierarchy']> = {
  tiers?: Resolver<Array<ResolversTypes['ApproverConjunction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AsAssociateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AsAssociate'] = ResolversParentTypes['AsAssociate']> = {
  approvalFlow?: Resolver<Maybe<ResolversTypes['ApprovalFlow']>, ParentType, ContextType, RequireFields<AsAssociateApprovalFlowArgs, 'id'>>;
  approvalFlows?: Resolver<ResolversTypes['ApprovalFlowQueryResult'], ParentType, ContextType, Partial<AsAssociateApprovalFlowsArgs>>;
  approvalRule?: Resolver<Maybe<ResolversTypes['ApprovalRule']>, ParentType, ContextType, Partial<AsAssociateApprovalRuleArgs>>;
  approvalRules?: Resolver<ResolversTypes['ApprovalRuleQueryResult'], ParentType, ContextType, Partial<AsAssociateApprovalRulesArgs>>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, Partial<AsAssociateBusinessUnitArgs>>;
  businessUnits?: Resolver<ResolversTypes['BusinessUnitQueryResult'], ParentType, ContextType, Partial<AsAssociateBusinessUnitsArgs>>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<AsAssociateCartArgs, 'id'>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<AsAssociateCartsArgs>>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<AsAssociateOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<AsAssociateOrdersArgs>>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, Partial<AsAssociateQuoteArgs>>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, Partial<AsAssociateQuoteRequestArgs>>;
  quoteRequests?: Resolver<ResolversTypes['QuoteRequestQueryResult'], ParentType, ContextType, Partial<AsAssociateQuoteRequestsArgs>>;
  quotes?: Resolver<ResolversTypes['QuoteQueryResult'], ParentType, ContextType, Partial<AsAssociateQuotesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetResolvers<ContextType = any, ParentType extends ResolversParentTypes['Asset'] = ResolversParentTypes['Asset']> = {
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AssetDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AssetNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  sources?: Resolver<Array<ResolversTypes['AssetSource']>, ParentType, ContextType>;
  tags?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetDimensionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetDimensions'] = ResolversParentTypes['AssetDimensions']> = {
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssetSourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetSource'] = ResolversParentTypes['AssetSource']> = {
  contentType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dimensions?: Resolver<Maybe<ResolversTypes['AssetDimensions']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateResolvers<ContextType = any, ParentType extends ResolversParentTypes['Associate'] = ResolversParentTypes['Associate']> = {
  associateRoleAssignments?: Resolver<Array<ResolversTypes['AssociateRoleAssignment']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['SimpleAssociateRole']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRole'] = ResolversParentTypes['AssociateRole']> = {
  buyerAssignable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['Permission']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleAssignment'] = ResolversParentTypes['AssociateRoleAssignment']> = {
  associateRole?: Resolver<ResolversTypes['AssociateRole'], ParentType, ContextType>;
  associateRoleRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  inheritance?: Resolver<ResolversTypes['AssociateInheritanceMode'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleBuyerAssignableChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleBuyerAssignableChanged'] = ResolversParentTypes['AssociateRoleBuyerAssignableChanged']> = {
  buyerAssignable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleCreated'] = ResolversParentTypes['AssociateRoleCreated']> = {
  associateRole?: Resolver<ResolversTypes['AssociateRole'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleDeleted'] = ResolversParentTypes['AssociateRoleDeleted']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleNameSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleNameSet'] = ResolversParentTypes['AssociateRoleNameSet']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRolePermissionAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRolePermissionAdded'] = ResolversParentTypes['AssociateRolePermissionAdded']> = {
  permission?: Resolver<ResolversTypes['Permission'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRolePermissionRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRolePermissionRemoved'] = ResolversParentTypes['AssociateRolePermissionRemoved']> = {
  permission?: Resolver<ResolversTypes['Permission'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRolePermissionsSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRolePermissionsSet'] = ResolversParentTypes['AssociateRolePermissionsSet']> = {
  permissions?: Resolver<Maybe<Array<ResolversTypes['Permission']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssociateRoleQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociateRoleQueryResult'] = ResolversParentTypes['AssociateRoleQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['AssociateRole']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attribute'] = ResolversParentTypes['Attribute']> = {
  __resolveType: TypeResolveFn<'BooleanAttribute' | 'DateAttribute' | 'DateTimeAttribute' | 'EnumAttribute' | 'LocalizedEnumAttribute' | 'LocalizedStringAttribute' | 'MoneyAttribute' | 'NumberAttribute' | 'ReferenceAttribute' | 'StringAttribute' | 'TimeAttribute', ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type AttributeDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeDefinition'] = ResolversParentTypes['AttributeDefinition']> = {
  attributeConstraint?: Resolver<ResolversTypes['AttributeConstraint'], ParentType, ContextType>;
  inputHint?: Resolver<ResolversTypes['TextInputHint'], ParentType, ContextType>;
  inputTip?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AttributeDefinitionInputTipArgs>>;
  inputTipAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  isRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isSearchable?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AttributeDefinitionLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['AttributeDefinitionType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeDefinitionResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeDefinitionResult'] = ResolversParentTypes['AttributeDefinitionResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['AttributeDefinition']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeDefinitionType'] = ResolversParentTypes['AttributeDefinitionType']> = {
  __resolveType: TypeResolveFn<'BooleanAttributeDefinitionType' | 'DateAttributeDefinitionType' | 'DateTimeAttributeDefinitionType' | 'EnumAttributeDefinitionType' | 'LocalizableEnumAttributeDefinitionType' | 'LocalizableTextAttributeDefinitionType' | 'MoneyAttributeDefinitionType' | 'NestedAttributeDefinitionType' | 'NumberAttributeDefinitionType' | 'ReferenceAttributeDefinitionType' | 'SetAttributeDefinitionType' | 'TextAttributeDefinitionType' | 'TimeAttributeDefinitionType', ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type AttributeGroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeGroup'] = ResolversParentTypes['AttributeGroup']> = {
  attributes?: Resolver<Array<ResolversTypes['AttributeReference']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AttributeGroupDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<AttributeGroupNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeGroupLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeGroupLimitWithCurrent'] = ResolversParentTypes['AttributeGroupLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeGroupLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeGroupLimitsProjection'] = ResolversParentTypes['AttributeGroupLimitsProjection']> = {
  total?: Resolver<ResolversTypes['AttributeGroupLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeGroupQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeGroupQueryResult'] = ResolversParentTypes['AttributeGroupQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['AttributeGroup']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeReferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeReference'] = ResolversParentTypes['AttributeReference']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AuthorizationHeaderResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthorizationHeader'] = ResolversParentTypes['AuthorizationHeader']> = {
  headerValue?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AzureFunctionsAuthenticationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AzureFunctionsAuthentication'] = ResolversParentTypes['AzureFunctionsAuthentication']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AzureServiceBusDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AzureServiceBusDestination'] = ResolversParentTypes['AzureServiceBusDestination']> = {
  connectionString?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BaseMoneyResolvers<ContextType = any, ParentType extends ResolversParentTypes['BaseMoney'] = ResolversParentTypes['BaseMoney']> = {
  __resolveType: TypeResolveFn<'HighPrecisionMoney' | 'Money', ParentType, ContextType>;
  centAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  fractionDigits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export interface BigDecimalScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigDecimal'], any> {
  name: 'BigDecimal';
}

export type BooleanAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanAttribute'] = ResolversParentTypes['BooleanAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BooleanAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanAttributeDefinitionType'] = ResolversParentTypes['BooleanAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BooleanFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanField'] = ResolversParentTypes['BooleanField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BooleanTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['BooleanType'] = ResolversParentTypes['BooleanType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnit'] = ResolversParentTypes['BusinessUnit']> = {
  addresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  ancestors?: Resolver<Array<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  associateMode?: Resolver<ResolversTypes['BusinessUnitAssociateMode'], ParentType, ContextType>;
  associates?: Resolver<Array<ResolversTypes['Associate']>, ParentType, ContextType>;
  billingAddressIds?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  billingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  contactEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  defaultBillingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  defaultBillingAddressId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultShippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  defaultShippingAddressId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inheritedAssociates?: Resolver<Maybe<Array<ResolversTypes['InheritedAssociate']>>, ParentType, ContextType>;
  inheritedStores?: Resolver<Maybe<Array<ResolversTypes['InheritedStore']>>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parentUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  parentUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  shippingAddressIds?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['BusinessUnitStatus'], ParentType, ContextType>;
  storeMode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stores?: Resolver<Maybe<Array<ResolversTypes['Store']>>, ParentType, ContextType>;
  storesRef?: Resolver<Maybe<Array<ResolversTypes['KeyReference']>>, ParentType, ContextType>;
  topLevelUnit?: Resolver<ResolversTypes['BusinessUnit'], ParentType, ContextType>;
  topLevelUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  unitType?: Resolver<ResolversTypes['BusinessUnitType'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAddressAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAddressAdded'] = ResolversParentTypes['BusinessUnitAddressAdded']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAddressChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAddressChanged'] = ResolversParentTypes['BusinessUnitAddressChanged']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAddressRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAddressRemoved'] = ResolversParentTypes['BusinessUnitAddressRemoved']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAssociateAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAssociateAdded'] = ResolversParentTypes['BusinessUnitAssociateAdded']> = {
  associate?: Resolver<ResolversTypes['Associate'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAssociateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAssociateChanged'] = ResolversParentTypes['BusinessUnitAssociateChanged']> = {
  associate?: Resolver<ResolversTypes['Associate'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAssociateModeChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAssociateModeChanged'] = ResolversParentTypes['BusinessUnitAssociateModeChanged']> = {
  associateMode?: Resolver<ResolversTypes['BusinessUnitAssociateMode'], ParentType, ContextType>;
  oldAssociateMode?: Resolver<Maybe<ResolversTypes['BusinessUnitAssociateMode']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAssociateRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAssociateRemoved'] = ResolversParentTypes['BusinessUnitAssociateRemoved']> = {
  associate?: Resolver<ResolversTypes['Associate'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitAssociatesSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitAssociatesSet'] = ResolversParentTypes['BusinessUnitAssociatesSet']> = {
  associates?: Resolver<Array<ResolversTypes['Associate']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitBillingAddressAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitBillingAddressAdded'] = ResolversParentTypes['BusinessUnitBillingAddressAdded']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitBillingAddressRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitBillingAddressRemoved'] = ResolversParentTypes['BusinessUnitBillingAddressRemoved']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitConfiguration'] = ResolversParentTypes['BusinessUnitConfiguration']> = {
  myBusinessUnitAssociateRoleOnCreation?: Resolver<Maybe<ResolversTypes['AssociateRole']>, ParentType, ContextType>;
  myBusinessUnitAssociateRoleOnCreationRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  myBusinessUnitStatusOnCreation?: Resolver<ResolversTypes['BusinessUnitConfigurationStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitContactEmailSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitContactEmailSet'] = ResolversParentTypes['BusinessUnitContactEmailSet']> = {
  contactEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitCreated'] = ResolversParentTypes['BusinessUnitCreated']> = {
  businessUnit?: Resolver<ResolversTypes['BusinessUnit'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitDefaultBillingAddressSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitDefaultBillingAddressSet'] = ResolversParentTypes['BusinessUnitDefaultBillingAddressSet']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitDefaultShippingAddressSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitDefaultShippingAddressSet'] = ResolversParentTypes['BusinessUnitDefaultShippingAddressSet']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitDeleted'] = ResolversParentTypes['BusinessUnitDeleted']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitNameChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitNameChanged'] = ResolversParentTypes['BusinessUnitNameChanged']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitParentChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitParentChanged'] = ResolversParentTypes['BusinessUnitParentChanged']> = {
  newParentUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  newParentUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  oldParentUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  oldParentUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitQueryResult'] = ResolversParentTypes['BusinessUnitQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitShippingAddressAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitShippingAddressAdded'] = ResolversParentTypes['BusinessUnitShippingAddressAdded']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitShippingAddressRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitShippingAddressRemoved'] = ResolversParentTypes['BusinessUnitShippingAddressRemoved']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitStatusChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitStatusChanged'] = ResolversParentTypes['BusinessUnitStatusChanged']> = {
  status?: Resolver<ResolversTypes['BusinessUnitStatus'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitStoreAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitStoreAdded'] = ResolversParentTypes['BusinessUnitStoreAdded']> = {
  store?: Resolver<ResolversTypes['Store'], ParentType, ContextType>;
  storeRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitStoreModeChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitStoreModeChanged'] = ResolversParentTypes['BusinessUnitStoreModeChanged']> = {
  oldStoreMode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldStores?: Resolver<Maybe<Array<ResolversTypes['Store']>>, ParentType, ContextType>;
  oldStoresRef?: Resolver<Maybe<Array<ResolversTypes['KeyReference']>>, ParentType, ContextType>;
  storeMode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stores?: Resolver<Maybe<Array<ResolversTypes['Store']>>, ParentType, ContextType>;
  storesRef?: Resolver<Maybe<Array<ResolversTypes['KeyReference']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitStoreRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitStoreRemoved'] = ResolversParentTypes['BusinessUnitStoreRemoved']> = {
  store?: Resolver<ResolversTypes['Store'], ParentType, ContextType>;
  storeRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BusinessUnitStoresSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['BusinessUnitStoresSet'] = ResolversParentTypes['BusinessUnitStoresSet']> = {
  stores?: Resolver<Array<ResolversTypes['Store']>, ParentType, ContextType>;
  storesRef?: Resolver<Array<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartResolvers<ContextType = any, ParentType extends ResolversParentTypes['Cart'] = ResolversParentTypes['Cart']> = {
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  businessUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  cartState?: Resolver<ResolversTypes['CartState'], ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customLineItems?: Resolver<Array<ResolversTypes['CustomLineItem']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  customerId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deleteDaysAfterLastModification?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  directDiscounts?: Resolver<Array<ResolversTypes['DirectDiscount']>, ParentType, ContextType>;
  discountCodes?: Resolver<Array<ResolversTypes['DiscountCodeInfo']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inventoryMode?: Resolver<ResolversTypes['InventoryMode'], ParentType, ContextType>;
  itemShippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lineItems?: Resolver<Array<ResolversTypes['LineItem']>, ParentType, ContextType, Partial<CartLineItemsArgs>>;
  locale?: Resolver<Maybe<ResolversTypes['Locale']>, ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['CartOrigin'], ParentType, ContextType>;
  paymentInfo?: Resolver<Maybe<ResolversTypes['PaymentInfo']>, ParentType, ContextType>;
  refusedGifts?: Resolver<Array<ResolversTypes['CartDiscount']>, ParentType, ContextType>;
  refusedGiftsRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  shipping?: Resolver<Array<ResolversTypes['Shipping']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingCustomFields?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingMode?: Resolver<ResolversTypes['ShippingMode'], ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  taxCalculationMode?: Resolver<ResolversTypes['TaxCalculationMode'], ParentType, ContextType>;
  taxMode?: Resolver<ResolversTypes['TaxMode'], ParentType, ContextType>;
  taxRoundingMode?: Resolver<ResolversTypes['RoundingMode'], ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  taxedShippingPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  totalLineItemQuantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartClassificationTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartClassificationType'] = ResolversParentTypes['CartClassificationType']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  values?: Resolver<Array<ResolversTypes['ShippingRateInputLocalizedEnumValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartCreated'] = ResolversParentTypes['CartCreated']> = {
  discountCodesRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  lineItemCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartDiscountResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscount'] = ResolversParentTypes['CartDiscount']> = {
  cartPredicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CartDiscountDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CartDiscountNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  referenceRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  requiresDiscountCode?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  sortOrder?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  stackingMode?: Resolver<ResolversTypes['StackingMode'], ParentType, ContextType>;
  stores?: Resolver<Array<ResolversTypes['Store']>, ParentType, ContextType>;
  storesRef?: Resolver<Array<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['CartDiscountTarget']>, ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['CartDiscountValue'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartDiscountLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountLimitWithCurrent'] = ResolversParentTypes['CartDiscountLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartDiscountLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountLimitsProjection'] = ResolversParentTypes['CartDiscountLimitsProjection']> = {
  totalActiveWithoutDiscountCodes?: Resolver<ResolversTypes['CartDiscountLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartDiscountQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountQueryInterface'] = ResolversParentTypes['CartDiscountQueryInterface']> = {
  __resolveType: TypeResolveFn<'InStore', ParentType, ContextType>;
  cartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, Partial<CartDiscountQueryInterfaceCartDiscountArgs>>;
  cartDiscounts?: Resolver<ResolversTypes['CartDiscountQueryResult'], ParentType, ContextType, Partial<CartDiscountQueryInterfaceCartDiscountsArgs>>;
};

export type CartDiscountQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountQueryResult'] = ResolversParentTypes['CartDiscountQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['CartDiscount']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartDiscountTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountTarget'] = ResolversParentTypes['CartDiscountTarget']> = {
  __resolveType: TypeResolveFn<'CustomLineItemsTarget' | 'LineItemsTarget' | 'MultiBuyCustomLineItemsTarget' | 'MultiBuyLineItemsTarget' | 'ShippingTarget', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type CartDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartDiscountValue'] = ResolversParentTypes['CartDiscountValue']> = {
  __resolveType: TypeResolveFn<'AbsoluteDiscountValue' | 'FixedPriceDiscountValue' | 'GiftLineItemValue' | 'RelativeDiscountValue', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type CartLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartLimitWithCurrent'] = ResolversParentTypes['CartLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartLimitsProjection'] = ResolversParentTypes['CartLimitsProjection']> = {
  total?: Resolver<ResolversTypes['CartLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartQueryInterface'] = ResolversParentTypes['CartQueryInterface']> = {
  __resolveType: TypeResolveFn<'AsAssociate' | 'InStore' | 'InStoreMe' | 'Me' | 'Query', ParentType, ContextType>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<CartQueryInterfaceCartArgs, 'id'>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<CartQueryInterfaceCartsArgs>>;
};

export type CartQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartQueryResult'] = ResolversParentTypes['CartQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Cart']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartScoreTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartScoreType'] = ResolversParentTypes['CartScoreType']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartValueTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartValueType'] = ResolversParentTypes['CartValueType']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CartsConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CartsConfiguration'] = ResolversParentTypes['CartsConfiguration']> = {
  allowAddingUnpublishedProducts?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  countryTaxRateFallbackEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  deleteDaysAfterLastModification?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Category'] = ResolversParentTypes['Category']> = {
  ancestors?: Resolver<Array<ResolversTypes['Category']>, ParentType, ContextType>;
  ancestorsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  assets?: Resolver<Array<ResolversTypes['Asset']>, ParentType, ContextType>;
  childCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  children?: Resolver<Maybe<Array<ResolversTypes['Category']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategoryDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategoryMetaDescriptionArgs>>;
  metaDescriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategoryMetaKeywordsArgs>>;
  metaKeywordsAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategoryMetaTitleArgs>>;
  metaTitleAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategoryNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  orderHint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  parentRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  stagedProductCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCreated'] = ResolversParentTypes['CategoryCreated']> = {
  category?: Resolver<ResolversTypes['Category'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryLimitsProjection'] = ResolversParentTypes['CategoryLimitsProjection']> = {
  maxCategories?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryOrderHintResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryOrderHint'] = ResolversParentTypes['CategoryOrderHint']> = {
  categoryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orderHint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryOrderHintProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryOrderHintProductSearch'] = ResolversParentTypes['CategoryOrderHintProductSearch']> = {
  categoryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orderHint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryQueryResult'] = ResolversParentTypes['CategoryQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Category']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategorySearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategorySearch'] = ResolversParentTypes['CategorySearch']> = {
  ancestors?: Resolver<Array<ResolversTypes['CategorySearch']>, ParentType, ContextType>;
  ancestorsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  assets?: Resolver<Array<ResolversTypes['Asset']>, ParentType, ContextType>;
  childCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  children?: Resolver<Array<ResolversTypes['CategorySearch']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySearchDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySearchNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  orderHint?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['CategorySearch']>, ParentType, ContextType>;
  parentRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  productTypeNames?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySearchSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  stagedProductCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategorySearchResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategorySearchResult'] = ResolversParentTypes['CategorySearchResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['CategorySearch']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategorySlugChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategorySlugChanged'] = ResolversParentTypes['CategorySlugChanged']> = {
  oldSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySlugChangedOldSlugArgs>>;
  oldSlugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CategorySlugChangedSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderCustomLineItemMoneyOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderCustomLineItemMoneyOutput'] = ResolversParentTypes['ChangeStagedOrderCustomLineItemMoneyOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  money?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderCustomLineItemQuantityOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderCustomLineItemQuantityOutput'] = ResolversParentTypes['ChangeStagedOrderCustomLineItemQuantityOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderLineItemQuantityOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderLineItemQuantityOutput'] = ResolversParentTypes['ChangeStagedOrderLineItemQuantityOutput']> = {
  externalPrice?: Resolver<Maybe<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  externalTotalPrice?: Resolver<Maybe<ResolversTypes['ExternalLineItemTotalPrice']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderOrderStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderOrderStateOutput'] = ResolversParentTypes['ChangeStagedOrderOrderStateOutput']> = {
  orderState?: Resolver<ResolversTypes['OrderState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderPaymentStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderPaymentStateOutput'] = ResolversParentTypes['ChangeStagedOrderPaymentStateOutput']> = {
  paymentState?: Resolver<ResolversTypes['PaymentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderShipmentStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderShipmentStateOutput'] = ResolversParentTypes['ChangeStagedOrderShipmentStateOutput']> = {
  shipmentState?: Resolver<ResolversTypes['ShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderTaxCalculationModeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderTaxCalculationModeOutput'] = ResolversParentTypes['ChangeStagedOrderTaxCalculationModeOutput']> = {
  taxCalculationMode?: Resolver<ResolversTypes['TaxCalculationMode'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderTaxModeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderTaxModeOutput'] = ResolversParentTypes['ChangeStagedOrderTaxModeOutput']> = {
  taxMode?: Resolver<ResolversTypes['TaxMode'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeStagedOrderTaxRoundingModeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeStagedOrderTaxRoundingModeOutput'] = ResolversParentTypes['ChangeStagedOrderTaxRoundingModeOutput']> = {
  taxRoundingMode?: Resolver<ResolversTypes['RoundingMode'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChangeSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChangeSubscription'] = ResolversParentTypes['ChangeSubscription']> = {
  resourceTypeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Channel'] = ResolversParentTypes['Channel']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ChannelDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  geoLocation?: Resolver<Maybe<ResolversTypes['Geometry']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ChannelNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  reviewRatingStatistics?: Resolver<Maybe<ResolversTypes['ReviewRatingStatistics']>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['ChannelRole']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelQueryResult'] = ResolversParentTypes['ChannelQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelReferenceIdentifierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelReferenceIdentifier'] = ResolversParentTypes['ChannelReferenceIdentifier']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClassificationShippingRateInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ClassificationShippingRateInput'] = ResolversParentTypes['ClassificationShippingRateInput']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ClassificationShippingRateInputLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ClassificationShippingRateInputDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ClassificationShippingRateInputDraftOutput'] = ResolversParentTypes['ClassificationShippingRateInputDraftOutput']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CloudEventsSubscriptionsFormatResolvers<ContextType = any, ParentType extends ResolversParentTypes['CloudEventsSubscriptionsFormat'] = ResolversParentTypes['CloudEventsSubscriptionsFormat']> = {
  cloudEventsVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommercetoolsSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommercetoolsSubscription'] = ResolversParentTypes['CommercetoolsSubscription']> = {
  changes?: Resolver<Array<ResolversTypes['ChangeSubscription']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  destination?: Resolver<ResolversTypes['Destination'], ParentType, ContextType>;
  format?: Resolver<ResolversTypes['NotificationFormat'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  messages?: Resolver<Array<ResolversTypes['MessageSubscription']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['SubscriptionHealthStatus'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CommercetoolsSubscriptionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CommercetoolsSubscriptionQueryResult'] = ResolversParentTypes['CommercetoolsSubscriptionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['CommercetoolsSubscription']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfluentCloudDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfluentCloudDestination'] = ResolversParentTypes['ConfluentCloudDestination']> = {
  acks?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  apiKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  apiSecret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bootstrapServer?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CountryScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Country'], any> {
  name: 'Country';
}

export interface CurrencyScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Currency'], any> {
  name: 'Currency';
}

export type CustomFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomField'] = ResolversParentTypes['CustomField']> = {
  __resolveType: TypeResolveFn<'BooleanField' | 'DateField' | 'DateTimeField' | 'EnumField' | 'LocalizedEnumField' | 'LocalizedStringField' | 'MoneyField' | 'NumberField' | 'ReferenceField' | 'StringField' | 'TimeField', ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type CustomFieldsCommandResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomFieldsCommand'] = ResolversParentTypes['CustomFieldsCommand']> = {
  fields?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  typeId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomFieldsTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomFieldsType'] = ResolversParentTypes['CustomFieldsType']> = {
  customFieldsRaw?: Resolver<Maybe<Array<ResolversTypes['RawCustomField']>>, ParentType, ContextType, Partial<CustomFieldsTypeCustomFieldsRawArgs>>;
  type?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType>;
  typeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomLineItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomLineItem'] = ResolversParentTypes['CustomLineItem']> = {
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  discountedPricePerQuantity?: Resolver<Array<ResolversTypes['DiscountedLineItemPriceForQuantity']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  money?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CustomLineItemNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  perMethodTaxRate?: Resolver<Array<ResolversTypes['MethodTaxRate']>, ParentType, ContextType>;
  priceMode?: Resolver<ResolversTypes['CustomLineItemPriceMode'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetails']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Array<ResolversTypes['ItemState']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  taxedPricePortions?: Resolver<Array<ResolversTypes['MethodTaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomLineItemDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomLineItemDraftOutput'] = ResolversParentTypes['CustomLineItemDraftOutput']> = {
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  money?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<CustomLineItemDraftOutputNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  priceMode?: Resolver<ResolversTypes['CustomLineItemPriceMode'], ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetailsDraftOutput']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxCategoryResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomLineItemReturnItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomLineItemReturnItem'] = ResolversParentTypes['CustomLineItemReturnItem']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customLineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  paymentState?: Resolver<ResolversTypes['ReturnPaymentState'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomLineItemStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomLineItemStateTransition'] = ResolversParentTypes['CustomLineItemStateTransition']> = {
  customLineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fromState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  fromStateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  toState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  toStateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  transitionDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomLineItemsTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomLineItemsTarget'] = ResolversParentTypes['CustomLineItemsTarget']> = {
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomObject'] = ResolversParentTypes['CustomObject']> = {
  container?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomObjectLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomObjectLimitWithCurrent'] = ResolversParentTypes['CustomObjectLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomObjectLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomObjectLimitsProjection'] = ResolversParentTypes['CustomObjectLimitsProjection']> = {
  total?: Resolver<ResolversTypes['CustomObjectLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomObjectQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomObjectQueryResult'] = ResolversParentTypes['CustomObjectQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['CustomObject']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomSuggestTokenizerResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomSuggestTokenizer'] = ResolversParentTypes['CustomSuggestTokenizer']> = {
  inputs?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomSuggestTokenizerProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomSuggestTokenizerProductSearch'] = ResolversParentTypes['CustomSuggestTokenizerProductSearch']> = {
  inputs?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Customer'] = ResolversParentTypes['Customer']> = {
  MMU_TEST?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  addresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  authenticationMode?: Resolver<Maybe<ResolversTypes['AuthenticationMode']>, ParentType, ContextType>;
  billingAddressIds?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  billingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  customerNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  defaultBillingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  defaultBillingAddressId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultShippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  defaultShippingAddressId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isEmailVerified?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  locale?: Resolver<Maybe<ResolversTypes['Locale']>, ParentType, ContextType>;
  middleName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  password?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  salutation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddressIds?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  stores?: Resolver<Array<ResolversTypes['Store']>, ParentType, ContextType>;
  storesRef?: Resolver<Array<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vatId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerActiveCartInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerActiveCartInterface'] = ResolversParentTypes['CustomerActiveCartInterface']> = {
  __resolveType: TypeResolveFn<'InStore' | 'Query', ParentType, ContextType>;
  customerActiveCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<CustomerActiveCartInterfaceCustomerActiveCartArgs, 'customerId'>>;
};

export type CustomerAddressAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerAddressAdded'] = ResolversParentTypes['CustomerAddressAdded']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerAddressChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerAddressChanged'] = ResolversParentTypes['CustomerAddressChanged']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerAddressRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerAddressRemoved'] = ResolversParentTypes['CustomerAddressRemoved']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerCompanyNameSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerCompanyNameSet'] = ResolversParentTypes['CustomerCompanyNameSet']> = {
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerCreated'] = ResolversParentTypes['CustomerCreated']> = {
  customer?: Resolver<ResolversTypes['Customer'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerDateOfBirthSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerDateOfBirthSet'] = ResolversParentTypes['CustomerDateOfBirthSet']> = {
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerDeleted'] = ResolversParentTypes['CustomerDeleted']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerEmailChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerEmailChanged'] = ResolversParentTypes['CustomerEmailChanged']> = {
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerEmailTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerEmailToken'] = ResolversParentTypes['CustomerEmailToken']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  customerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiresAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerEmailTokenCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerEmailTokenCreated'] = ResolversParentTypes['CustomerEmailTokenCreated']> = {
  customerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiresAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerEmailVerifiedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerEmailVerified'] = ResolversParentTypes['CustomerEmailVerified']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerFirstNameSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerFirstNameSet'] = ResolversParentTypes['CustomerFirstNameSet']> = {
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroup'] = ResolversParentTypes['CustomerGroup']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroupLimitWithCurrent'] = ResolversParentTypes['CustomerGroupLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroupLimitsProjection'] = ResolversParentTypes['CustomerGroupLimitsProjection']> = {
  total?: Resolver<ResolversTypes['CustomerGroupLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroupQueryResult'] = ResolversParentTypes['CustomerGroupQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupReferenceIdentifierResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroupReferenceIdentifier'] = ResolversParentTypes['CustomerGroupReferenceIdentifier']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerGroupSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerGroupSet'] = ResolversParentTypes['CustomerGroupSet']> = {
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerLastNameSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerLastNameSet'] = ResolversParentTypes['CustomerLastNameSet']> = {
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerLimitWithCurrent'] = ResolversParentTypes['CustomerLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerLimitsProjection'] = ResolversParentTypes['CustomerLimitsProjection']> = {
  total?: Resolver<ResolversTypes['CustomerLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerPasswordTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerPasswordToken'] = ResolversParentTypes['CustomerPasswordToken']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  customerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiresAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerPasswordTokenCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerPasswordTokenCreated'] = ResolversParentTypes['CustomerPasswordTokenCreated']> = {
  customerId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expiresAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerPasswordUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerPasswordUpdated'] = ResolversParentTypes['CustomerPasswordUpdated']> = {
  reset?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerQueryInterface'] = ResolversParentTypes['CustomerQueryInterface']> = {
  __resolveType: TypeResolveFn<'InStore' | 'Query', ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, Partial<CustomerQueryInterfaceCustomerArgs>>;
  customers?: Resolver<ResolversTypes['CustomerQueryResult'], ParentType, ContextType, Partial<CustomerQueryInterfaceCustomersArgs>>;
};

export type CustomerQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerQueryResult'] = ResolversParentTypes['CustomerQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Customer']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerSearchConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerSearchConfiguration'] = ResolversParentTypes['CustomerSearchConfiguration']> = {
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['CustomerSearchStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerSignInResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerSignInResult'] = ResolversParentTypes['CustomerSignInResult']> = {
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  customer?: Resolver<ResolversTypes['Customer'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerTitleSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerTitleSet'] = ResolversParentTypes['CustomerTitleSet']> = {
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export type DateAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateAttribute'] = ResolversParentTypes['DateAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateAttributeDefinitionType'] = ResolversParentTypes['DateAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateField'] = ResolversParentTypes['DateField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type DateTimeAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateTimeAttribute'] = ResolversParentTypes['DateTimeAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateTimeAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateTimeAttributeDefinitionType'] = ResolversParentTypes['DateTimeAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateTimeFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateTimeField'] = ResolversParentTypes['DateTimeField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateTimeTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateTimeType'] = ResolversParentTypes['DateTimeType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DateTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DateType'] = ResolversParentTypes['DateType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Delivery'] = ResolversParentTypes['Delivery']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcels?: Resolver<Array<ResolversTypes['Parcel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryAdded'] = ResolversParentTypes['DeliveryAdded']> = {
  delivery?: Resolver<ResolversTypes['Delivery'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryAddressSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryAddressSet'] = ResolversParentTypes['DeliveryAddressSet']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  oldAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryItem'] = ResolversParentTypes['DeliveryItem']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryItemsUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryItemsUpdated'] = ResolversParentTypes['DeliveryItemsUpdated']> = {
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  oldItems?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryRemoved'] = ResolversParentTypes['DeliveryRemoved']> = {
  delivery?: Resolver<ResolversTypes['Delivery'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Destination'] = ResolversParentTypes['Destination']> = {
  __resolveType: TypeResolveFn<'AzureServiceBusDestination' | 'ConfluentCloudDestination' | 'EventBridgeDestination' | 'EventGridDestination' | 'GoogleCloudPubSubDestination' | 'SNSDestination' | 'SQSDestination', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type DimensionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Dimensions'] = ResolversParentTypes['Dimensions']> = {
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DimensionsProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['DimensionsProductSearch'] = ResolversParentTypes['DimensionsProductSearch']> = {
  height?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  width?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DirectDiscountResolvers<ContextType = any, ParentType extends ResolversParentTypes['DirectDiscount'] = ResolversParentTypes['DirectDiscount']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['CartDiscountTarget']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['CartDiscountValue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DirectDiscountDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['DirectDiscountDraftOutput'] = ResolversParentTypes['DirectDiscountDraftOutput']> = {
  target?: Resolver<Maybe<ResolversTypes['CartDiscountTarget']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['CartDiscountValue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountCodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountCode'] = ResolversParentTypes['DiscountCode']> = {
  applicationCount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  applicationVersion?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  cartDiscountRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  cartDiscounts?: Resolver<Array<ResolversTypes['CartDiscount']>, ParentType, ContextType>;
  cartPredicate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<DiscountCodeDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  groups?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  maxApplications?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  maxApplicationsPerCustomer?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<DiscountCodeNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  referenceRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountCodeInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountCodeInfo'] = ResolversParentTypes['DiscountCodeInfo']> = {
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  discountCodeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['DiscountCodeState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountCodeQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountCodeQueryResult'] = ResolversParentTypes['DiscountCodeQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountedLineItemPortionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountedLineItemPortion'] = ResolversParentTypes['DiscountedLineItemPortion']> = {
  discount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType>;
  discountRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  discountedAmount?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountedLineItemPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountedLineItemPrice'] = ResolversParentTypes['DiscountedLineItemPrice']> = {
  includedDiscounts?: Resolver<Array<ResolversTypes['DiscountedLineItemPortion']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountedLineItemPriceForQuantityResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountedLineItemPriceForQuantity'] = ResolversParentTypes['DiscountedLineItemPriceForQuantity']> = {
  discountedPrice?: Resolver<ResolversTypes['DiscountedLineItemPrice'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountedProductPriceValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountedProductPriceValue'] = ResolversParentTypes['DiscountedProductPriceValue']> = {
  discount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType>;
  discountRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountedProductSearchPriceValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountedProductSearchPriceValue'] = ResolversParentTypes['DiscountedProductSearchPriceValue']> = {
  discount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType>;
  discountRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnumAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EnumAttribute'] = ResolversParentTypes['EnumAttribute']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnumAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EnumAttributeDefinitionType'] = ResolversParentTypes['EnumAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  values?: Resolver<ResolversTypes['PlainEnumValueResult'], ParentType, ContextType, Partial<EnumAttributeDefinitionTypeValuesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnumFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['EnumField'] = ResolversParentTypes['EnumField']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnumTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EnumType'] = ResolversParentTypes['EnumType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  values?: Resolver<Array<ResolversTypes['EnumValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EnumValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['EnumValue'] = ResolversParentTypes['EnumValue']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventBridgeDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventBridgeDestination'] = ResolversParentTypes['EventBridgeDestination']> = {
  accountId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  region?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventGridDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventGridDestination'] = ResolversParentTypes['EventGridDestination']> = {
  accessKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExtensionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Extension'] = ResolversParentTypes['Extension']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  destination?: Resolver<ResolversTypes['ExtensionDestination'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  timeoutInMs?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  triggers?: Resolver<Array<ResolversTypes['Trigger']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExtensionDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExtensionDestination'] = ResolversParentTypes['ExtensionDestination']> = {
  __resolveType: TypeResolveFn<'AWSLambdaDestination' | 'GoogleCloudFunctionDestination' | 'HttpDestination', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ExtensionLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExtensionLimitsProjection'] = ResolversParentTypes['ExtensionLimitsProjection']> = {
  timeoutInMs?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExtensionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExtensionQueryResult'] = ResolversParentTypes['ExtensionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Extension']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalDiscountValue'] = ResolversParentTypes['ExternalDiscountValue']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalLineItemTotalPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalLineItemTotalPrice'] = ResolversParentTypes['ExternalLineItemTotalPrice']> = {
  price?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalOAuthResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalOAuth'] = ResolversParentTypes['ExternalOAuth']> = {
  authorizationHeader?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalTaxAmountDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalTaxAmountDraftOutput'] = ResolversParentTypes['ExternalTaxAmountDraftOutput']> = {
  taxRate?: Resolver<ResolversTypes['ExternalTaxRateDraftOutput'], ParentType, ContextType>;
  totalGross?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalTaxRateDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalTaxRateDraftOutput'] = ResolversParentTypes['ExternalTaxRateDraftOutput']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  country?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  includedInPrice?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subRates?: Resolver<Array<ResolversTypes['SubRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FacetResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['FacetResult'] = ResolversParentTypes['FacetResult']> = {
  __resolveType: TypeResolveFn<'RangeFacetResult' | 'TermsFacetResult' | 'ValueFacetResult', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type FacetResultValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['FacetResultValue'] = ResolversParentTypes['FacetResultValue']> = {
  facet?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['FacetResult'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FieldDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FieldDefinition'] = ResolversParentTypes['FieldDefinition']> = {
  inputHint?: Resolver<ResolversTypes['TextInputHint'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<FieldDefinitionLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  required?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['FieldType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FieldTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FieldType'] = ResolversParentTypes['FieldType']> = {
  __resolveType: TypeResolveFn<'BooleanType' | 'DateTimeType' | 'DateType' | 'EnumType' | 'LocalizedEnumType' | 'LocalizedStringType' | 'MoneyType' | 'NumberType' | 'ReferenceType' | 'SetType' | 'StringType' | 'TimeType', ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type FixedPriceDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['FixedPriceDiscountValue'] = ResolversParentTypes['FixedPriceDiscountValue']> = {
  money?: Resolver<Array<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GeometryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Geometry'] = ResolversParentTypes['Geometry']> = {
  __resolveType: TypeResolveFn<'Point', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type GiftLineItemValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftLineItemValue'] = ResolversParentTypes['GiftLineItemValue']> = {
  distributionChannelRef?: Resolver<Maybe<ResolversTypes['ChannelReferenceIdentifier']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['ProductReferenceIdentifier'], ParentType, ContextType>;
  supplyChannelRef?: Resolver<Maybe<ResolversTypes['ChannelReferenceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GoogleCloudFunctionDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['GoogleCloudFunctionDestination'] = ResolversParentTypes['GoogleCloudFunctionDestination']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GoogleCloudPubSubDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['GoogleCloudPubSubDestination'] = ResolversParentTypes['GoogleCloudPubSubDestination']> = {
  projectId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  topic?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HighPrecisionMoneyResolvers<ContextType = any, ParentType extends ResolversParentTypes['HighPrecisionMoney'] = ResolversParentTypes['HighPrecisionMoney']> = {
  centAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  fractionDigits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  preciseAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HttpDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['HttpDestination'] = ResolversParentTypes['HttpDestination']> = {
  authentication?: Resolver<Maybe<ResolversTypes['HttpDestinationAuthentication']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type HttpDestinationAuthenticationResolvers<ContextType = any, ParentType extends ResolversParentTypes['HttpDestinationAuthentication'] = ResolversParentTypes['HttpDestinationAuthentication']> = {
  __resolveType: TypeResolveFn<'AuthorizationHeader' | 'AzureFunctionsAuthentication', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Image'] = ResolversParentTypes['Image']> = {
  dimensions?: Resolver<ResolversTypes['Dimensions'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImageProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImageProductSearch'] = ResolversParentTypes['ImageProductSearch']> = {
  dimensions?: Resolver<ResolversTypes['DimensionsProductSearch'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportStagedOrderCustomLineItemStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportStagedOrderCustomLineItemStateOutput'] = ResolversParentTypes['ImportStagedOrderCustomLineItemStateOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImportStagedOrderLineItemStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ImportStagedOrderLineItemStateOutput'] = ResolversParentTypes['ImportStagedOrderLineItemStateOutput']> = {
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InStoreResolvers<ContextType = any, ParentType extends ResolversParentTypes['InStore'] = ResolversParentTypes['InStore']> = {
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<InStoreCartArgs, 'id'>>;
  cartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, Partial<InStoreCartDiscountArgs>>;
  cartDiscounts?: Resolver<ResolversTypes['CartDiscountQueryResult'], ParentType, ContextType, Partial<InStoreCartDiscountsArgs>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<InStoreCartsArgs>>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, Partial<InStoreCustomerArgs>>;
  customerActiveCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<InStoreCustomerActiveCartArgs, 'customerId'>>;
  customers?: Resolver<ResolversTypes['CustomerQueryResult'], ParentType, ContextType, Partial<InStoreCustomersArgs>>;
  me?: Resolver<ResolversTypes['InStoreMe'], ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<InStoreOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<InStoreOrdersArgs>>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<InStoreProductArgs, 'projectExpandedProducts'>>;
  productSelectionAssignments?: Resolver<ResolversTypes['ProductAssignmentQueryResult'], ParentType, ContextType, Partial<InStoreProductSelectionAssignmentsArgs>>;
  shippingMethodsByCart?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<InStoreShippingMethodsByCartArgs, 'id'>>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<InStoreShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<InStoreShoppingListsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InStoreMeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InStoreMe'] = ResolversParentTypes['InStoreMe']> = {
  activeCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<InStoreMeCartArgs, 'id'>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<InStoreMeCartsArgs>>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<InStoreMeOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<InStoreMeOrdersArgs>>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<InStoreMeShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<InStoreMeShoppingListsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InheritedAssociateResolvers<ContextType = any, ParentType extends ResolversParentTypes['InheritedAssociate'] = ResolversParentTypes['InheritedAssociate']> = {
  associateRoleAssignments?: Resolver<Array<ResolversTypes['InheritedAssociateRoleAssignment']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InheritedAssociateRoleAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['InheritedAssociateRoleAssignment'] = ResolversParentTypes['InheritedAssociateRoleAssignment']> = {
  associateRole?: Resolver<ResolversTypes['AssociateRole'], ParentType, ContextType>;
  associateRoleRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  source?: Resolver<ResolversTypes['BusinessUnit'], ParentType, ContextType>;
  sourceRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InheritedStoreResolvers<ContextType = any, ParentType extends ResolversParentTypes['InheritedStore'] = ResolversParentTypes['InheritedStore']> = {
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InitiatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Initiator'] = ResolversParentTypes['Initiator']> = {
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  associateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  clientId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  externalUserId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isPlatformClient?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  userRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InterfaceInteractionsRawResolvers<ContextType = any, ParentType extends ResolversParentTypes['InterfaceInteractionsRaw'] = ResolversParentTypes['InterfaceInteractionsRaw']> = {
  fields?: Resolver<Array<ResolversTypes['RawCustomField']>, ParentType, ContextType, Partial<InterfaceInteractionsRawFieldsArgs>>;
  type?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType>;
  typeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InterfaceInteractionsRawResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['InterfaceInteractionsRawResult'] = ResolversParentTypes['InterfaceInteractionsRawResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['InterfaceInteractionsRaw']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InventoryEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['InventoryEntry'] = ResolversParentTypes['InventoryEntry']> = {
  availableQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  expectedDelivery?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  quantityOnStock?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  restockableInDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sku?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  supplyChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InventoryEntryCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['InventoryEntryCreated'] = ResolversParentTypes['InventoryEntryCreated']> = {
  inventoryEntry?: Resolver<ResolversTypes['InventoryEntry'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InventoryEntryDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['InventoryEntryDeleted'] = ResolversParentTypes['InventoryEntryDeleted']> = {
  sku?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  supplyChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InventoryEntryQuantitySetResolvers<ContextType = any, ParentType extends ResolversParentTypes['InventoryEntryQuantitySet'] = ResolversParentTypes['InventoryEntryQuantitySet']> = {
  newAvailableQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  newQuantityOnStock?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  oldAvailableQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  oldQuantityOnStock?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  supplyChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InventoryEntryQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['InventoryEntryQueryResult'] = ResolversParentTypes['InventoryEntryQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['InventoryEntry']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemShippingDetailsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemShippingDetails'] = ResolversParentTypes['ItemShippingDetails']> = {
  targets?: Resolver<Array<ResolversTypes['ItemShippingTarget']>, ParentType, ContextType>;
  valid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemShippingDetailsDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemShippingDetailsDraftOutput'] = ResolversParentTypes['ItemShippingDetailsDraftOutput']> = {
  targets?: Resolver<Array<ResolversTypes['ItemShippingTarget']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemShippingTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemShippingTarget'] = ResolversParentTypes['ItemShippingTarget']> = {
  addressKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shippingMethodKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ItemStateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ItemState'] = ResolversParentTypes['ItemState']> = {
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Json'], any> {
  name: 'Json';
}

export type KeyReferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['KeyReference'] = ResolversParentTypes['KeyReference']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface KeyReferenceInputScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['KeyReferenceInput'], any> {
  name: 'KeyReferenceInput';
}

export type LimitResolvers<ContextType = any, ParentType extends ResolversParentTypes['Limit'] = ResolversParentTypes['Limit']> = {
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['LimitWithCurrent'] = ResolversParentTypes['LimitWithCurrent']> = {
  __resolveType: TypeResolveFn<'AttributeGroupLimitWithCurrent' | 'CartDiscountLimitWithCurrent' | 'CartLimitWithCurrent' | 'CustomObjectLimitWithCurrent' | 'CustomerGroupLimitWithCurrent' | 'CustomerLimitWithCurrent' | 'OrderEditLimitWithCurrent' | 'ProductDiscountLimitWithCurrent' | 'ProductTypeLimitWithCurrent' | 'RefreshTokenLimitWithCurrent' | 'ShippingMethodLimitWithCurrent' | 'ShoppingListLimitWithCurrent' | 'StoreLimitWithCurrent' | 'TaxCategoryLimitWithCurrent' | 'ZoneLimitWithCurrent', ParentType, ContextType>;
  current?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
};

export type LineItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['LineItem'] = ResolversParentTypes['LineItem']> = {
  addedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  discountedPricePerQuantity?: Resolver<Array<ResolversTypes['DiscountedLineItemPriceForQuantity']>, ParentType, ContextType>;
  distributionChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  distributionChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inventoryMode?: Resolver<Maybe<ResolversTypes['InventoryMode']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lineItemMode?: Resolver<ResolversTypes['LineItemMode'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<LineItemNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  perMethodTaxRate?: Resolver<Array<ResolversTypes['MethodTaxRate']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['ProductPrice'], ParentType, ContextType>;
  priceMode?: Resolver<ResolversTypes['LineItemPriceMode'], ParentType, ContextType>;
  productId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  productKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<LineItemProductSlugArgs>>;
  productSlugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType>;
  productTypeRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetails']>, ParentType, ContextType>;
  state?: Resolver<Array<ResolversTypes['ItemState']>, ParentType, ContextType>;
  supplyChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  taxedPricePortions?: Resolver<Array<ResolversTypes['MethodTaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LineItemDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['LineItemDraftOutput'] = ResolversParentTypes['LineItemDraftOutput']> = {
  addedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  distributionChannelResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  externalPrice?: Resolver<Maybe<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  externalTotalPrice?: Resolver<Maybe<ResolversTypes['ExternalLineItemTotalPrice']>, ParentType, ContextType>;
  inventoryMode?: Resolver<Maybe<ResolversTypes['InventoryMode']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetailsDraftOutput']>, ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  supplyChannelResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  variantId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LineItemReturnItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['LineItemReturnItem'] = ResolversParentTypes['LineItemReturnItem']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentState?: Resolver<ResolversTypes['ReturnPaymentState'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LineItemStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['LineItemStateTransition'] = ResolversParentTypes['LineItemStateTransition']> = {
  fromState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  fromStateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  lineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  toState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  toStateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  transitionDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LineItemsTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['LineItemsTarget'] = ResolversParentTypes['LineItemsTarget']> = {
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface LocaleScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Locale'], any> {
  name: 'Locale';
}

export type LocalizableEnumAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizableEnumAttributeDefinitionType'] = ResolversParentTypes['LocalizableEnumAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  values?: Resolver<ResolversTypes['LocalizableEnumValueTypeResult'], ParentType, ContextType, Partial<LocalizableEnumAttributeDefinitionTypeValuesArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizableEnumValueTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizableEnumValueType'] = ResolversParentTypes['LocalizableEnumValueType']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<LocalizableEnumValueTypeLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizableEnumValueTypeResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizableEnumValueTypeResult'] = ResolversParentTypes['LocalizableEnumValueTypeResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['LocalizableEnumValueType']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizableTextAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizableTextAttributeDefinitionType'] = ResolversParentTypes['LocalizableTextAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedEnumAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedEnumAttribute'] = ResolversParentTypes['LocalizedEnumAttribute']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LocalizedEnumAttributeLabelArgs, 'locale'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedEnumFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedEnumField'] = ResolversParentTypes['LocalizedEnumField']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LocalizedEnumFieldLabelArgs, 'locale'>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedEnumTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedEnumType'] = ResolversParentTypes['LocalizedEnumType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  values?: Resolver<Array<ResolversTypes['LocalizedEnumValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedEnumValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedEnumValue'] = ResolversParentTypes['LocalizedEnumValue']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<LocalizedEnumValueLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedStringResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedString'] = ResolversParentTypes['LocalizedString']> = {
  locale?: Resolver<ResolversTypes['Locale'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedStringAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedStringAttribute'] = ResolversParentTypes['LocalizedStringAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LocalizedStringAttributeValueArgs, 'locale'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedStringFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedStringField'] = ResolversParentTypes['LocalizedStringField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<LocalizedStringFieldValueArgs, 'locale'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocalizedStringTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LocalizedStringType'] = ResolversParentTypes['LocalizedStringType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LocationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Location'] = ResolversParentTypes['Location']> = {
  country?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface LongScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Long'], any> {
  name: 'Long';
}

export type MeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Me'] = ResolversParentTypes['Me']> = {
  activeCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, Partial<MeBusinessUnitArgs>>;
  businessUnits?: Resolver<ResolversTypes['BusinessUnitQueryResult'], ParentType, ContextType, Partial<MeBusinessUnitsArgs>>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MeCartArgs, 'id'>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<MeCartsArgs>>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<MeOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<MeOrdersArgs>>;
  payment?: Resolver<Maybe<ResolversTypes['MyPayment']>, ParentType, ContextType, RequireFields<MePaymentArgs, 'id'>>;
  payments?: Resolver<ResolversTypes['MyPaymentQueryResult'], ParentType, ContextType, Partial<MePaymentsArgs>>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, Partial<MeQuoteArgs>>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, Partial<MeQuoteRequestArgs>>;
  quoteRequests?: Resolver<ResolversTypes['QuoteRequestQueryResult'], ParentType, ContextType, Partial<MeQuoteRequestsArgs>>;
  quotes?: Resolver<ResolversTypes['QuoteQueryResult'], ParentType, ContextType, Partial<MeQuotesArgs>>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<MeShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<MeShoppingListsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MeFieldInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeFieldInterface'] = ResolversParentTypes['MeFieldInterface']> = {
  __resolveType: TypeResolveFn<'InStore' | 'Query', ParentType, ContextType>;
  me?: Resolver<ResolversTypes['MeQueryInterface'], ParentType, ContextType>;
};

export type MeQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['MeQueryInterface'] = ResolversParentTypes['MeQueryInterface']> = {
  __resolveType: TypeResolveFn<'InStoreMe' | 'Me', ParentType, ContextType>;
  activeCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MeQueryInterfaceCartArgs, 'id'>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<MeQueryInterfaceCartsArgs>>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<MeQueryInterfaceOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<MeQueryInterfaceOrdersArgs>>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<MeQueryInterfaceShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<MeQueryInterfaceShoppingListsArgs>>;
};

export type MessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Message'] = ResolversParentTypes['Message']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  payload?: Resolver<ResolversTypes['MessagePayload'], ParentType, ContextType>;
  resourceRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  resourceVersion?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  sequenceNumber?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userProvidedIdentifiers?: Resolver<Maybe<ResolversTypes['UserProvidedIdentifiers']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagePayload'] = ResolversParentTypes['MessagePayload']> = {
  __resolveType: TypeResolveFn<'ApprovalFlowApproved' | 'ApprovalFlowCompleted' | 'ApprovalFlowCreated' | 'ApprovalFlowRejected' | 'AssociateRoleBuyerAssignableChanged' | 'AssociateRoleCreated' | 'AssociateRoleDeleted' | 'AssociateRoleNameSet' | 'AssociateRolePermissionAdded' | 'AssociateRolePermissionRemoved' | 'AssociateRolePermissionsSet' | 'BusinessUnitAddressAdded' | 'BusinessUnitAddressChanged' | 'BusinessUnitAddressRemoved' | 'BusinessUnitAssociateAdded' | 'BusinessUnitAssociateChanged' | 'BusinessUnitAssociateModeChanged' | 'BusinessUnitAssociateRemoved' | 'BusinessUnitAssociatesSet' | 'BusinessUnitBillingAddressAdded' | 'BusinessUnitBillingAddressRemoved' | 'BusinessUnitContactEmailSet' | 'BusinessUnitCreated' | 'BusinessUnitDefaultBillingAddressSet' | 'BusinessUnitDefaultShippingAddressSet' | 'BusinessUnitDeleted' | 'BusinessUnitNameChanged' | 'BusinessUnitParentChanged' | 'BusinessUnitShippingAddressAdded' | 'BusinessUnitShippingAddressRemoved' | 'BusinessUnitStatusChanged' | 'BusinessUnitStoreAdded' | 'BusinessUnitStoreModeChanged' | 'BusinessUnitStoreRemoved' | 'BusinessUnitStoresSet' | 'CartCreated' | 'CategoryCreated' | 'CategorySlugChanged' | 'CustomLineItemStateTransition' | 'CustomerAddressAdded' | 'CustomerAddressChanged' | 'CustomerAddressRemoved' | 'CustomerCompanyNameSet' | 'CustomerCreated' | 'CustomerDateOfBirthSet' | 'CustomerDeleted' | 'CustomerEmailChanged' | 'CustomerEmailTokenCreated' | 'CustomerEmailVerified' | 'CustomerFirstNameSet' | 'CustomerGroupSet' | 'CustomerLastNameSet' | 'CustomerPasswordTokenCreated' | 'CustomerPasswordUpdated' | 'CustomerTitleSet' | 'DeliveryAdded' | 'DeliveryAddressSet' | 'DeliveryItemsUpdated' | 'DeliveryRemoved' | 'InventoryEntryCreated' | 'InventoryEntryDeleted' | 'InventoryEntryQuantitySet' | 'LineItemStateTransition' | 'OrderBillingAddressSet' | 'OrderCreated' | 'OrderCustomFieldAdded' | 'OrderCustomFieldChanged' | 'OrderCustomFieldRemoved' | 'OrderCustomLineItemAdded' | 'OrderCustomLineItemDiscountSet' | 'OrderCustomLineItemQuantityChanged' | 'OrderCustomLineItemRemoved' | 'OrderCustomTypeRemoved' | 'OrderCustomTypeSet' | 'OrderCustomerEmailSet' | 'OrderCustomerGroupSet' | 'OrderCustomerSet' | 'OrderDeleted' | 'OrderDiscountCodeAdded' | 'OrderDiscountCodeRemoved' | 'OrderDiscountCodeStateSet' | 'OrderEditApplied' | 'OrderImported' | 'OrderLineItemAdded' | 'OrderLineItemDiscountSet' | 'OrderLineItemDistributionChannelSet' | 'OrderLineItemRemoved' | 'OrderPaymentAdded' | 'OrderPaymentRemoved' | 'OrderPaymentStateChanged' | 'OrderReturnShipmentStateChanged' | 'OrderShipmentStateChanged' | 'OrderShippingAddressSet' | 'OrderShippingInfoSet' | 'OrderShippingRateInputSet' | 'OrderStateChanged' | 'OrderStateTransition' | 'OrderStoreSet' | 'ParcelAddedToDelivery' | 'ParcelItemsUpdated' | 'ParcelMeasurementsUpdated' | 'ParcelRemovedFromDelivery' | 'ParcelTrackingDataUpdated' | 'PaymentCreated' | 'PaymentInteractionAdded' | 'PaymentStatusInterfaceCodeSet' | 'PaymentStatusStateTransition' | 'PaymentTransactionAdded' | 'PaymentTransactionStateChanged' | 'ProductAddedToCategory' | 'ProductCreated' | 'ProductDeleted' | 'ProductImageAdded' | 'ProductPriceAdded' | 'ProductPriceChanged' | 'ProductPriceDiscountsSet' | 'ProductPriceExternalDiscountSet' | 'ProductPriceKeySet' | 'ProductPriceModeSet' | 'ProductPriceRemoved' | 'ProductPricesSet' | 'ProductPublished' | 'ProductRemovedFromCategory' | 'ProductRevertedStagedChanges' | 'ProductSelectionCreated' | 'ProductSelectionDeleted' | 'ProductSelectionProductAdded' | 'ProductSelectionProductExcluded' | 'ProductSelectionProductRemoved' | 'ProductSelectionVariantExclusionChanged' | 'ProductSelectionVariantSelectionChanged' | 'ProductSlugChanged' | 'ProductStateTransition' | 'ProductUnpublished' | 'ProductVariantAdded' | 'ProductVariantDeleted' | 'PurchaseOrderNumberSet' | 'ReturnInfoAdded' | 'ReturnInfoSet' | 'ReviewCreated' | 'ReviewRatingSet' | 'ReviewStateTransition' | 'StandalonePriceActiveChanged' | 'StandalonePriceCreated' | 'StandalonePriceDeleted' | 'StandalonePriceDiscountSet' | 'StandalonePriceExpiresAtSet' | 'StandalonePriceExternalDiscountSet' | 'StandalonePriceKeySet' | 'StandalonePriceStagedChangesApplied' | 'StandalonePriceStagedChangesRemoved' | 'StandalonePriceTierAdded' | 'StandalonePriceTierRemoved' | 'StandalonePriceTiersSet' | 'StandalonePriceValidFromAndUntilSet' | 'StandalonePriceValidFromSet' | 'StandalonePriceValidUntilSet' | 'StandalonePriceValueChanged' | 'StoreCountriesChanged' | 'StoreCreated' | 'StoreDeleted' | 'StoreDistributionChannelsChanged' | 'StoreLanguagesChanged' | 'StoreNameSet' | 'StoreProductSelectionsChanged' | 'StoreSupplyChannelsChanged', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type MessageQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageQueryResult'] = ResolversParentTypes['MessageQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Message']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessageSubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessageSubscription'] = ResolversParentTypes['MessageSubscription']> = {
  resourceTypeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  types?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MessagesConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MessagesConfiguration'] = ResolversParentTypes['MessagesConfiguration']> = {
  deleteDaysAfterCreation?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MethodTaxRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MethodTaxRate'] = ResolversParentTypes['MethodTaxRate']> = {
  shippingMethodKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MethodTaxedPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['MethodTaxedPrice'] = ResolversParentTypes['MethodTaxedPrice']> = {
  shippingMethodKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Money'] = ResolversParentTypes['Money']> = {
  centAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  fractionDigits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MoneyAttribute'] = ResolversParentTypes['MoneyAttribute']> = {
  centAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MoneyAttributeDefinitionType'] = ResolversParentTypes['MoneyAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['MoneyField'] = ResolversParentTypes['MoneyField']> = {
  centAmount?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MoneyType'] = ResolversParentTypes['MoneyType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MultiBuyCustomLineItemsTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiBuyCustomLineItemsTarget'] = ResolversParentTypes['MultiBuyCustomLineItemsTarget']> = {
  discountedQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  maxOccurrence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  selectionMode?: Resolver<ResolversTypes['SelectionMode'], ParentType, ContextType>;
  triggerQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MultiBuyLineItemsTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiBuyLineItemsTarget'] = ResolversParentTypes['MultiBuyLineItemsTarget']> = {
  discountedQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  maxOccurrence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  selectionMode?: Resolver<ResolversTypes['SelectionMode'], ParentType, ContextType>;
  triggerQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  createApiClient?: Resolver<Maybe<ResolversTypes['APIClientWithSecret']>, ParentType, ContextType, RequireFields<MutationCreateApiClientArgs, 'draft'>>;
  createApprovalRule?: Resolver<Maybe<ResolversTypes['ApprovalRule']>, ParentType, ContextType, RequireFields<MutationCreateApprovalRuleArgs, 'asAssociate' | 'draft'>>;
  createAssociateRole?: Resolver<Maybe<ResolversTypes['AssociateRole']>, ParentType, ContextType, RequireFields<MutationCreateAssociateRoleArgs, 'draft'>>;
  createAttributeGroup?: Resolver<Maybe<ResolversTypes['AttributeGroup']>, ParentType, ContextType, RequireFields<MutationCreateAttributeGroupArgs, 'draft'>>;
  createBusinessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, RequireFields<MutationCreateBusinessUnitArgs, 'draft'>>;
  createCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationCreateCartArgs, 'draft'>>;
  createCartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, RequireFields<MutationCreateCartDiscountArgs, 'draft'>>;
  createCategory?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, RequireFields<MutationCreateCategoryArgs, 'draft'>>;
  createChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationCreateChannelArgs, 'draft'>>;
  createCustomerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, RequireFields<MutationCreateCustomerGroupArgs, 'draft'>>;
  createDiscountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType, RequireFields<MutationCreateDiscountCodeArgs, 'draft'>>;
  createExtension?: Resolver<Maybe<ResolversTypes['Extension']>, ParentType, ContextType, RequireFields<MutationCreateExtensionArgs, 'draft'>>;
  createInventoryEntry?: Resolver<Maybe<ResolversTypes['InventoryEntry']>, ParentType, ContextType, RequireFields<MutationCreateInventoryEntryArgs, 'draft'>>;
  createMyBusinessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, RequireFields<MutationCreateMyBusinessUnitArgs, 'draft'>>;
  createMyCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationCreateMyCartArgs, 'draft'>>;
  createMyOrderFromCart?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationCreateMyOrderFromCartArgs, 'draft'>>;
  createMyOrderFromQuote?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationCreateMyOrderFromQuoteArgs, 'draft'>>;
  createMyPayment?: Resolver<Maybe<ResolversTypes['MyPayment']>, ParentType, ContextType, RequireFields<MutationCreateMyPaymentArgs, 'draft'>>;
  createMyQuoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, RequireFields<MutationCreateMyQuoteRequestArgs, 'draft'>>;
  createMyShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationCreateMyShoppingListArgs, 'draft'>>;
  createOrUpdateCustomObject?: Resolver<Maybe<ResolversTypes['CustomObject']>, ParentType, ContextType, RequireFields<MutationCreateOrUpdateCustomObjectArgs, 'draft'>>;
  createOrderEdit?: Resolver<Maybe<ResolversTypes['OrderEdit']>, ParentType, ContextType, RequireFields<MutationCreateOrderEditArgs, 'draft'>>;
  createOrderFromCart?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationCreateOrderFromCartArgs, 'draft'>>;
  createOrderFromQuote?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationCreateOrderFromQuoteArgs, 'draft'>>;
  createPayment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<MutationCreatePaymentArgs, 'draft'>>;
  createProduct?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<MutationCreateProductArgs, 'draft'>>;
  createProductDiscount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType, RequireFields<MutationCreateProductDiscountArgs, 'draft'>>;
  createProductSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType, RequireFields<MutationCreateProductSelectionArgs, 'draft'>>;
  createProductType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType, RequireFields<MutationCreateProductTypeArgs, 'draft'>>;
  createQuote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<MutationCreateQuoteArgs, 'draft'>>;
  createQuoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, RequireFields<MutationCreateQuoteRequestArgs, 'draft'>>;
  createReview?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<MutationCreateReviewArgs, 'draft'>>;
  createShippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<MutationCreateShippingMethodArgs, 'draft'>>;
  createShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationCreateShoppingListArgs, 'draft'>>;
  createStagedQuote?: Resolver<Maybe<ResolversTypes['StagedQuote']>, ParentType, ContextType, RequireFields<MutationCreateStagedQuoteArgs, 'draft'>>;
  createStandalonePrice?: Resolver<Maybe<ResolversTypes['StandalonePrice']>, ParentType, ContextType, RequireFields<MutationCreateStandalonePriceArgs, 'draft'>>;
  createState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, RequireFields<MutationCreateStateArgs, 'draft'>>;
  createStore?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType, RequireFields<MutationCreateStoreArgs, 'draft'>>;
  createSubscription?: Resolver<Maybe<ResolversTypes['CommercetoolsSubscription']>, ParentType, ContextType, RequireFields<MutationCreateSubscriptionArgs, 'draft'>>;
  createTaxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, RequireFields<MutationCreateTaxCategoryArgs, 'draft'>>;
  createTypeDefinition?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType, RequireFields<MutationCreateTypeDefinitionArgs, 'draft'>>;
  createZone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, RequireFields<MutationCreateZoneArgs, 'draft'>>;
  customerChangeMyPassword?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerChangeMyPasswordArgs, 'currentPassword' | 'newPassword' | 'version'>>;
  customerChangePassword?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerChangePasswordArgs, 'currentPassword' | 'id' | 'newPassword' | 'version'>>;
  customerConfirmEmail?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerConfirmEmailArgs, 'tokenValue'>>;
  customerConfirmMyEmail?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerConfirmMyEmailArgs, 'tokenValue'>>;
  customerCreateEmailVerificationToken?: Resolver<ResolversTypes['CustomerEmailToken'], ParentType, ContextType, RequireFields<MutationCustomerCreateEmailVerificationTokenArgs, 'id' | 'ttlMinutes'>>;
  customerCreatePasswordResetToken?: Resolver<Maybe<ResolversTypes['CustomerPasswordToken']>, ParentType, ContextType, RequireFields<MutationCustomerCreatePasswordResetTokenArgs, 'email'>>;
  customerResetMyPassword?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerResetMyPasswordArgs, 'newPassword' | 'tokenValue'>>;
  customerResetPassword?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationCustomerResetPasswordArgs, 'newPassword' | 'tokenValue'>>;
  customerSignIn?: Resolver<ResolversTypes['CustomerSignInResult'], ParentType, ContextType, RequireFields<MutationCustomerSignInArgs, 'draft'>>;
  customerSignMeIn?: Resolver<ResolversTypes['CustomerSignInResult'], ParentType, ContextType, RequireFields<MutationCustomerSignMeInArgs, 'draft'>>;
  customerSignMeUp?: Resolver<ResolversTypes['CustomerSignInResult'], ParentType, ContextType, RequireFields<MutationCustomerSignMeUpArgs, 'draft'>>;
  customerSignUp?: Resolver<ResolversTypes['CustomerSignInResult'], ParentType, ContextType, RequireFields<MutationCustomerSignUpArgs, 'draft'>>;
  deleteApiClient?: Resolver<Maybe<ResolversTypes['APIClientWithoutSecret']>, ParentType, ContextType, RequireFields<MutationDeleteApiClientArgs, 'id'>>;
  deleteAssociateRole?: Resolver<Maybe<ResolversTypes['AssociateRole']>, ParentType, ContextType, RequireFields<MutationDeleteAssociateRoleArgs, 'personalDataErasure' | 'version'>>;
  deleteAttributeGroup?: Resolver<Maybe<ResolversTypes['AttributeGroup']>, ParentType, ContextType, RequireFields<MutationDeleteAttributeGroupArgs, 'version'>>;
  deleteBusinessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, RequireFields<MutationDeleteBusinessUnitArgs, 'personalDataErasure' | 'version'>>;
  deleteCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationDeleteCartArgs, 'personalDataErasure' | 'version'>>;
  deleteCartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, RequireFields<MutationDeleteCartDiscountArgs, 'version'>>;
  deleteCategory?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, RequireFields<MutationDeleteCategoryArgs, 'version'>>;
  deleteChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationDeleteChannelArgs, 'id' | 'version'>>;
  deleteCustomObject?: Resolver<Maybe<ResolversTypes['CustomObject']>, ParentType, ContextType, RequireFields<MutationDeleteCustomObjectArgs, 'personalDataErasure'>>;
  deleteCustomer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationDeleteCustomerArgs, 'personalDataErasure' | 'version'>>;
  deleteCustomerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, RequireFields<MutationDeleteCustomerGroupArgs, 'version'>>;
  deleteDiscountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType, RequireFields<MutationDeleteDiscountCodeArgs, 'id' | 'version'>>;
  deleteExtension?: Resolver<Maybe<ResolversTypes['Extension']>, ParentType, ContextType, RequireFields<MutationDeleteExtensionArgs, 'version'>>;
  deleteInventoryEntry?: Resolver<Maybe<ResolversTypes['InventoryEntry']>, ParentType, ContextType, RequireFields<MutationDeleteInventoryEntryArgs, 'version'>>;
  deleteMyCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationDeleteMyCartArgs, 'id' | 'version'>>;
  deleteMyCustomer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationDeleteMyCustomerArgs, 'personalDataErasure' | 'version'>>;
  deleteMyPayment?: Resolver<Maybe<ResolversTypes['MyPayment']>, ParentType, ContextType, RequireFields<MutationDeleteMyPaymentArgs, 'id' | 'version'>>;
  deleteMyShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationDeleteMyShoppingListArgs, 'version'>>;
  deleteOrder?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationDeleteOrderArgs, 'personalDataErasure' | 'version'>>;
  deleteOrderEdit?: Resolver<Maybe<ResolversTypes['OrderEdit']>, ParentType, ContextType, RequireFields<MutationDeleteOrderEditArgs, 'version'>>;
  deletePayment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<MutationDeletePaymentArgs, 'personalDataErasure' | 'version'>>;
  deleteProduct?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<MutationDeleteProductArgs, 'version'>>;
  deleteProductDiscount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType, RequireFields<MutationDeleteProductDiscountArgs, 'version'>>;
  deleteProductSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType, RequireFields<MutationDeleteProductSelectionArgs, 'version'>>;
  deleteProductType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType, RequireFields<MutationDeleteProductTypeArgs, 'version'>>;
  deleteQuote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<MutationDeleteQuoteArgs, 'personalDataErasure' | 'version'>>;
  deleteQuoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, RequireFields<MutationDeleteQuoteRequestArgs, 'personalDataErasure' | 'version'>>;
  deleteReview?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<MutationDeleteReviewArgs, 'personalDataErasure' | 'version'>>;
  deleteShippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<MutationDeleteShippingMethodArgs, 'version'>>;
  deleteShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationDeleteShoppingListArgs, 'personalDataErasure' | 'version'>>;
  deleteStagedQuote?: Resolver<Maybe<ResolversTypes['StagedQuote']>, ParentType, ContextType, RequireFields<MutationDeleteStagedQuoteArgs, 'personalDataErasure' | 'version'>>;
  deleteStandalonePrice?: Resolver<Maybe<ResolversTypes['StandalonePrice']>, ParentType, ContextType, RequireFields<MutationDeleteStandalonePriceArgs, 'version'>>;
  deleteState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, RequireFields<MutationDeleteStateArgs, 'version'>>;
  deleteStore?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType, RequireFields<MutationDeleteStoreArgs, 'version'>>;
  deleteSubscription?: Resolver<Maybe<ResolversTypes['CommercetoolsSubscription']>, ParentType, ContextType, RequireFields<MutationDeleteSubscriptionArgs, 'version'>>;
  deleteTaxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, RequireFields<MutationDeleteTaxCategoryArgs, 'version'>>;
  deleteTypeDefinition?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType, RequireFields<MutationDeleteTypeDefinitionArgs, 'version'>>;
  deleteZone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, RequireFields<MutationDeleteZoneArgs, 'version'>>;
  importOrder?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationImportOrderArgs, 'draft'>>;
  replicateCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationReplicateCartArgs, 'reference'>>;
  replicateMyCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationReplicateMyCartArgs, 'reference'>>;
  signUpInMyBusinessUnit?: Resolver<ResolversTypes['CustomerSignInResult'], ParentType, ContextType, RequireFields<MutationSignUpInMyBusinessUnitArgs, 'draft'>>;
  updateApprovalFlow?: Resolver<Maybe<ResolversTypes['ApprovalFlow']>, ParentType, ContextType, RequireFields<MutationUpdateApprovalFlowArgs, 'actions' | 'asAssociate' | 'id' | 'version'>>;
  updateApprovalRule?: Resolver<Maybe<ResolversTypes['ApprovalRule']>, ParentType, ContextType, RequireFields<MutationUpdateApprovalRuleArgs, 'actions' | 'asAssociate' | 'version'>>;
  updateAssociateRole?: Resolver<Maybe<ResolversTypes['AssociateRole']>, ParentType, ContextType, RequireFields<MutationUpdateAssociateRoleArgs, 'actions' | 'version'>>;
  updateAttributeGroup?: Resolver<Maybe<ResolversTypes['AttributeGroup']>, ParentType, ContextType, RequireFields<MutationUpdateAttributeGroupArgs, 'actions' | 'version'>>;
  updateBusinessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, RequireFields<MutationUpdateBusinessUnitArgs, 'actions' | 'version'>>;
  updateCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationUpdateCartArgs, 'actions' | 'version'>>;
  updateCartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, RequireFields<MutationUpdateCartDiscountArgs, 'actions' | 'version'>>;
  updateCategory?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, RequireFields<MutationUpdateCategoryArgs, 'actions' | 'version'>>;
  updateChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, RequireFields<MutationUpdateChannelArgs, 'actions' | 'id' | 'version'>>;
  updateCustomer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationUpdateCustomerArgs, 'actions' | 'version'>>;
  updateCustomerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, RequireFields<MutationUpdateCustomerGroupArgs, 'actions' | 'version'>>;
  updateDiscountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType, RequireFields<MutationUpdateDiscountCodeArgs, 'actions' | 'id' | 'version'>>;
  updateExtension?: Resolver<Maybe<ResolversTypes['Extension']>, ParentType, ContextType, RequireFields<MutationUpdateExtensionArgs, 'actions' | 'version'>>;
  updateInventoryEntry?: Resolver<Maybe<ResolversTypes['InventoryEntry']>, ParentType, ContextType, RequireFields<MutationUpdateInventoryEntryArgs, 'actions' | 'version'>>;
  updateMyBusinessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, RequireFields<MutationUpdateMyBusinessUnitArgs, 'actions' | 'version'>>;
  updateMyCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<MutationUpdateMyCartArgs, 'actions' | 'id' | 'version'>>;
  updateMyCustomer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, RequireFields<MutationUpdateMyCustomerArgs, 'actions' | 'version'>>;
  updateMyPayment?: Resolver<Maybe<ResolversTypes['MyPayment']>, ParentType, ContextType, RequireFields<MutationUpdateMyPaymentArgs, 'actions' | 'id' | 'version'>>;
  updateMyQuote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<MutationUpdateMyQuoteArgs, 'actions' | 'version'>>;
  updateMyQuoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, RequireFields<MutationUpdateMyQuoteRequestArgs, 'actions' | 'version'>>;
  updateMyShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationUpdateMyShoppingListArgs, 'actions' | 'version'>>;
  updateOrder?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<MutationUpdateOrderArgs, 'actions' | 'version'>>;
  updateOrderEdit?: Resolver<Maybe<ResolversTypes['OrderEdit']>, ParentType, ContextType, RequireFields<MutationUpdateOrderEditArgs, 'actions' | 'dryRun' | 'version'>>;
  updatePayment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<MutationUpdatePaymentArgs, 'actions' | 'version'>>;
  updateProduct?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<MutationUpdateProductArgs, 'actions' | 'version'>>;
  updateProductDiscount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType, RequireFields<MutationUpdateProductDiscountArgs, 'actions' | 'version'>>;
  updateProductSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType, RequireFields<MutationUpdateProductSelectionArgs, 'actions' | 'version'>>;
  updateProductType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType, RequireFields<MutationUpdateProductTypeArgs, 'actions' | 'version'>>;
  updateProject?: Resolver<Maybe<ResolversTypes['ProjectProjection']>, ParentType, ContextType, RequireFields<MutationUpdateProjectArgs, 'actions' | 'version'>>;
  updateQuote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, RequireFields<MutationUpdateQuoteArgs, 'actions' | 'version'>>;
  updateQuoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, RequireFields<MutationUpdateQuoteRequestArgs, 'actions' | 'version'>>;
  updateReview?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<MutationUpdateReviewArgs, 'actions' | 'version'>>;
  updateShippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<MutationUpdateShippingMethodArgs, 'actions' | 'version'>>;
  updateShoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, RequireFields<MutationUpdateShoppingListArgs, 'actions' | 'version'>>;
  updateStagedQuote?: Resolver<Maybe<ResolversTypes['StagedQuote']>, ParentType, ContextType, RequireFields<MutationUpdateStagedQuoteArgs, 'actions' | 'version'>>;
  updateStandalonePrice?: Resolver<Maybe<ResolversTypes['StandalonePrice']>, ParentType, ContextType, RequireFields<MutationUpdateStandalonePriceArgs, 'actions' | 'version'>>;
  updateState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, RequireFields<MutationUpdateStateArgs, 'actions' | 'version'>>;
  updateStore?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType, RequireFields<MutationUpdateStoreArgs, 'actions' | 'version'>>;
  updateSubscription?: Resolver<Maybe<ResolversTypes['CommercetoolsSubscription']>, ParentType, ContextType, RequireFields<MutationUpdateSubscriptionArgs, 'actions' | 'version'>>;
  updateTaxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, RequireFields<MutationUpdateTaxCategoryArgs, 'actions' | 'version'>>;
  updateTypeDefinition?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType, RequireFields<MutationUpdateTypeDefinitionArgs, 'actions' | 'version'>>;
  updateZone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, RequireFields<MutationUpdateZoneArgs, 'actions' | 'version'>>;
};

export type MyPaymentResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyPayment'] = ResolversParentTypes['MyPayment']> = {
  amountPlanned?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  paymentMethodInfo?: Resolver<ResolversTypes['PaymentMethodInfo'], ParentType, ContextType>;
  transactions?: Resolver<Array<ResolversTypes['Transaction']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MyPaymentQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyPaymentQueryResult'] = ResolversParentTypes['MyPaymentQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['MyPayment']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NestedAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NestedAttributeDefinitionType'] = ResolversParentTypes['NestedAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotProcessedResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotProcessed'] = ResolversParentTypes['NotProcessed']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationFormatResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationFormat'] = ResolversParentTypes['NotificationFormat']> = {
  __resolveType: TypeResolveFn<'CloudEventsSubscriptionsFormat' | 'PlatformFormat', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type NumberAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NumberAttribute'] = ResolversParentTypes['NumberAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NumberAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NumberAttributeDefinitionType'] = ResolversParentTypes['NumberAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NumberFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['NumberField'] = ResolversParentTypes['NumberField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BigDecimal'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NumberTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NumberType'] = ResolversParentTypes['NumberType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Order'] = ResolversParentTypes['Order']> = {
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  businessUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  cartRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  completedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customLineItems?: Resolver<Array<ResolversTypes['CustomLineItem']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  customerId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  directDiscounts?: Resolver<Array<ResolversTypes['DirectDiscount']>, ParentType, ContextType>;
  discountCodes?: Resolver<Array<ResolversTypes['DiscountCodeInfo']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inventoryMode?: Resolver<ResolversTypes['InventoryMode'], ParentType, ContextType>;
  itemShippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  lastMessageSequenceNumber?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lineItems?: Resolver<Array<ResolversTypes['LineItem']>, ParentType, ContextType, Partial<OrderLineItemsArgs>>;
  locale?: Resolver<Maybe<ResolversTypes['Locale']>, ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderState?: Resolver<ResolversTypes['OrderState'], ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['CartOrigin'], ParentType, ContextType>;
  paymentInfo?: Resolver<Maybe<ResolversTypes['PaymentInfo']>, ParentType, ContextType>;
  paymentState?: Resolver<Maybe<ResolversTypes['PaymentState']>, ParentType, ContextType>;
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType>;
  quoteRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  refusedGifts?: Resolver<Array<ResolversTypes['CartDiscount']>, ParentType, ContextType>;
  refusedGiftsRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  returnInfo?: Resolver<Array<ResolversTypes['ReturnInfo']>, ParentType, ContextType>;
  shipmentState?: Resolver<Maybe<ResolversTypes['ShipmentState']>, ParentType, ContextType>;
  shipping?: Resolver<Array<ResolversTypes['Shipping']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingCustomFields?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingMode?: Resolver<ResolversTypes['ShippingMode'], ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  syncInfo?: Resolver<Array<ResolversTypes['SyncInfo']>, ParentType, ContextType>;
  taxCalculationMode?: Resolver<ResolversTypes['TaxCalculationMode'], ParentType, ContextType>;
  taxMode?: Resolver<ResolversTypes['TaxMode'], ParentType, ContextType>;
  taxRoundingMode?: Resolver<ResolversTypes['RoundingMode'], ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  taxedShippingPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderBillingAddressSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderBillingAddressSet'] = ResolversParentTypes['OrderBillingAddressSet']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  oldAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCreated'] = ResolversParentTypes['OrderCreated']> = {
  order?: Resolver<ResolversTypes['Order'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomFieldAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomFieldAdded'] = ResolversParentTypes['OrderCustomFieldAdded']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomFieldChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomFieldChanged'] = ResolversParentTypes['OrderCustomFieldChanged']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  previousValue?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomFieldRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomFieldRemoved'] = ResolversParentTypes['OrderCustomFieldRemoved']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomLineItemAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomLineItemAdded'] = ResolversParentTypes['OrderCustomLineItemAdded']> = {
  customLineItem?: Resolver<ResolversTypes['CustomLineItem'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomLineItemDiscountSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomLineItemDiscountSet'] = ResolversParentTypes['OrderCustomLineItemDiscountSet']> = {
  customLineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discountedPricePerQuantity?: Resolver<Array<ResolversTypes['DiscountedLineItemPriceForQuantity']>, ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomLineItemQuantityChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomLineItemQuantityChanged'] = ResolversParentTypes['OrderCustomLineItemQuantityChanged']> = {
  customLineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oldQuantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomLineItemRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomLineItemRemoved'] = ResolversParentTypes['OrderCustomLineItemRemoved']> = {
  customLineItem?: Resolver<Maybe<ResolversTypes['CustomLineItem']>, ParentType, ContextType>;
  customLineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomTypeRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomTypeRemoved'] = ResolversParentTypes['OrderCustomTypeRemoved']> = {
  previousTypeId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomTypeSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomTypeSet'] = ResolversParentTypes['OrderCustomTypeSet']> = {
  customFields?: Resolver<ResolversTypes['CustomFieldsType'], ParentType, ContextType>;
  previousTypeId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomerEmailSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomerEmailSet'] = ResolversParentTypes['OrderCustomerEmailSet']> = {
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oldEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomerGroupSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomerGroupSet'] = ResolversParentTypes['OrderCustomerGroupSet']> = {
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  oldCustomerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  oldCustomerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCustomerSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCustomerSet'] = ResolversParentTypes['OrderCustomerSet']> = {
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  oldCustomer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  oldCustomerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  oldCustomerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  oldCustomerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDeleted'] = ResolversParentTypes['OrderDeleted']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountCodeAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountCodeAdded'] = ResolversParentTypes['OrderDiscountCodeAdded']> = {
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  discountCodeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountCodeRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountCodeRemoved'] = ResolversParentTypes['OrderDiscountCodeRemoved']> = {
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  discountCodeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountCodeStateSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountCodeStateSet'] = ResolversParentTypes['OrderDiscountCodeStateSet']> = {
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  discountCodeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  oldState?: Resolver<Maybe<ResolversTypes['DiscountCodeState']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['DiscountCodeState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEdit'] = ResolversParentTypes['OrderEdit']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  resource?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  resourceRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  result?: Resolver<ResolversTypes['OrderEditResult'], ParentType, ContextType>;
  stagedActions?: Resolver<Array<ResolversTypes['StagedOrderUpdateActionOutput']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditAppliedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEditApplied'] = ResolversParentTypes['OrderEditApplied']> = {
  edit?: Resolver<Maybe<ResolversTypes['OrderEdit']>, ParentType, ContextType>;
  editRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  result?: Resolver<ResolversTypes['Applied'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEditLimitWithCurrent'] = ResolversParentTypes['OrderEditLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEditLimitsProjection'] = ResolversParentTypes['OrderEditLimitsProjection']> = {
  total?: Resolver<ResolversTypes['OrderEditLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEditQueryResult'] = ResolversParentTypes['OrderEditQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['OrderEdit']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEditResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEditResult'] = ResolversParentTypes['OrderEditResult']> = {
  __resolveType: TypeResolveFn<'Applied' | 'NotProcessed' | 'PreviewFailure' | 'PreviewSuccess', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type OrderExcerptResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderExcerpt'] = ResolversParentTypes['OrderExcerpt']> = {
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderImportedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderImported'] = ResolversParentTypes['OrderImported']> = {
  order?: Resolver<ResolversTypes['Order'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineItemAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineItemAdded'] = ResolversParentTypes['OrderLineItemAdded']> = {
  addedQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  lineItem?: Resolver<ResolversTypes['LineItem'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineItemDiscountSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineItemDiscountSet'] = ResolversParentTypes['OrderLineItemDiscountSet']> = {
  discountedPricePerQuantity?: Resolver<Array<ResolversTypes['DiscountedLineItemPriceForQuantity']>, ParentType, ContextType>;
  lineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  taxedPricePortions?: Resolver<Array<ResolversTypes['MethodTaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineItemDistributionChannelSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineItemDistributionChannelSet'] = ResolversParentTypes['OrderLineItemDistributionChannelSet']> = {
  distributionChannel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  distributionChannelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  lineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineItemRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineItemRemoved'] = ResolversParentTypes['OrderLineItemRemoved']> = {
  lineItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  newPrice?: Resolver<Maybe<ResolversTypes['ProductPrice']>, ParentType, ContextType>;
  newQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  newShippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetails']>, ParentType, ContextType>;
  newState?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  newTaxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  newTotalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  removedQuantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderMessagePayload'] = ResolversParentTypes['OrderMessagePayload']> = {
  __resolveType: TypeResolveFn<'CustomLineItemStateTransition' | 'DeliveryAdded' | 'DeliveryAddressSet' | 'DeliveryItemsUpdated' | 'DeliveryRemoved' | 'LineItemStateTransition' | 'OrderBillingAddressSet' | 'OrderCreated' | 'OrderCustomFieldAdded' | 'OrderCustomFieldChanged' | 'OrderCustomFieldRemoved' | 'OrderCustomLineItemAdded' | 'OrderCustomLineItemDiscountSet' | 'OrderCustomLineItemQuantityChanged' | 'OrderCustomLineItemRemoved' | 'OrderCustomTypeRemoved' | 'OrderCustomTypeSet' | 'OrderCustomerEmailSet' | 'OrderCustomerGroupSet' | 'OrderCustomerSet' | 'OrderDeleted' | 'OrderDiscountCodeAdded' | 'OrderDiscountCodeRemoved' | 'OrderDiscountCodeStateSet' | 'OrderEditApplied' | 'OrderImported' | 'OrderLineItemAdded' | 'OrderLineItemDiscountSet' | 'OrderLineItemDistributionChannelSet' | 'OrderLineItemRemoved' | 'OrderPaymentAdded' | 'OrderPaymentRemoved' | 'OrderPaymentStateChanged' | 'OrderReturnShipmentStateChanged' | 'OrderShipmentStateChanged' | 'OrderShippingAddressSet' | 'OrderShippingInfoSet' | 'OrderShippingRateInputSet' | 'OrderStateChanged' | 'OrderStateTransition' | 'OrderStoreSet' | 'ParcelAddedToDelivery' | 'ParcelItemsUpdated' | 'ParcelMeasurementsUpdated' | 'ParcelRemovedFromDelivery' | 'ParcelTrackingDataUpdated' | 'PurchaseOrderNumberSet' | 'ReturnInfoAdded' | 'ReturnInfoSet', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type OrderPaymentAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderPaymentAdded'] = ResolversParentTypes['OrderPaymentAdded']> = {
  paymentRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderPaymentRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderPaymentRemoved'] = ResolversParentTypes['OrderPaymentRemoved']> = {
  paymentRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  removedPaymentInfo?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderPaymentStateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderPaymentStateChanged'] = ResolversParentTypes['OrderPaymentStateChanged']> = {
  oldPaymentState?: Resolver<Maybe<ResolversTypes['PaymentState']>, ParentType, ContextType>;
  paymentState?: Resolver<ResolversTypes['PaymentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderQueryInterface'] = ResolversParentTypes['OrderQueryInterface']> = {
  __resolveType: TypeResolveFn<'AsAssociate' | 'InStore' | 'InStoreMe' | 'Me' | 'Query', ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<OrderQueryInterfaceOrderArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<OrderQueryInterfaceOrdersArgs>>;
};

export type OrderQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderQueryResult'] = ResolversParentTypes['OrderQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Order']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderReturnShipmentStateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderReturnShipmentStateChanged'] = ResolversParentTypes['OrderReturnShipmentStateChanged']> = {
  returnItemId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  returnShipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderSearchConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderSearchConfiguration'] = ResolversParentTypes['OrderSearchConfiguration']> = {
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['OrderSearchStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderShipmentStateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderShipmentStateChanged'] = ResolversParentTypes['OrderShipmentStateChanged']> = {
  oldShipmentState?: Resolver<Maybe<ResolversTypes['ShipmentState']>, ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderShippingAddressSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderShippingAddressSet'] = ResolversParentTypes['OrderShippingAddressSet']> = {
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  oldAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderShippingInfoSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderShippingInfoSet'] = ResolversParentTypes['OrderShippingInfoSet']> = {
  oldShippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderShippingRateInputSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderShippingRateInputSet'] = ResolversParentTypes['OrderShippingRateInputSet']> = {
  oldShippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderStateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderStateChanged'] = ResolversParentTypes['OrderStateChanged']> = {
  oldOrderState?: Resolver<Maybe<ResolversTypes['OrderState']>, ParentType, ContextType>;
  orderId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  orderState?: Resolver<ResolversTypes['OrderState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderStateTransition'] = ResolversParentTypes['OrderStateTransition']> = {
  force?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oldState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  oldStateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderStoreSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderStoreSet'] = ResolversParentTypes['OrderStoreSet']> = {
  oldStore?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  oldStoreRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Parcel'] = ResolversParentTypes['Parcel']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  measurements?: Resolver<Maybe<ResolversTypes['ParcelMeasurements']>, ParentType, ContextType>;
  trackingData?: Resolver<Maybe<ResolversTypes['TrackingData']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelAddedToDeliveryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelAddedToDelivery'] = ResolversParentTypes['ParcelAddedToDelivery']> = {
  delivery?: Resolver<ResolversTypes['Delivery'], ParentType, ContextType>;
  parcel?: Resolver<ResolversTypes['Parcel'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelData'] = ResolversParentTypes['ParcelData']> = {
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  measurements?: Resolver<Maybe<ResolversTypes['ParcelMeasurements']>, ParentType, ContextType>;
  trackingData?: Resolver<Maybe<ResolversTypes['TrackingData']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelItemsUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelItemsUpdated'] = ResolversParentTypes['ParcelItemsUpdated']> = {
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  oldItems?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  parcelId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelMeasurementsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelMeasurements'] = ResolversParentTypes['ParcelMeasurements']> = {
  heightInMillimeter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lengthInMillimeter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  weightInGram?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  widthInMillimeter?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelMeasurementsUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelMeasurementsUpdated'] = ResolversParentTypes['ParcelMeasurementsUpdated']> = {
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  measurements?: Resolver<Maybe<ResolversTypes['ParcelMeasurements']>, ParentType, ContextType>;
  parcelId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelRemovedFromDeliveryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelRemovedFromDelivery'] = ResolversParentTypes['ParcelRemovedFromDelivery']> = {
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parcel?: Resolver<ResolversTypes['Parcel'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ParcelTrackingDataUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ParcelTrackingDataUpdated'] = ResolversParentTypes['ParcelTrackingDataUpdated']> = {
  deliveryId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parcelId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingData?: Resolver<Maybe<ResolversTypes['TrackingData']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Payment'] = ResolversParentTypes['Payment']> = {
  amountPlanned?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  interfaceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  interfaceInteractionsRaw?: Resolver<ResolversTypes['InterfaceInteractionsRawResult'], ParentType, ContextType, Partial<PaymentInterfaceInteractionsRawArgs>>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  paymentMethodInfo?: Resolver<ResolversTypes['PaymentMethodInfo'], ParentType, ContextType>;
  paymentStatus?: Resolver<ResolversTypes['PaymentStatus'], ParentType, ContextType>;
  transactions?: Resolver<Array<ResolversTypes['Transaction']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCreated'] = ResolversParentTypes['PaymentCreated']> = {
  payment?: Resolver<ResolversTypes['Payment'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentInfo'] = ResolversParentTypes['PaymentInfo']> = {
  paymentRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  payments?: Resolver<Array<ResolversTypes['Payment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentInteractionAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentInteractionAdded'] = ResolversParentTypes['PaymentInteractionAdded']> = {
  interaction?: Resolver<ResolversTypes['CustomFieldsType'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentMethodInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentMethodInfo'] = ResolversParentTypes['PaymentMethodInfo']> = {
  method?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<PaymentMethodInfoNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  paymentInterface?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentQueryResult'] = ResolversParentTypes['PaymentQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Payment']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentStatusResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentStatus'] = ResolversParentTypes['PaymentStatus']> = {
  interfaceCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  interfaceText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentStatusInterfaceCodeSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentStatusInterfaceCodeSet'] = ResolversParentTypes['PaymentStatusInterfaceCodeSet']> = {
  interfaceCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentStatusStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentStatusStateTransition'] = ResolversParentTypes['PaymentStatusStateTransition']> = {
  force?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentTransactionAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentTransactionAdded'] = ResolversParentTypes['PaymentTransactionAdded']> = {
  transaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentTransactionStateChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentTransactionStateChanged'] = ResolversParentTypes['PaymentTransactionStateChanged']> = {
  state?: Resolver<ResolversTypes['TransactionState'], ParentType, ContextType>;
  transactionId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlainEnumValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['PlainEnumValue'] = ResolversParentTypes['PlainEnumValue']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlainEnumValueResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['PlainEnumValueResult'] = ResolversParentTypes['PlainEnumValueResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['PlainEnumValue']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlatformFormatResolvers<ContextType = any, ParentType extends ResolversParentTypes['PlatformFormat'] = ResolversParentTypes['PlatformFormat']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PointResolvers<ContextType = any, ParentType extends ResolversParentTypes['Point'] = ResolversParentTypes['Point']> = {
  coordinates?: Resolver<Array<ResolversTypes['Float']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewFailureResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewFailure'] = ResolversParentTypes['PreviewFailure']> = {
  errors?: Resolver<Array<ResolversTypes['Json']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreviewSuccessResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreviewSuccess'] = ResolversParentTypes['PreviewSuccess']> = {
  messagePayloads?: Resolver<Array<ResolversTypes['OrderMessagePayload']>, ParentType, ContextType>;
  preview?: Resolver<ResolversTypes['Order'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PriceFunctionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PriceFunction'] = ResolversParentTypes['PriceFunction']> = {
  currencyCode?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  function?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductResolvers<ContextType = any, ParentType extends ResolversParentTypes['Product'] = ResolversParentTypes['Product']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  masterData?: Resolver<ResolversTypes['ProductCatalogData'], ParentType, ContextType>;
  priceMode?: Resolver<Maybe<ResolversTypes['PriceMode']>, ParentType, ContextType>;
  productSelectionRefs?: Resolver<ResolversTypes['SelectionOfProductQueryResult'], ParentType, ContextType, Partial<ProductProductSelectionRefsArgs>>;
  productType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType>;
  productTypeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  reviewRatingStatistics?: Resolver<Maybe<ResolversTypes['ReviewRatingStatistics']>, ParentType, ContextType>;
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAddedToCategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAddedToCategory'] = ResolversParentTypes['ProductAddedToCategory']> = {
  category?: Resolver<ResolversTypes['ReferenceId'], ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAssignment'] = ResolversParentTypes['ProductAssignment']> = {
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  productSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType>;
  productSelectionRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  variantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  variantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAssignmentQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAssignmentQueryResult'] = ResolversParentTypes['ProductAssignmentQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductAssignment']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCatalogDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCatalogData'] = ResolversParentTypes['ProductCatalogData']> = {
  current?: Resolver<Maybe<ResolversTypes['ProductData']>, ParentType, ContextType>;
  hasStagedChanges?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  published?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  staged?: Resolver<Maybe<ResolversTypes['ProductData']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCreated'] = ResolversParentTypes['ProductCreated']> = {
  productProjection?: Resolver<ResolversTypes['ProductProjectionMessagePayload'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductData'] = ResolversParentTypes['ProductData']> = {
  allVariants?: Resolver<Array<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductDataAllVariantsArgs>>;
  categories?: Resolver<Array<ResolversTypes['Category']>, ParentType, ContextType>;
  categoriesRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  categoryOrderHint?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductDataCategoryOrderHintArgs, 'categoryId'>>;
  categoryOrderHints?: Resolver<Array<ResolversTypes['CategoryOrderHint']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  masterVariant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataMetaDescriptionArgs>>;
  metaDescriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataMetaKeywordsArgs>>;
  metaKeywordsAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataMetaTitleArgs>>;
  metaTitleAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  searchKeyword?: Resolver<Maybe<Array<ResolversTypes['SearchKeyword']>>, ParentType, ContextType, RequireFields<ProductDataSearchKeywordArgs, 'locale'>>;
  searchKeywords?: Resolver<Array<ResolversTypes['SearchKeywords']>, ParentType, ContextType>;
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDataSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductDataVariantArgs>>;
  variants?: Resolver<Array<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductDataVariantsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDeleted'] = ResolversParentTypes['ProductDeleted']> = {
  currentProjection?: Resolver<Maybe<ResolversTypes['ProductProjectionMessagePayload']>, ParentType, ContextType>;
  removedImageUrls?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDiscountResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDiscount'] = ResolversParentTypes['ProductDiscount']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDiscountDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductDiscountNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  predicate?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referenceRefs?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  sortOrder?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['ProductDiscountValue'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDiscountLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDiscountLimitWithCurrent'] = ResolversParentTypes['ProductDiscountLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDiscountLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDiscountLimitsProjection'] = ResolversParentTypes['ProductDiscountLimitsProjection']> = {
  totalActive?: Resolver<ResolversTypes['ProductDiscountLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDiscountQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDiscountQueryResult'] = ResolversParentTypes['ProductDiscountQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductDiscount']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDiscountValue'] = ResolversParentTypes['ProductDiscountValue']> = {
  __resolveType: TypeResolveFn<'AbsoluteDiscountValue' | 'ExternalDiscountValue' | 'RelativeDiscountValue', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ProductImageAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductImageAdded'] = ResolversParentTypes['ProductImageAdded']> = {
  image?: Resolver<ResolversTypes['Image'], ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductLimitsProjection'] = ResolversParentTypes['ProductLimitsProjection']> = {
  pricesPerVariant?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  variants?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductOfSelectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductOfSelection'] = ResolversParentTypes['ProductOfSelection']> = {
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  variantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  variantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductOfSelectionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductOfSelectionQueryResult'] = ResolversParentTypes['ProductOfSelectionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductOfSelection']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPrice'] = ResolversParentTypes['ProductPrice']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tiers?: Resolver<Maybe<Array<ResolversTypes['ProductPriceTier']>>, ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceAdded'] = ResolversParentTypes['ProductPriceAdded']> = {
  price?: Resolver<ResolversTypes['ProductPrice'], ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceChanged'] = ResolversParentTypes['ProductPriceChanged']> = {
  newPrice?: Resolver<ResolversTypes['ProductPrice'], ParentType, ContextType>;
  oldPrice?: Resolver<ResolversTypes['ProductPrice'], ParentType, ContextType>;
  oldStagedPrice?: Resolver<Maybe<ResolversTypes['ProductPrice']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceDiscountUpdateMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceDiscountUpdateMessagePayload'] = ResolversParentTypes['ProductPriceDiscountUpdateMessagePayload']> = {
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  priceId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  variantKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceDiscountsSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceDiscountsSet'] = ResolversParentTypes['ProductPriceDiscountsSet']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedPrices?: Resolver<Array<ResolversTypes['ProductPriceDiscountUpdateMessagePayload']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceExternalDiscountSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceExternalDiscountSet'] = ResolversParentTypes['ProductPriceExternalDiscountSet']> = {
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  priceId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  variantKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceKeySetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceKeySet'] = ResolversParentTypes['ProductPriceKeySet']> = {
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oldKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priceId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceModeSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceModeSet'] = ResolversParentTypes['ProductPriceModeSet']> = {
  to?: Resolver<Maybe<ResolversTypes['PriceMode']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceRemoved'] = ResolversParentTypes['ProductPriceRemoved']> = {
  price?: Resolver<ResolversTypes['ProductPrice'], ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceSearch'] = ResolversParentTypes['ProductPriceSearch']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductSearchPriceValue']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tiers?: Resolver<Maybe<Array<ResolversTypes['ProductSearchPriceTier']>>, ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPriceTier'] = ResolversParentTypes['ProductPriceTier']> = {
  minimumQuantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPricesSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPricesSet'] = ResolversParentTypes['ProductPricesSet']> = {
  prices?: Resolver<Array<ResolversTypes['ProductPrice']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductProjection'] = ResolversParentTypes['ProductProjection']> = {
  categories?: Resolver<Array<ResolversTypes['Category']>, ParentType, ContextType>;
  categoriesRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  categoryOrderHints?: Resolver<Array<ResolversTypes['CategoryOrderHintProductSearch']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  hasStagedChanges?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  masterVariant?: Resolver<ResolversTypes['ProductSearchVariant'], ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMetaDescriptionArgs>>;
  metaDescriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMetaKeywordsArgs>>;
  metaKeywordsAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMetaTitleArgs>>;
  metaTitleAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType>;
  productTypeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  published?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRatingStatistics?: Resolver<Maybe<ResolversTypes['ReviewRatingStatistics']>, ParentType, ContextType>;
  searchKeywords?: Resolver<Array<ResolversTypes['SearchKeywordsProductSearch']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  variants?: Resolver<Array<ResolversTypes['ProductSearchVariant']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductProjectionMessagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductProjectionMessagePayload'] = ResolversParentTypes['ProductProjectionMessagePayload']> = {
  categories?: Resolver<Array<ResolversTypes['Category']>, ParentType, ContextType>;
  categoriesRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  categoryOrderHints?: Resolver<Array<ResolversTypes['CategoryOrderHint']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  hasStagedChanges?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  masterVariant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  metaDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadMetaDescriptionArgs>>;
  metaDescriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaKeywords?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadMetaKeywordsArgs>>;
  metaKeywordsAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  metaTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadMetaTitleArgs>>;
  metaTitleAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType>;
  productTypeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  published?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRatingStatistics?: Resolver<Maybe<ResolversTypes['ReviewRatingStatistics']>, ParentType, ContextType>;
  searchKeywords?: Resolver<Array<ResolversTypes['SearchKeywords']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductProjectionMessagePayloadSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  variants?: Resolver<Array<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductProjectionSearchResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductProjectionSearchResult'] = ResolversParentTypes['ProductProjectionSearchResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  facets?: Resolver<Array<ResolversTypes['FacetResultValue']>, ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductProjection']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPublishedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPublished'] = ResolversParentTypes['ProductPublished']> = {
  productProjection?: Resolver<ResolversTypes['ProductProjectionMessagePayload'], ParentType, ContextType>;
  removedImageUrls?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  scope?: Resolver<ResolversTypes['PublishScope'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductQueryResult'] = ResolversParentTypes['ProductQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Product']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductReferenceIdentifierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductReferenceIdentifier'] = ResolversParentTypes['ProductReferenceIdentifier']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductRemovedFromCategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductRemovedFromCategory'] = ResolversParentTypes['ProductRemovedFromCategory']> = {
  category?: Resolver<ResolversTypes['ReferenceId'], ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductRevertedStagedChangesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductRevertedStagedChanges'] = ResolversParentTypes['ProductRevertedStagedChanges']> = {
  removedImageUrls?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchPriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchPriceTier'] = ResolversParentTypes['ProductSearchPriceTier']> = {
  minimumQuantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchVariantResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchVariant'] = ResolversParentTypes['ProductSearchVariant']> = {
  assets?: Resolver<Array<ResolversTypes['Asset']>, ParentType, ContextType>;
  attributesRaw?: Resolver<Array<ResolversTypes['RawProductSearchAttribute']>, ParentType, ContextType, Partial<ProductSearchVariantAttributesRawArgs>>;
  availability?: Resolver<Maybe<ResolversTypes['ProductSearchVariantAvailabilityWithChannels']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  images?: Resolver<Array<ResolversTypes['ImageProductSearch']>, ParentType, ContextType>;
  isMatchingVariant?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['ProductPriceSearch']>, ParentType, ContextType, RequireFields<ProductSearchVariantPriceArgs, 'currency'>>;
  prices?: Resolver<Maybe<Array<ResolversTypes['ProductPriceSearch']>>, ParentType, ContextType>;
  scopedPrice?: Resolver<Maybe<ResolversTypes['ScopedPrice']>, ParentType, ContextType>;
  scopedPriceDiscounted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchVariantAvailabilitiesResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchVariantAvailabilitiesResult'] = ResolversParentTypes['ProductSearchVariantAvailabilitiesResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductSearchVariantAvailabilityWithChannel']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchVariantAvailabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchVariantAvailability'] = ResolversParentTypes['ProductSearchVariantAvailability']> = {
  availableQuantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isOnStock?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restockableInDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchVariantAvailabilityWithChannelResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchVariantAvailabilityWithChannel'] = ResolversParentTypes['ProductSearchVariantAvailabilityWithChannel']> = {
  availability?: Resolver<ResolversTypes['ProductSearchVariantAvailability'], ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSearchVariantAvailabilityWithChannelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSearchVariantAvailabilityWithChannels'] = ResolversParentTypes['ProductSearchVariantAvailabilityWithChannels']> = {
  channels?: Resolver<ResolversTypes['ProductSearchVariantAvailabilitiesResult'], ParentType, ContextType, Partial<ProductSearchVariantAvailabilityWithChannelsChannelsArgs>>;
  noChannel?: Resolver<Maybe<ResolversTypes['ProductSearchVariantAvailability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelection'] = ResolversParentTypes['ProductSelection']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  mode?: Resolver<ResolversTypes['ProductSelectionMode'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductSelectionNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  productCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  productRefs?: Resolver<ResolversTypes['ProductOfSelectionQueryResult'], ParentType, ContextType, Partial<ProductSelectionProductRefsArgs>>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionCreated'] = ResolversParentTypes['ProductSelectionCreated']> = {
  productSelection?: Resolver<ResolversTypes['ProductSelection'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionDeleted'] = ResolversParentTypes['ProductSelectionDeleted']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionProductAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionProductAdded'] = ResolversParentTypes['ProductSelectionProductAdded']> = {
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionProductExcludedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionProductExcluded'] = ResolversParentTypes['ProductSelectionProductExcluded']> = {
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionProductRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionProductRemoved'] = ResolversParentTypes['ProductSelectionProductRemoved']> = {
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionQueryInterface'] = ResolversParentTypes['ProductSelectionQueryInterface']> = {
  __resolveType: TypeResolveFn<'Query', ParentType, ContextType>;
  productSelectionAssignments?: Resolver<ResolversTypes['ProductAssignmentQueryResult'], ParentType, ContextType, Partial<ProductSelectionQueryInterfaceProductSelectionAssignmentsArgs>>;
};

export type ProductSelectionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionQueryResult'] = ResolversParentTypes['ProductSelectionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductSelection']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionSettingResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionSetting'] = ResolversParentTypes['ProductSelectionSetting']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  productSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType>;
  productSelectionRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionVariantExclusionChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionVariantExclusionChanged'] = ResolversParentTypes['ProductSelectionVariantExclusionChanged']> = {
  newVariantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  oldVariantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSelectionVariantSelectionChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSelectionVariantSelectionChanged'] = ResolversParentTypes['ProductSelectionVariantSelectionChanged']> = {
  newVariantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  oldVariantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductSlugChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductSlugChanged'] = ResolversParentTypes['ProductSlugChanged']> = {
  oldSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductSlugChangedOldSlugArgs>>;
  oldSlugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ProductSlugChangedSlugArgs>>;
  slugAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductStateTransition'] = ResolversParentTypes['ProductStateTransition']> = {
  force?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeDefinition'] = ResolversParentTypes['ProductTypeDefinition']> = {
  attributeDefinitions?: Resolver<ResolversTypes['AttributeDefinitionResult'], ParentType, ContextType, Partial<ProductTypeDefinitionAttributeDefinitionsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeDefinitionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeDefinitionQueryResult'] = ResolversParentTypes['ProductTypeDefinitionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeLimitWithCurrent'] = ResolversParentTypes['ProductTypeLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeLimitsProjection'] = ResolversParentTypes['ProductTypeLimitsProjection']> = {
  total?: Resolver<ResolversTypes['ProductTypeLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductUnpublishedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductUnpublished'] = ResolversParentTypes['ProductUnpublished']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariant'] = ResolversParentTypes['ProductVariant']> = {
  assets?: Resolver<Array<ResolversTypes['Asset']>, ParentType, ContextType>;
  attributesRaw?: Resolver<Array<ResolversTypes['RawProductAttribute']>, ParentType, ContextType, Partial<ProductVariantAttributesRawArgs>>;
  availability?: Resolver<Maybe<ResolversTypes['ProductVariantAvailabilityWithChannels']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  images?: Resolver<Array<ResolversTypes['Image']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['ProductPrice']>, ParentType, ContextType, RequireFields<ProductVariantPriceArgs, 'currency'>>;
  prices?: Resolver<Maybe<Array<ResolversTypes['ProductPrice']>>, ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantAdded'] = ResolversParentTypes['ProductVariantAdded']> = {
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantAvailabilitiesResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantAvailabilitiesResult'] = ResolversParentTypes['ProductVariantAvailabilitiesResult']> = {
  limit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  offset?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ProductVariantAvailabilityWithChannel']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantAvailabilityResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantAvailability'] = ResolversParentTypes['ProductVariantAvailability']> = {
  availableQuantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isOnStock?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  restockableInDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantAvailabilityWithChannelResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantAvailabilityWithChannel'] = ResolversParentTypes['ProductVariantAvailabilityWithChannel']> = {
  availability?: Resolver<ResolversTypes['ProductVariantAvailability'], ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantAvailabilityWithChannelsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantAvailabilityWithChannels'] = ResolversParentTypes['ProductVariantAvailabilityWithChannels']> = {
  channels?: Resolver<ResolversTypes['ProductVariantAvailabilitiesResult'], ParentType, ContextType, Partial<ProductVariantAvailabilityWithChannelsChannelsArgs>>;
  noChannel?: Resolver<Maybe<ResolversTypes['ProductVariantAvailability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantDeleted'] = ResolversParentTypes['ProductVariantDeleted']> = {
  removedImageUrls?: Resolver<ResolversTypes['Set'], ParentType, ContextType>;
  staged?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantExclusionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantExclusion'] = ResolversParentTypes['ProductVariantExclusion']> = {
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantSelectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantSelection'] = ResolversParentTypes['ProductVariantSelection']> = {
  __resolveType: TypeResolveFn<'ProductVariantSelectionIncludeAllExcept' | 'ProductVariantSelectionIncludeOnly', ParentType, ContextType>;
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ProductVariantSelectionIncludeAllExceptResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantSelectionIncludeAllExcept'] = ResolversParentTypes['ProductVariantSelectionIncludeAllExcept']> = {
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantSelectionIncludeOnlyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantSelectionIncludeOnly'] = ResolversParentTypes['ProductVariantSelectionIncludeOnly']> = {
  skus?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectCustomLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProjectCustomLimitsProjection'] = ResolversParentTypes['ProjectCustomLimitsProjection']> = {
  attributeGroups?: Resolver<ResolversTypes['AttributeGroupLimitsProjection'], ParentType, ContextType>;
  cartDiscounts?: Resolver<ResolversTypes['CartDiscountLimitsProjection'], ParentType, ContextType>;
  carts?: Resolver<ResolversTypes['CartLimitsProjection'], ParentType, ContextType>;
  category?: Resolver<ResolversTypes['CategoryLimitsProjection'], ParentType, ContextType>;
  customObjects?: Resolver<ResolversTypes['CustomObjectLimitsProjection'], ParentType, ContextType>;
  customerGroups?: Resolver<ResolversTypes['CustomerGroupLimitsProjection'], ParentType, ContextType>;
  customers?: Resolver<ResolversTypes['CustomerLimitsProjection'], ParentType, ContextType>;
  extensions?: Resolver<ResolversTypes['ExtensionLimitsProjection'], ParentType, ContextType>;
  orderEdits?: Resolver<ResolversTypes['OrderEditLimitsProjection'], ParentType, ContextType>;
  productDiscounts?: Resolver<ResolversTypes['ProductDiscountLimitsProjection'], ParentType, ContextType>;
  productType?: Resolver<ResolversTypes['ProductTypeLimitsProjection'], ParentType, ContextType>;
  products?: Resolver<ResolversTypes['ProductLimitsProjection'], ParentType, ContextType>;
  query?: Resolver<ResolversTypes['QueryLimitsProjection'], ParentType, ContextType>;
  refreshTokens?: Resolver<ResolversTypes['RefreshTokenLimitsProjection'], ParentType, ContextType>;
  search?: Resolver<ResolversTypes['SearchLimitsProjection'], ParentType, ContextType>;
  shippingMethods?: Resolver<ResolversTypes['ShippingMethodLimitsProjection'], ParentType, ContextType>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListLimitsProjection'], ParentType, ContextType>;
  stores?: Resolver<ResolversTypes['StoreLimitsProjection'], ParentType, ContextType>;
  subscriptions?: Resolver<ResolversTypes['SubscriptionsLimitsProjection'], ParentType, ContextType>;
  taxCategories?: Resolver<ResolversTypes['TaxCategoryLimitsProjection'], ParentType, ContextType>;
  zones?: Resolver<ResolversTypes['ZoneLimitsProjection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProjectProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProjectProjection'] = ResolversParentTypes['ProjectProjection']> = {
  businessUnits?: Resolver<Maybe<ResolversTypes['BusinessUnitConfiguration']>, ParentType, ContextType>;
  carts?: Resolver<ResolversTypes['CartsConfiguration'], ParentType, ContextType>;
  countries?: Resolver<Array<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  currencies?: Resolver<Array<ResolversTypes['Currency']>, ParentType, ContextType>;
  externalOAuth?: Resolver<Maybe<ResolversTypes['ExternalOAuth']>, ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  languages?: Resolver<Array<ResolversTypes['Locale']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  messages?: Resolver<ResolversTypes['MessagesConfiguration'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  searchIndexing?: Resolver<Maybe<ResolversTypes['SearchIndexingConfiguration']>, ParentType, ContextType>;
  shippingRateInputType?: Resolver<Maybe<ResolversTypes['ShippingRateInputType']>, ParentType, ContextType>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListsConfiguration'], ParentType, ContextType>;
  trialUntil?: Resolver<Maybe<ResolversTypes['YearMonth']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PurchaseOrderNumberSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['PurchaseOrderNumberSet'] = ResolversParentTypes['PurchaseOrderNumberSet']> = {
  oldPurchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  apiClient?: Resolver<Maybe<ResolversTypes['APIClientWithoutSecret']>, ParentType, ContextType, RequireFields<QueryApiClientArgs, 'id'>>;
  apiClients?: Resolver<ResolversTypes['APIClientWithoutSecretQueryResult'], ParentType, ContextType, Partial<QueryApiClientsArgs>>;
  asAssociate?: Resolver<ResolversTypes['AsAssociate'], ParentType, ContextType, RequireFields<QueryAsAssociateArgs, 'associateId' | 'businessUnitKey'>>;
  associateRole?: Resolver<Maybe<ResolversTypes['AssociateRole']>, ParentType, ContextType, Partial<QueryAssociateRoleArgs>>;
  associateRoles?: Resolver<ResolversTypes['AssociateRoleQueryResult'], ParentType, ContextType, Partial<QueryAssociateRolesArgs>>;
  attributeGroup?: Resolver<Maybe<ResolversTypes['AttributeGroup']>, ParentType, ContextType, Partial<QueryAttributeGroupArgs>>;
  attributeGroups?: Resolver<ResolversTypes['AttributeGroupQueryResult'], ParentType, ContextType, Partial<QueryAttributeGroupsArgs>>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType, Partial<QueryBusinessUnitArgs>>;
  businessUnits?: Resolver<ResolversTypes['BusinessUnitQueryResult'], ParentType, ContextType, Partial<QueryBusinessUnitsArgs>>;
  cart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<QueryCartArgs, 'id'>>;
  cartDiscount?: Resolver<Maybe<ResolversTypes['CartDiscount']>, ParentType, ContextType, Partial<QueryCartDiscountArgs>>;
  cartDiscounts?: Resolver<ResolversTypes['CartDiscountQueryResult'], ParentType, ContextType, Partial<QueryCartDiscountsArgs>>;
  carts?: Resolver<ResolversTypes['CartQueryResult'], ParentType, ContextType, Partial<QueryCartsArgs>>;
  categories?: Resolver<ResolversTypes['CategoryQueryResult'], ParentType, ContextType, Partial<QueryCategoriesArgs>>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, Partial<QueryCategoryArgs>>;
  categoryAutocomplete?: Resolver<ResolversTypes['CategorySearchResult'], ParentType, ContextType, RequireFields<QueryCategoryAutocompleteArgs, 'limit' | 'locale' | 'offset' | 'text'>>;
  categorySearch?: Resolver<ResolversTypes['CategorySearchResult'], ParentType, ContextType, RequireFields<QueryCategorySearchArgs, 'limit' | 'offset'>>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, Partial<QueryChannelArgs>>;
  channels?: Resolver<ResolversTypes['ChannelQueryResult'], ParentType, ContextType, Partial<QueryChannelsArgs>>;
  customObject?: Resolver<Maybe<ResolversTypes['CustomObject']>, ParentType, ContextType, Partial<QueryCustomObjectArgs>>;
  customObjects?: Resolver<ResolversTypes['CustomObjectQueryResult'], ParentType, ContextType, RequireFields<QueryCustomObjectsArgs, 'container'>>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, Partial<QueryCustomerArgs>>;
  customerActiveCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType, RequireFields<QueryCustomerActiveCartArgs, 'customerId'>>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType, Partial<QueryCustomerGroupArgs>>;
  customerGroups?: Resolver<ResolversTypes['CustomerGroupQueryResult'], ParentType, ContextType, Partial<QueryCustomerGroupsArgs>>;
  customers?: Resolver<ResolversTypes['CustomerQueryResult'], ParentType, ContextType, Partial<QueryCustomersArgs>>;
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType, RequireFields<QueryDiscountCodeArgs, 'id'>>;
  discountCodes?: Resolver<ResolversTypes['DiscountCodeQueryResult'], ParentType, ContextType, Partial<QueryDiscountCodesArgs>>;
  extension?: Resolver<Maybe<ResolversTypes['Extension']>, ParentType, ContextType, Partial<QueryExtensionArgs>>;
  extensions?: Resolver<ResolversTypes['ExtensionQueryResult'], ParentType, ContextType, Partial<QueryExtensionsArgs>>;
  inStore?: Resolver<ResolversTypes['InStore'], ParentType, ContextType, RequireFields<QueryInStoreArgs, 'key'>>;
  inStores?: Resolver<ResolversTypes['InStore'], ParentType, ContextType, RequireFields<QueryInStoresArgs, 'keys'>>;
  inventoryEntries?: Resolver<ResolversTypes['InventoryEntryQueryResult'], ParentType, ContextType, Partial<QueryInventoryEntriesArgs>>;
  inventoryEntry?: Resolver<Maybe<ResolversTypes['InventoryEntry']>, ParentType, ContextType, Partial<QueryInventoryEntryArgs>>;
  limits?: Resolver<ResolversTypes['ProjectCustomLimitsProjection'], ParentType, ContextType>;
  me?: Resolver<ResolversTypes['Me'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['Message']>, ParentType, ContextType, Partial<QueryMessageArgs>>;
  messages?: Resolver<ResolversTypes['MessageQueryResult'], ParentType, ContextType, Partial<QueryMessagesArgs>>;
  mmuCustomersQuery?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType, Partial<QueryMmuCustomersQueryArgs>>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, Partial<QueryOrderArgs>>;
  orderEdit?: Resolver<Maybe<ResolversTypes['OrderEdit']>, ParentType, ContextType, Partial<QueryOrderEditArgs>>;
  orderEdits?: Resolver<ResolversTypes['OrderEditQueryResult'], ParentType, ContextType, Partial<QueryOrderEditsArgs>>;
  orders?: Resolver<ResolversTypes['OrderQueryResult'], ParentType, ContextType, Partial<QueryOrdersArgs>>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, Partial<QueryPaymentArgs>>;
  payments?: Resolver<ResolversTypes['PaymentQueryResult'], ParentType, ContextType, Partial<QueryPaymentsArgs>>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, RequireFields<QueryProductArgs, 'projectExpandedProducts'>>;
  productDiscount?: Resolver<Maybe<ResolversTypes['ProductDiscount']>, ParentType, ContextType, Partial<QueryProductDiscountArgs>>;
  productDiscounts?: Resolver<ResolversTypes['ProductDiscountQueryResult'], ParentType, ContextType, Partial<QueryProductDiscountsArgs>>;
  productProjectionSearch?: Resolver<ResolversTypes['ProductProjectionSearchResult'], ParentType, ContextType, RequireFields<QueryProductProjectionSearchArgs, 'facetFilters' | 'facets' | 'filters' | 'fuzzy' | 'limit' | 'markMatchingVariant' | 'markMatchingVariants' | 'offset' | 'projectExpandedProducts' | 'queryFilters' | 'sorts' | 'staged'>>;
  productProjectionsSuggest?: Resolver<ResolversTypes['SuggestResult'], ParentType, ContextType, RequireFields<QueryProductProjectionsSuggestArgs, 'limit' | 'searchKeywords' | 'staged'>>;
  productSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType, Partial<QueryProductSelectionArgs>>;
  productSelectionAssignments?: Resolver<ResolversTypes['ProductAssignmentQueryResult'], ParentType, ContextType, Partial<QueryProductSelectionAssignmentsArgs>>;
  productSelections?: Resolver<ResolversTypes['ProductSelectionQueryResult'], ParentType, ContextType, Partial<QueryProductSelectionsArgs>>;
  productType?: Resolver<Maybe<ResolversTypes['ProductTypeDefinition']>, ParentType, ContextType, Partial<QueryProductTypeArgs>>;
  productTypes?: Resolver<ResolversTypes['ProductTypeDefinitionQueryResult'], ParentType, ContextType, Partial<QueryProductTypesArgs>>;
  products?: Resolver<ResolversTypes['ProductQueryResult'], ParentType, ContextType, RequireFields<QueryProductsArgs, 'projectExpandedProducts'>>;
  project?: Resolver<ResolversTypes['ProjectProjection'], ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, Partial<QueryQuoteArgs>>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, Partial<QueryQuoteRequestArgs>>;
  quoteRequests?: Resolver<ResolversTypes['QuoteRequestQueryResult'], ParentType, ContextType, Partial<QueryQuoteRequestsArgs>>;
  quotes?: Resolver<ResolversTypes['QuoteQueryResult'], ParentType, ContextType, Partial<QueryQuotesArgs>>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, Partial<QueryReviewArgs>>;
  reviews?: Resolver<ResolversTypes['ReviewQueryResult'], ParentType, ContextType, Partial<QueryReviewsArgs>>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType, Partial<QueryShippingMethodArgs>>;
  shippingMethods?: Resolver<ResolversTypes['ShippingMethodQueryResult'], ParentType, ContextType, Partial<QueryShippingMethodsArgs>>;
  shippingMethodsByCart?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<QueryShippingMethodsByCartArgs, 'id'>>;
  shippingMethodsByLocation?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<QueryShippingMethodsByLocationArgs, 'country'>>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<QueryShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<QueryShoppingListsArgs>>;
  stagedQuote?: Resolver<Maybe<ResolversTypes['StagedQuote']>, ParentType, ContextType, Partial<QueryStagedQuoteArgs>>;
  stagedQuotes?: Resolver<ResolversTypes['StagedQuoteQueryResult'], ParentType, ContextType, Partial<QueryStagedQuotesArgs>>;
  standalonePrice?: Resolver<Maybe<ResolversTypes['StandalonePrice']>, ParentType, ContextType, Partial<QueryStandalonePriceArgs>>;
  standalonePrices?: Resolver<ResolversTypes['StandalonePriceQueryResult'], ParentType, ContextType, Partial<QueryStandalonePricesArgs>>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType, Partial<QueryStateArgs>>;
  states?: Resolver<ResolversTypes['StateQueryResult'], ParentType, ContextType, Partial<QueryStatesArgs>>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType, Partial<QueryStoreArgs>>;
  stores?: Resolver<ResolversTypes['StoreQueryResult'], ParentType, ContextType, Partial<QueryStoresArgs>>;
  subscription?: Resolver<Maybe<ResolversTypes['CommercetoolsSubscription']>, ParentType, ContextType, Partial<QuerySubscriptionArgs>>;
  subscriptions?: Resolver<ResolversTypes['CommercetoolsSubscriptionQueryResult'], ParentType, ContextType, Partial<QuerySubscriptionsArgs>>;
  taxCategories?: Resolver<ResolversTypes['TaxCategoryQueryResult'], ParentType, ContextType, Partial<QueryTaxCategoriesArgs>>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType, Partial<QueryTaxCategoryArgs>>;
  typeDefinition?: Resolver<Maybe<ResolversTypes['TypeDefinition']>, ParentType, ContextType, Partial<QueryTypeDefinitionArgs>>;
  typeDefinitions?: Resolver<ResolversTypes['TypeDefinitionQueryResult'], ParentType, ContextType, Partial<QueryTypeDefinitionsArgs>>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType, Partial<QueryZoneArgs>>;
  zones?: Resolver<ResolversTypes['ZoneQueryResult'], ParentType, ContextType, Partial<QueryZonesArgs>>;
};

export type QueryLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['QueryLimitsProjection'] = ResolversParentTypes['QueryLimitsProjection']> = {
  offset?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QuoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['Quote'] = ResolversParentTypes['Quote']> = {
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  businessUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  buyerComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customLineItems?: Resolver<Array<ResolversTypes['CustomLineItem']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  directDiscounts?: Resolver<Array<ResolversTypes['DirectDiscount']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inventoryMode?: Resolver<ResolversTypes['InventoryMode'], ParentType, ContextType>;
  itemShippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lineItems?: Resolver<Array<ResolversTypes['LineItem']>, ParentType, ContextType, Partial<QuoteLineItemsArgs>>;
  paymentInfo?: Resolver<Maybe<ResolversTypes['PaymentInfo']>, ParentType, ContextType>;
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType>;
  quoteRequestRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  quoteState?: Resolver<ResolversTypes['QuoteState'], ParentType, ContextType>;
  sellerComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  stagedQuote?: Resolver<Maybe<ResolversTypes['StagedQuote']>, ParentType, ContextType>;
  stagedQuoteRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  taxCalculationMode?: Resolver<ResolversTypes['TaxCalculationMode'], ParentType, ContextType>;
  taxMode?: Resolver<ResolversTypes['TaxMode'], ParentType, ContextType>;
  taxRoundingMode?: Resolver<ResolversTypes['RoundingMode'], ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  validTo?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QuoteQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuoteQueryInterface'] = ResolversParentTypes['QuoteQueryInterface']> = {
  __resolveType: TypeResolveFn<'AsAssociate', ParentType, ContextType>;
  quote?: Resolver<Maybe<ResolversTypes['Quote']>, ParentType, ContextType, Partial<QuoteQueryInterfaceQuoteArgs>>;
  quotes?: Resolver<ResolversTypes['QuoteQueryResult'], ParentType, ContextType, Partial<QuoteQueryInterfaceQuotesArgs>>;
};

export type QuoteQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuoteQueryResult'] = ResolversParentTypes['QuoteQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Quote']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QuoteRequestResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuoteRequest'] = ResolversParentTypes['QuoteRequest']> = {
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  businessUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customLineItems?: Resolver<Array<ResolversTypes['CustomLineItem']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  directDiscounts?: Resolver<Array<ResolversTypes['DirectDiscount']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  inventoryMode?: Resolver<ResolversTypes['InventoryMode'], ParentType, ContextType>;
  itemShippingAddresses?: Resolver<Array<ResolversTypes['Address']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lineItems?: Resolver<Array<ResolversTypes['LineItem']>, ParentType, ContextType, Partial<QuoteRequestLineItemsArgs>>;
  paymentInfo?: Resolver<Maybe<ResolversTypes['PaymentInfo']>, ParentType, ContextType>;
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quoteRequestState?: Resolver<ResolversTypes['QuoteRequestState'], ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  taxCalculationMode?: Resolver<ResolversTypes['TaxCalculationMode'], ParentType, ContextType>;
  taxMode?: Resolver<ResolversTypes['TaxMode'], ParentType, ContextType>;
  taxRoundingMode?: Resolver<ResolversTypes['RoundingMode'], ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedPrice']>, ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QuoteRequestQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuoteRequestQueryInterface'] = ResolversParentTypes['QuoteRequestQueryInterface']> = {
  __resolveType: TypeResolveFn<'AsAssociate', ParentType, ContextType>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType, Partial<QuoteRequestQueryInterfaceQuoteRequestArgs>>;
  quoteRequests?: Resolver<ResolversTypes['QuoteRequestQueryResult'], ParentType, ContextType, Partial<QuoteRequestQueryInterfaceQuoteRequestsArgs>>;
};

export type QuoteRequestQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuoteRequestQueryResult'] = ResolversParentTypes['QuoteRequestQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['QuoteRequest']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RangeCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['RangeCount'] = ResolversParentTypes['RangeCount']> = {
  __resolveType: TypeResolveFn<'RangeCountDouble' | 'RangeCountLong', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type RangeCountDoubleResolvers<ContextType = any, ParentType extends ResolversParentTypes['RangeCountDouble'] = ResolversParentTypes['RangeCountDouble']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  from?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  fromStr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  max?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  mean?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  min?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  productCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  to?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  toStr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RangeCountLongResolvers<ContextType = any, ParentType extends ResolversParentTypes['RangeCountLong'] = ResolversParentTypes['RangeCountLong']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  from?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  fromStr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  max?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  mean?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  min?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  productCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  to?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  toStr?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RangeFacetResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['RangeFacetResult'] = ResolversParentTypes['RangeFacetResult']> = {
  dataType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ranges?: Resolver<Array<ResolversTypes['RangeCount']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RawCustomFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['RawCustomField'] = ResolversParentTypes['RawCustomField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referencedResource?: Resolver<Maybe<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  referencedResourceSet?: Resolver<Array<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RawProductAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RawProductAttribute'] = ResolversParentTypes['RawProductAttribute']> = {
  attributeDefinition?: Resolver<Maybe<ResolversTypes['AttributeDefinition']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referencedResource?: Resolver<Maybe<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  referencedResourceSet?: Resolver<Array<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RawProductSearchAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RawProductSearchAttribute'] = ResolversParentTypes['RawProductSearchAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referencedResource?: Resolver<Maybe<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  referencedResourceSet?: Resolver<Array<ResolversTypes['ReferenceExpandable']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RecalculateStagedOrderOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RecalculateStagedOrderOutput'] = ResolversParentTypes['RecalculateStagedOrderOutput']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updateProductData?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Reference'] = ResolversParentTypes['Reference']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceAttribute'] = ResolversParentTypes['ReferenceAttribute']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceAttributeDefinitionType'] = ResolversParentTypes['ReferenceAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referenceTypeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceExpandableResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceExpandable'] = ResolversParentTypes['ReferenceExpandable']> = {
  __resolveType: TypeResolveFn<'Cart' | 'CartDiscount' | 'Category' | 'Channel' | 'CustomObject' | 'Customer' | 'CustomerGroup' | 'DiscountCode' | 'Extension' | 'InventoryEntry' | 'Message' | 'Order' | 'Product' | 'ProductDiscount' | 'ProductTypeDefinition' | 'Review' | 'ShippingMethod' | 'ShoppingList' | 'State' | 'Store' | 'TaxCategory' | 'TypeDefinition' | 'Zone', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ReferenceFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceField'] = ResolversParentTypes['ReferenceField']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceIdResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceId'] = ResolversParentTypes['ReferenceId']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReferenceTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReferenceType'] = ResolversParentTypes['ReferenceType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  referenceTypeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefreshTokenLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['RefreshTokenLimitWithCurrent'] = ResolversParentTypes['RefreshTokenLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefreshTokenLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['RefreshTokenLimitsProjection'] = ResolversParentTypes['RefreshTokenLimitsProjection']> = {
  total?: Resolver<ResolversTypes['RefreshTokenLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RelativeDiscountValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['RelativeDiscountValue'] = ResolversParentTypes['RelativeDiscountValue']> = {
  permyriad?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderCustomLineItemOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderCustomLineItemOutput'] = ResolversParentTypes['RemoveStagedOrderCustomLineItemOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderDeliveryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderDeliveryOutput'] = ResolversParentTypes['RemoveStagedOrderDeliveryOutput']> = {
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderDiscountCodeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderDiscountCodeOutput'] = ResolversParentTypes['RemoveStagedOrderDiscountCodeOutput']> = {
  discountCode?: Resolver<Maybe<ResolversTypes['DiscountCode']>, ParentType, ContextType>;
  discountCodeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderItemShippingAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderItemShippingAddressOutput'] = ResolversParentTypes['RemoveStagedOrderItemShippingAddressOutput']> = {
  addressKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderLineItemOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderLineItemOutput'] = ResolversParentTypes['RemoveStagedOrderLineItemOutput']> = {
  externalPrice?: Resolver<Maybe<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  externalTotalPrice?: Resolver<Maybe<ResolversTypes['ExternalLineItemTotalPrice']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  shippingDetailsToRemove?: Resolver<Maybe<ResolversTypes['ItemShippingDetailsDraftOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderParcelFromDeliveryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderParcelFromDeliveryOutput'] = ResolversParentTypes['RemoveStagedOrderParcelFromDeliveryOutput']> = {
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RemoveStagedOrderPaymentOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['RemoveStagedOrderPaymentOutput'] = ResolversParentTypes['RemoveStagedOrderPaymentOutput']> = {
  paymentResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ResourceIdentifierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceIdentifier'] = ResolversParentTypes['ResourceIdentifier']> = {
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  typeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReturnInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnInfo'] = ResolversParentTypes['ReturnInfo']> = {
  items?: Resolver<Array<ResolversTypes['ReturnItem']>, ParentType, ContextType>;
  returnDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  returnTrackingId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReturnInfoAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnInfoAdded'] = ResolversParentTypes['ReturnInfoAdded']> = {
  returnInfo?: Resolver<ResolversTypes['ReturnInfo'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReturnInfoDraftTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnInfoDraftTypeOutput'] = ResolversParentTypes['ReturnInfoDraftTypeOutput']> = {
  items?: Resolver<Array<ResolversTypes['ReturnItemDraftTypeOutput']>, ParentType, ContextType>;
  returnDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  returnTrackingId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReturnInfoSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnInfoSet'] = ResolversParentTypes['ReturnInfoSet']> = {
  returnInfo?: Resolver<Maybe<Array<ResolversTypes['ReturnInfo']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReturnItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnItem'] = ResolversParentTypes['ReturnItem']> = {
  __resolveType: TypeResolveFn<'CustomLineItemReturnItem' | 'LineItemReturnItem', ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  paymentState?: Resolver<ResolversTypes['ReturnPaymentState'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ReturnItemDraftTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReturnItemDraftTypeOutput'] = ResolversParentTypes['ReturnItemDraftTypeOutput']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsCommand']>, ParentType, ContextType>;
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResolvers<ContextType = any, ParentType extends ResolversParentTypes['Review'] = ResolversParentTypes['Review']> = {
  authorName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  includedInStatistics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  locale?: Resolver<Maybe<ResolversTypes['Locale']>, ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['ReviewTarget']>, ParentType, ContextType>;
  targetRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  text?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uniquenessValue?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewCreated'] = ResolversParentTypes['ReviewCreated']> = {
  review?: Resolver<ResolversTypes['Review'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewQueryResult'] = ResolversParentTypes['ReviewQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Review']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRatingSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewRatingSet'] = ResolversParentTypes['ReviewRatingSet']> = {
  includedInStatistics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  newRating?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  oldRating?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['ReviewTarget']>, ParentType, ContextType>;
  targetRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewRatingStatisticsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewRatingStatistics'] = ResolversParentTypes['ReviewRatingStatistics']> = {
  averageRating?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  highestRating?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  lowestRating?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  ratingsDistribution?: Resolver<ResolversTypes['Json'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStateTransitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStateTransition'] = ResolversParentTypes['ReviewStateTransition']> = {
  force?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  newIncludedInStatistics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  newState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  newStateRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  oldIncludedInStatistics?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oldState?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  oldStateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  target?: Resolver<Maybe<ResolversTypes['ReviewTarget']>, ParentType, ContextType>;
  targetRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewTarget'] = ResolversParentTypes['ReviewTarget']> = {
  __resolveType: TypeResolveFn<'Channel' | 'Product', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type RuleApproverResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleApprover'] = ResolversParentTypes['RuleApprover']> = {
  associateRole?: Resolver<ResolversTypes['AssociateRole'], ParentType, ContextType>;
  associateRoleRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleInfo'] = ResolversParentTypes['RuleInfo']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RuleRequesterResolvers<ContextType = any, ParentType extends ResolversParentTypes['RuleRequester'] = ResolversParentTypes['RuleRequester']> = {
  associateRole?: Resolver<ResolversTypes['AssociateRole'], ParentType, ContextType>;
  associateRoleRef?: Resolver<ResolversTypes['KeyReference'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SnsDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SNSDestination'] = ResolversParentTypes['SNSDestination']> = {
  accessKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authenticationMode?: Resolver<ResolversTypes['AwsAuthenticationMode'], ParentType, ContextType>;
  topicArn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SqsDestinationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SQSDestination'] = ResolversParentTypes['SQSDestination']> = {
  accessKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessSecret?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  authenticationMode?: Resolver<ResolversTypes['AwsAuthenticationMode'], ParentType, ContextType>;
  queueUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  region?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ScopedPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScopedPrice'] = ResolversParentTypes['ScopedPrice']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currentValue?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductSearchPriceValue']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ScoreShippingRateInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScoreShippingRateInput'] = ResolversParentTypes['ScoreShippingRateInput']> = {
  score?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ScoreShippingRateInputDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ScoreShippingRateInputDraftOutput'] = ResolversParentTypes['ScoreShippingRateInputDraftOutput']> = {
  score?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SearchFilterScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SearchFilter'], any> {
  name: 'SearchFilter';
}

export type SearchIndexingConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchIndexingConfiguration'] = ResolversParentTypes['SearchIndexingConfiguration']> = {
  customers?: Resolver<Maybe<ResolversTypes['CustomerSearchConfiguration']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['OrderSearchConfiguration']>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['SearchIndexingConfigurationValues']>, ParentType, ContextType>;
  standalonePrices?: Resolver<Maybe<ResolversTypes['SearchIndexingConfigurationValues']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchIndexingConfigurationValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchIndexingConfigurationValues'] = ResolversParentTypes['SearchIndexingConfigurationValues']> = {
  lastModifiedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['SearchIndexingStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchKeywordResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchKeyword'] = ResolversParentTypes['SearchKeyword']> = {
  suggestTokenizer?: Resolver<Maybe<ResolversTypes['SuggestTokenizer']>, ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchKeywordProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchKeywordProductSearch'] = ResolversParentTypes['SearchKeywordProductSearch']> = {
  suggestTokenizer?: Resolver<Maybe<ResolversTypes['SuggestTokenizerProductSearch']>, ParentType, ContextType>;
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchKeywordsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchKeywords'] = ResolversParentTypes['SearchKeywords']> = {
  locale?: Resolver<ResolversTypes['Locale'], ParentType, ContextType>;
  searchKeywords?: Resolver<Array<ResolversTypes['SearchKeyword']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchKeywordsProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchKeywordsProductSearch'] = ResolversParentTypes['SearchKeywordsProductSearch']> = {
  locale?: Resolver<ResolversTypes['Locale'], ParentType, ContextType>;
  searchKeywords?: Resolver<Array<ResolversTypes['SearchKeywordProductSearch']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SearchLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SearchLimitsProjection'] = ResolversParentTypes['SearchLimitsProjection']> = {
  maxTextSize?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SearchSortScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SearchSort'], any> {
  name: 'SearchSort';
}

export type SelectionOfProductResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectionOfProduct'] = ResolversParentTypes['SelectionOfProduct']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  productSelection?: Resolver<Maybe<ResolversTypes['ProductSelection']>, ParentType, ContextType>;
  productSelectionRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  variantExclusion?: Resolver<Maybe<ResolversTypes['ProductVariantExclusion']>, ParentType, ContextType>;
  variantSelection?: Resolver<Maybe<ResolversTypes['ProductVariantSelection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectionOfProductQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectionOfProductQueryResult'] = ResolversParentTypes['SelectionOfProductQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['SelectionOfProduct']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SetScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Set'], any> {
  name: 'Set';
}

export type SetAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetAttributeDefinitionType'] = ResolversParentTypes['SetAttributeDefinitionType']> = {
  elementType?: Resolver<ResolversTypes['AttributeDefinitionType'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderBillingAddressCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderBillingAddressCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderBillingAddressCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderBillingAddressCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderBillingAddressCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderBillingAddressCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderBillingAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderBillingAddressOutput'] = ResolversParentTypes['SetStagedOrderBillingAddressOutput']> = {
  address?: Resolver<Maybe<ResolversTypes['AddressDraft']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCountryOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCountryOutput'] = ResolversParentTypes['SetStagedOrderCountryOutput']> = {
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomLineItemCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomLineItemCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderCustomLineItemCustomFieldOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomLineItemCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomLineItemCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderCustomLineItemCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomLineItemShippingDetailsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomLineItemShippingDetailsOutput'] = ResolversParentTypes['SetStagedOrderCustomLineItemShippingDetailsOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetailsDraftOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomLineItemTaxAmountOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomLineItemTaxAmountOutput'] = ResolversParentTypes['SetStagedOrderCustomLineItemTaxAmountOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalTaxAmount?: Resolver<Maybe<ResolversTypes['ExternalTaxAmountDraftOutput']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomLineItemTaxRateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomLineItemTaxRateOutput'] = ResolversParentTypes['SetStagedOrderCustomLineItemTaxRateOutput']> = {
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomShippingMethodOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomShippingMethodOutput'] = ResolversParentTypes['SetStagedOrderCustomShippingMethodOutput']> = {
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingMethodName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingRate?: Resolver<ResolversTypes['ShippingRate'], ParentType, ContextType>;
  taxCategoryResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomerEmailOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomerEmailOutput'] = ResolversParentTypes['SetStagedOrderCustomerEmailOutput']> = {
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomerGroupOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomerGroupOutput'] = ResolversParentTypes['SetStagedOrderCustomerGroupOutput']> = {
  customerGroupResId?: Resolver<Maybe<ResolversTypes['CustomerGroupReferenceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderCustomerIdOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderCustomerIdOutput'] = ResolversParentTypes['SetStagedOrderCustomerIdOutput']> = {
  customerId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryAddressCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryAddressCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderDeliveryAddressCustomFieldOutput']> = {
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryAddressCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryAddressCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderDeliveryAddressCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryAddressOutput'] = ResolversParentTypes['SetStagedOrderDeliveryAddressOutput']> = {
  address?: Resolver<Maybe<ResolversTypes['AddressDraft']>, ParentType, ContextType>;
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderDeliveryCustomFieldOutput']> = {
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderDeliveryCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDeliveryItemsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDeliveryItemsOutput'] = ResolversParentTypes['SetStagedOrderDeliveryItemsOutput']> = {
  deliveryId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deliveryKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderDirectDiscountsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderDirectDiscountsOutput'] = ResolversParentTypes['SetStagedOrderDirectDiscountsOutput']> = {
  discounts?: Resolver<Array<ResolversTypes['DirectDiscountDraftOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderItemShippingAddressCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderItemShippingAddressCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderItemShippingAddressCustomFieldOutput']> = {
  addressKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderItemShippingAddressCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderItemShippingAddressCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderItemShippingAddressCustomTypeOutput']> = {
  addressKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderLineItemCustomFieldOutput']> = {
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderLineItemCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemDistributionChannelOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemDistributionChannelOutput'] = ResolversParentTypes['SetStagedOrderLineItemDistributionChannelOutput']> = {
  distributionChannelResId?: Resolver<Maybe<ResolversTypes['ChannelReferenceIdentifier']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemPriceOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemPriceOutput'] = ResolversParentTypes['SetStagedOrderLineItemPriceOutput']> = {
  externalPrice?: Resolver<Maybe<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemShippingDetailsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemShippingDetailsOutput'] = ResolversParentTypes['SetStagedOrderLineItemShippingDetailsOutput']> = {
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingDetails?: Resolver<Maybe<ResolversTypes['ItemShippingDetailsDraftOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemTaxAmountOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemTaxAmountOutput'] = ResolversParentTypes['SetStagedOrderLineItemTaxAmountOutput']> = {
  externalTaxAmount?: Resolver<Maybe<ResolversTypes['ExternalTaxAmountDraftOutput']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemTaxRateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemTaxRateOutput'] = ResolversParentTypes['SetStagedOrderLineItemTaxRateOutput']> = {
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLineItemTotalPriceOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLineItemTotalPriceOutput'] = ResolversParentTypes['SetStagedOrderLineItemTotalPriceOutput']> = {
  externalTotalPrice?: Resolver<Maybe<ResolversTypes['ExternalLineItemTotalPrice']>, ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderLocaleOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderLocaleOutput'] = ResolversParentTypes['SetStagedOrderLocaleOutput']> = {
  locale?: Resolver<Maybe<ResolversTypes['Locale']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderOrderNumberOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderOrderNumberOutput'] = ResolversParentTypes['SetStagedOrderOrderNumberOutput']> = {
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderOrderTotalTaxOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderOrderTotalTaxOutput'] = ResolversParentTypes['SetStagedOrderOrderTotalTaxOutput']> = {
  externalTaxPortions?: Resolver<Array<ResolversTypes['TaxPortion']>, ParentType, ContextType>;
  externalTotalGross?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderParcelCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderParcelCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderParcelCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderParcelCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderParcelCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderParcelCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderParcelItemsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderParcelItemsOutput'] = ResolversParentTypes['SetStagedOrderParcelItemsOutput']> = {
  items?: Resolver<Array<ResolversTypes['DeliveryItem']>, ParentType, ContextType>;
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderParcelMeasurementsOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderParcelMeasurementsOutput'] = ResolversParentTypes['SetStagedOrderParcelMeasurementsOutput']> = {
  measurements?: Resolver<Maybe<ResolversTypes['ParcelMeasurements']>, ParentType, ContextType>;
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderParcelTrackingDataOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderParcelTrackingDataOutput'] = ResolversParentTypes['SetStagedOrderParcelTrackingDataOutput']> = {
  parcelId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parcelKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingData?: Resolver<Maybe<ResolversTypes['TrackingData']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderPurchaseOrderNumberOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderPurchaseOrderNumberOutput'] = ResolversParentTypes['SetStagedOrderPurchaseOrderNumberOutput']> = {
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderReturnInfoOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderReturnInfoOutput'] = ResolversParentTypes['SetStagedOrderReturnInfoOutput']> = {
  items?: Resolver<Array<ResolversTypes['ReturnInfoDraftTypeOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderReturnItemCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderReturnItemCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderReturnItemCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  returnItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderReturnItemCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderReturnItemCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderReturnItemCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  returnItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderReturnPaymentStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderReturnPaymentStateOutput'] = ResolversParentTypes['SetStagedOrderReturnPaymentStateOutput']> = {
  paymentState?: Resolver<ResolversTypes['ReturnPaymentState'], ParentType, ContextType>;
  returnItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderReturnShipmentStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderReturnShipmentStateOutput'] = ResolversParentTypes['SetStagedOrderReturnShipmentStateOutput']> = {
  returnItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  returnItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shipmentState?: Resolver<ResolversTypes['ReturnShipmentState'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingAddressAndCustomShippingMethodOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingAddressAndCustomShippingMethodOutput'] = ResolversParentTypes['SetStagedOrderShippingAddressAndCustomShippingMethodOutput']> = {
  address?: Resolver<ResolversTypes['AddressDraft'], ParentType, ContextType>;
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingMethodName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingRate?: Resolver<ResolversTypes['ShippingRate'], ParentType, ContextType>;
  taxCategoryResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingAddressAndShippingMethodOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingAddressAndShippingMethodOutput'] = ResolversParentTypes['SetStagedOrderShippingAddressAndShippingMethodOutput']> = {
  address?: Resolver<ResolversTypes['AddressDraft'], ParentType, ContextType>;
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingMethodResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingAddressCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingAddressCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderShippingAddressCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingAddressCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingAddressCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderShippingAddressCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingAddressOutput'] = ResolversParentTypes['SetStagedOrderShippingAddressOutput']> = {
  address?: Resolver<Maybe<ResolversTypes['AddressDraft']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingCustomFieldOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingCustomFieldOutput'] = ResolversParentTypes['SetStagedOrderShippingCustomFieldOutput']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Json']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingCustomTypeOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingCustomTypeOutput'] = ResolversParentTypes['SetStagedOrderShippingCustomTypeOutput']> = {
  custom?: Resolver<ResolversTypes['CustomFieldsCommand'], ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingMethodOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingMethodOutput'] = ResolversParentTypes['SetStagedOrderShippingMethodOutput']> = {
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingMethodResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingMethodTaxAmountOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingMethodTaxAmountOutput'] = ResolversParentTypes['SetStagedOrderShippingMethodTaxAmountOutput']> = {
  externalTaxAmount?: Resolver<Maybe<ResolversTypes['ExternalTaxAmountDraftOutput']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingMethodTaxRateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingMethodTaxRateOutput'] = ResolversParentTypes['SetStagedOrderShippingMethodTaxRateOutput']> = {
  externalTaxRate?: Resolver<Maybe<ResolversTypes['ExternalTaxRateDraftOutput']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderShippingRateInputOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderShippingRateInputOutput'] = ResolversParentTypes['SetStagedOrderShippingRateInputOutput']> = {
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInputDraftOutput']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetStagedOrderStoreOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetStagedOrderStoreOutput'] = ResolversParentTypes['SetStagedOrderStoreOutput']> = {
  storeResId?: Resolver<Maybe<ResolversTypes['ResourceIdentifier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetType'] = ResolversParentTypes['SetType']> = {
  elementType?: Resolver<ResolversTypes['FieldType'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Shipping'] = ResolversParentTypes['Shipping']> = {
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingCustomFields?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  shippingInfo?: Resolver<Maybe<ResolversTypes['ShippingInfo']>, ParentType, ContextType>;
  shippingKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingRateInput?: Resolver<Maybe<ResolversTypes['ShippingRateInput']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingInfo'] = ResolversParentTypes['ShippingInfo']> = {
  deliveries?: Resolver<Array<ResolversTypes['Delivery']>, ParentType, ContextType>;
  discountedPrice?: Resolver<Maybe<ResolversTypes['DiscountedLineItemPrice']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  shippingMethodName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingMethodRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  shippingMethodState?: Resolver<ResolversTypes['ShippingMethodState'], ParentType, ContextType>;
  shippingRate?: Resolver<ResolversTypes['ShippingRate'], ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  taxRate?: Resolver<Maybe<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  taxedPrice?: Resolver<Maybe<ResolversTypes['TaxedItemPrice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethod'] = ResolversParentTypes['ShippingMethod']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isDefault?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  localizedDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShippingMethodLocalizedDescriptionArgs>>;
  localizedDescriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  localizedName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShippingMethodLocalizedNameArgs>>;
  localizedNameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  predicate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxCategory?: Resolver<Maybe<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  taxCategoryRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  zoneRates?: Resolver<Array<ResolversTypes['ZoneRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodLimitWithCurrent'] = ResolversParentTypes['ShippingMethodLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodLimitsProjection'] = ResolversParentTypes['ShippingMethodLimitsProjection']> = {
  total?: Resolver<ResolversTypes['ShippingMethodLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodQueryResult'] = ResolversParentTypes['ShippingMethodQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodsByCartInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodsByCartInterface'] = ResolversParentTypes['ShippingMethodsByCartInterface']> = {
  __resolveType: TypeResolveFn<'InStore' | 'Query', ParentType, ContextType>;
  shippingMethodsByCart?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType, RequireFields<ShippingMethodsByCartInterfaceShippingMethodsByCartArgs, 'id'>>;
};

export type ShippingRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRate'] = ResolversParentTypes['ShippingRate']> = {
  freeAbove?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  isMatching?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  tiers?: Resolver<Array<ResolversTypes['ShippingRatePriceTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingRateCartClassificationPriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateCartClassificationPriceTier'] = ResolversParentTypes['ShippingRateCartClassificationPriceTier']> = {
  isMatching?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingRateCartScorePriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateCartScorePriceTier'] = ResolversParentTypes['ShippingRateCartScorePriceTier']> = {
  isMatching?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  priceFunction?: Resolver<Maybe<ResolversTypes['PriceFunction']>, ParentType, ContextType>;
  score?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingRateCartValuePriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateCartValuePriceTier'] = ResolversParentTypes['ShippingRateCartValuePriceTier']> = {
  isMatching?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  minimumCentAmount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingRateInputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateInput'] = ResolversParentTypes['ShippingRateInput']> = {
  __resolveType: TypeResolveFn<'ClassificationShippingRateInput' | 'ScoreShippingRateInput', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ShippingRateInputDraftOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateInputDraftOutput'] = ResolversParentTypes['ShippingRateInputDraftOutput']> = {
  __resolveType: TypeResolveFn<'ClassificationShippingRateInputDraftOutput' | 'ScoreShippingRateInputDraftOutput', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ShippingRateInputLocalizedEnumValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateInputLocalizedEnumValue'] = ResolversParentTypes['ShippingRateInputLocalizedEnumValue']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShippingRateInputLocalizedEnumValueLabelArgs>>;
  labelAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingRateInputTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRateInputType'] = ResolversParentTypes['ShippingRateInputType']> = {
  __resolveType: TypeResolveFn<'CartClassificationType' | 'CartScoreType' | 'CartValueType', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ShippingRatePriceTierResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingRatePriceTier'] = ResolversParentTypes['ShippingRatePriceTier']> = {
  __resolveType: TypeResolveFn<'ShippingRateCartClassificationPriceTier' | 'ShippingRateCartScorePriceTier' | 'ShippingRateCartValuePriceTier', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type ShippingTargetResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingTarget'] = ResolversParentTypes['ShippingTarget']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingList'] = ResolversParentTypes['ShoppingList']> = {
  anonymousId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  deleteDaysAfterLastModification?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShoppingListDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  lineItems?: Resolver<Array<ResolversTypes['ShoppingListLineItem']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShoppingListNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShoppingListSlugArgs>>;
  slugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  store?: Resolver<Maybe<ResolversTypes['Store']>, ParentType, ContextType>;
  storeRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  textLineItems?: Resolver<Array<ResolversTypes['TextLineItem']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListLimitWithCurrent'] = ResolversParentTypes['ShoppingListLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListLimitsProjection'] = ResolversParentTypes['ShoppingListLimitsProjection']> = {
  lineItems?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  textLineItems?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['ShoppingListLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListLineItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListLineItem'] = ResolversParentTypes['ShoppingListLineItem']> = {
  addedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  deactivatedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShoppingListLineItemNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  productId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  productSlug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<ShoppingListLineItemProductSlugArgs>>;
  productSlugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  productType?: Resolver<ResolversTypes['ProductTypeDefinition'], ParentType, ContextType>;
  productTypeRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  variantId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListQueryInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListQueryInterface'] = ResolversParentTypes['ShoppingListQueryInterface']> = {
  __resolveType: TypeResolveFn<'InStoreMe' | 'Me' | 'Query', ParentType, ContextType>;
  shoppingList?: Resolver<Maybe<ResolversTypes['ShoppingList']>, ParentType, ContextType, Partial<ShoppingListQueryInterfaceShoppingListArgs>>;
  shoppingLists?: Resolver<ResolversTypes['ShoppingListQueryResult'], ParentType, ContextType, Partial<ShoppingListQueryInterfaceShoppingListsArgs>>;
};

export type ShoppingListQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListQueryResult'] = ResolversParentTypes['ShoppingListQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['ShoppingList']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShoppingListsConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShoppingListsConfiguration'] = ResolversParentTypes['ShoppingListsConfiguration']> = {
  deleteDaysAfterLastModification?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StagedOrderUpdateActionOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagedOrderUpdateActionOutput'] = ResolversParentTypes['StagedOrderUpdateActionOutput']> = {
  __resolveType: TypeResolveFn<'AddStagedOrderCustomLineItemOutput' | 'AddStagedOrderDeliveryOutput' | 'AddStagedOrderDiscountCodeOutput' | 'AddStagedOrderItemShippingAddressOutput' | 'AddStagedOrderLineItemOutput' | 'AddStagedOrderParcelToDeliveryOutput' | 'AddStagedOrderPaymentOutput' | 'AddStagedOrderReturnInfoOutput' | 'AddStagedOrderShoppingListOutput' | 'ChangeStagedOrderCustomLineItemMoneyOutput' | 'ChangeStagedOrderCustomLineItemQuantityOutput' | 'ChangeStagedOrderLineItemQuantityOutput' | 'ChangeStagedOrderOrderStateOutput' | 'ChangeStagedOrderPaymentStateOutput' | 'ChangeStagedOrderShipmentStateOutput' | 'ChangeStagedOrderTaxCalculationModeOutput' | 'ChangeStagedOrderTaxModeOutput' | 'ChangeStagedOrderTaxRoundingModeOutput' | 'ImportStagedOrderCustomLineItemStateOutput' | 'ImportStagedOrderLineItemStateOutput' | 'RecalculateStagedOrderOutput' | 'RemoveStagedOrderCustomLineItemOutput' | 'RemoveStagedOrderDeliveryOutput' | 'RemoveStagedOrderDiscountCodeOutput' | 'RemoveStagedOrderItemShippingAddressOutput' | 'RemoveStagedOrderLineItemOutput' | 'RemoveStagedOrderParcelFromDeliveryOutput' | 'RemoveStagedOrderPaymentOutput' | 'SetStagedOrderBillingAddressCustomFieldOutput' | 'SetStagedOrderBillingAddressCustomTypeOutput' | 'SetStagedOrderBillingAddressOutput' | 'SetStagedOrderCountryOutput' | 'SetStagedOrderCustomFieldOutput' | 'SetStagedOrderCustomLineItemCustomFieldOutput' | 'SetStagedOrderCustomLineItemCustomTypeOutput' | 'SetStagedOrderCustomLineItemShippingDetailsOutput' | 'SetStagedOrderCustomLineItemTaxAmountOutput' | 'SetStagedOrderCustomLineItemTaxRateOutput' | 'SetStagedOrderCustomShippingMethodOutput' | 'SetStagedOrderCustomTypeOutput' | 'SetStagedOrderCustomerEmailOutput' | 'SetStagedOrderCustomerGroupOutput' | 'SetStagedOrderCustomerIdOutput' | 'SetStagedOrderDeliveryAddressCustomFieldOutput' | 'SetStagedOrderDeliveryAddressCustomTypeOutput' | 'SetStagedOrderDeliveryAddressOutput' | 'SetStagedOrderDeliveryCustomFieldOutput' | 'SetStagedOrderDeliveryCustomTypeOutput' | 'SetStagedOrderDeliveryItemsOutput' | 'SetStagedOrderDirectDiscountsOutput' | 'SetStagedOrderItemShippingAddressCustomFieldOutput' | 'SetStagedOrderItemShippingAddressCustomTypeOutput' | 'SetStagedOrderLineItemCustomFieldOutput' | 'SetStagedOrderLineItemCustomTypeOutput' | 'SetStagedOrderLineItemDistributionChannelOutput' | 'SetStagedOrderLineItemPriceOutput' | 'SetStagedOrderLineItemShippingDetailsOutput' | 'SetStagedOrderLineItemTaxAmountOutput' | 'SetStagedOrderLineItemTaxRateOutput' | 'SetStagedOrderLineItemTotalPriceOutput' | 'SetStagedOrderLocaleOutput' | 'SetStagedOrderOrderNumberOutput' | 'SetStagedOrderOrderTotalTaxOutput' | 'SetStagedOrderParcelCustomFieldOutput' | 'SetStagedOrderParcelCustomTypeOutput' | 'SetStagedOrderParcelItemsOutput' | 'SetStagedOrderParcelMeasurementsOutput' | 'SetStagedOrderParcelTrackingDataOutput' | 'SetStagedOrderPurchaseOrderNumberOutput' | 'SetStagedOrderReturnInfoOutput' | 'SetStagedOrderReturnItemCustomFieldOutput' | 'SetStagedOrderReturnItemCustomTypeOutput' | 'SetStagedOrderReturnPaymentStateOutput' | 'SetStagedOrderReturnShipmentStateOutput' | 'SetStagedOrderShippingAddressAndCustomShippingMethodOutput' | 'SetStagedOrderShippingAddressAndShippingMethodOutput' | 'SetStagedOrderShippingAddressCustomFieldOutput' | 'SetStagedOrderShippingAddressCustomTypeOutput' | 'SetStagedOrderShippingAddressOutput' | 'SetStagedOrderShippingCustomFieldOutput' | 'SetStagedOrderShippingCustomTypeOutput' | 'SetStagedOrderShippingMethodOutput' | 'SetStagedOrderShippingMethodTaxAmountOutput' | 'SetStagedOrderShippingMethodTaxRateOutput' | 'SetStagedOrderShippingRateInputOutput' | 'SetStagedOrderStoreOutput' | 'TransitionStagedOrderCustomLineItemStateOutput' | 'TransitionStagedOrderLineItemStateOutput' | 'TransitionStagedOrderStateOutput' | 'UpdateStagedOrderItemShippingAddressOutput' | 'UpdateStagedOrderSyncInfoOutput', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type StagedQuoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagedQuote'] = ResolversParentTypes['StagedQuote']> = {
  businessUnit?: Resolver<Maybe<ResolversTypes['BusinessUnit']>, ParentType, ContextType>;
  businessUnitRef?: Resolver<Maybe<ResolversTypes['KeyReference']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customer?: Resolver<Maybe<ResolversTypes['Customer']>, ParentType, ContextType>;
  customerRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  purchaseOrderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quotationCart?: Resolver<Maybe<ResolversTypes['Cart']>, ParentType, ContextType>;
  quotationCartRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  quoteRequest?: Resolver<Maybe<ResolversTypes['QuoteRequest']>, ParentType, ContextType>;
  quoteRequestRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  sellerComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stagedQuoteState?: Resolver<ResolversTypes['StagedQuoteState'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['State']>, ParentType, ContextType>;
  stateRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  validTo?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StagedQuoteQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagedQuoteQueryResult'] = ResolversParentTypes['StagedQuoteQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['StagedQuote']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StagedStandalonePriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['StagedStandalonePrice'] = ResolversParentTypes['StagedStandalonePrice']> = {
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePrice'] = ResolversParentTypes['StandalonePrice']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['Country']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  customerGroup?: Resolver<Maybe<ResolversTypes['CustomerGroup']>, ParentType, ContextType>;
  customerGroupRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  sku?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  staged?: Resolver<Maybe<ResolversTypes['StagedStandalonePrice']>, ParentType, ContextType>;
  tiers?: Resolver<Maybe<Array<ResolversTypes['ProductPriceTier']>>, ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceActiveChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceActiveChanged'] = ResolversParentTypes['StandalonePriceActiveChanged']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  oldActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceCreated'] = ResolversParentTypes['StandalonePriceCreated']> = {
  standalonePrice?: Resolver<ResolversTypes['StandalonePrice'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceDeleted'] = ResolversParentTypes['StandalonePriceDeleted']> = {
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceDiscountSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceDiscountSet'] = ResolversParentTypes['StandalonePriceDiscountSet']> = {
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceExpiresAtSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceExpiresAtSet'] = ResolversParentTypes['StandalonePriceExpiresAtSet']> = {
  expiresAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceExternalDiscountSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceExternalDiscountSet'] = ResolversParentTypes['StandalonePriceExternalDiscountSet']> = {
  discounted?: Resolver<Maybe<ResolversTypes['DiscountedProductPriceValue']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceKeySetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceKeySet'] = ResolversParentTypes['StandalonePriceKeySet']> = {
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oldKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceQueryResult'] = ResolversParentTypes['StandalonePriceQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['StandalonePrice']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceStagedChangesAppliedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceStagedChangesApplied'] = ResolversParentTypes['StandalonePriceStagedChangesApplied']> = {
  stagedChanges?: Resolver<ResolversTypes['StagedStandalonePrice'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceStagedChangesRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceStagedChangesRemoved'] = ResolversParentTypes['StandalonePriceStagedChangesRemoved']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceTierAddedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceTierAdded'] = ResolversParentTypes['StandalonePriceTierAdded']> = {
  tier?: Resolver<ResolversTypes['ProductPriceTier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceTierRemovedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceTierRemoved'] = ResolversParentTypes['StandalonePriceTierRemoved']> = {
  tier?: Resolver<ResolversTypes['ProductPriceTier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceTiersSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceTiersSet'] = ResolversParentTypes['StandalonePriceTiersSet']> = {
  previousTiers?: Resolver<Array<ResolversTypes['ProductPriceTier']>, ParentType, ContextType>;
  tiers?: Resolver<Array<ResolversTypes['ProductPriceTier']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceValidFromAndUntilSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceValidFromAndUntilSet'] = ResolversParentTypes['StandalonePriceValidFromAndUntilSet']> = {
  previousValidFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  previousValidUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceValidFromSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceValidFromSet'] = ResolversParentTypes['StandalonePriceValidFromSet']> = {
  previousValidFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validFrom?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceValidUntilSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceValidUntilSet'] = ResolversParentTypes['StandalonePriceValidUntilSet']> = {
  previousValidUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  validUntil?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StandalonePriceValueChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StandalonePriceValueChanged'] = ResolversParentTypes['StandalonePriceValueChanged']> = {
  oldValue?: Resolver<Maybe<ResolversTypes['BaseMoney']>, ParentType, ContextType>;
  staged?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['BaseMoney'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StateResolvers<ContextType = any, ParentType extends ResolversParentTypes['State'] = ResolversParentTypes['State']> = {
  builtIn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<StateDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  initial?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<StateNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  roles?: Resolver<Array<ResolversTypes['StateRole']>, ParentType, ContextType>;
  transitions?: Resolver<Maybe<Array<ResolversTypes['State']>>, ParentType, ContextType>;
  transitionsRef?: Resolver<Maybe<Array<ResolversTypes['Reference']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['StateType'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StateQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['StateQueryResult'] = ResolversParentTypes['StateQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['State']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreResolvers<ContextType = any, ParentType extends ResolversParentTypes['Store'] = ResolversParentTypes['Store']> = {
  countries?: Resolver<Maybe<Array<ResolversTypes['StoreCountry']>>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  distributionChannels?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  distributionChannelsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  languages?: Resolver<Maybe<Array<ResolversTypes['Locale']>>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<StoreNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  productSelections?: Resolver<Array<ResolversTypes['ProductSelectionSetting']>, ParentType, ContextType>;
  supplyChannels?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreCountriesChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreCountriesChanged'] = ResolversParentTypes['StoreCountriesChanged']> = {
  addedCountries?: Resolver<Maybe<Array<ResolversTypes['StoreCountry']>>, ParentType, ContextType>;
  removedCountries?: Resolver<Maybe<Array<ResolversTypes['StoreCountry']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreCountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreCountry'] = ResolversParentTypes['StoreCountry']> = {
  code?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreCreated'] = ResolversParentTypes['StoreCreated']> = {
  countries?: Resolver<Maybe<Array<ResolversTypes['StoreCountry']>>, ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  distributionChannels?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  distributionChannelsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  languages?: Resolver<Array<ResolversTypes['Locale']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<StoreCreatedNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  productSelections?: Resolver<Array<ResolversTypes['ProductSelectionSetting']>, ParentType, ContextType>;
  productSelectionsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  supplyChannels?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  supplyChannelsRef?: Resolver<Array<ResolversTypes['Reference']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreDeleted'] = ResolversParentTypes['StoreDeleted']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreDistributionChannelsChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreDistributionChannelsChanged'] = ResolversParentTypes['StoreDistributionChannelsChanged']> = {
  addedDistributionChannels?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType>;
  addedDistributionChannelsRef?: Resolver<Maybe<Array<ResolversTypes['Reference']>>, ParentType, ContextType>;
  removedDistributionChannels?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType>;
  removedDistributionChannelsRef?: Resolver<Maybe<Array<ResolversTypes['Reference']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreLanguagesChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreLanguagesChanged'] = ResolversParentTypes['StoreLanguagesChanged']> = {
  addedLanguages?: Resolver<Maybe<Array<ResolversTypes['Locale']>>, ParentType, ContextType>;
  removedLanguages?: Resolver<Maybe<Array<ResolversTypes['Locale']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreLimitWithCurrent'] = ResolversParentTypes['StoreLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreLimitsProjection'] = ResolversParentTypes['StoreLimitsProjection']> = {
  inventorySupplyChannels?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  productDistributionChannels?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  productSelections?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['StoreLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreNameSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreNameSet'] = ResolversParentTypes['StoreNameSet']> = {
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<StoreNameSetNameArgs>>;
  nameAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreProductSelectionsChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreProductSelectionsChanged'] = ResolversParentTypes['StoreProductSelectionsChanged']> = {
  addedProductSelections?: Resolver<Maybe<Array<ResolversTypes['ProductSelectionSetting']>>, ParentType, ContextType>;
  removedProductSelections?: Resolver<Maybe<Array<ResolversTypes['ProductSelectionSetting']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  updatedProductSelections?: Resolver<Maybe<Array<ResolversTypes['ProductSelectionSetting']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreQueryResult'] = ResolversParentTypes['StoreQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Store']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StoreSupplyChannelsChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StoreSupplyChannelsChanged'] = ResolversParentTypes['StoreSupplyChannelsChanged']> = {
  addedSupplyChannels?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType>;
  addedSupplyChannelsRef?: Resolver<Maybe<Array<ResolversTypes['Reference']>>, ParentType, ContextType>;
  removedSupplyChannels?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType>;
  removedSupplyChannelsRef?: Resolver<Maybe<Array<ResolversTypes['Reference']>>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StringAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StringAttribute'] = ResolversParentTypes['StringAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StringFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['StringField'] = ResolversParentTypes['StringField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StringTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StringType'] = ResolversParentTypes['StringType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubRate'] = ResolversParentTypes['SubRate']> = {
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionsLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SubscriptionsLimitsProjection'] = ResolversParentTypes['SubscriptionsLimitsProjection']> = {
  maxSubscriptions?: Resolver<ResolversTypes['Limit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SuggestResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['SuggestResult'] = ResolversParentTypes['SuggestResult']> = {
  searchKeywords?: Resolver<Array<ResolversTypes['SuggestResultEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SuggestResultEntryResolvers<ContextType = any, ParentType extends ResolversParentTypes['SuggestResultEntry'] = ResolversParentTypes['SuggestResultEntry']> = {
  locale?: Resolver<ResolversTypes['Locale'], ParentType, ContextType>;
  suggestions?: Resolver<Array<ResolversTypes['Suggestion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SuggestTokenizerResolvers<ContextType = any, ParentType extends ResolversParentTypes['SuggestTokenizer'] = ResolversParentTypes['SuggestTokenizer']> = {
  __resolveType: TypeResolveFn<'CustomSuggestTokenizer' | 'WhitespaceSuggestTokenizer', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SuggestTokenizerProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['SuggestTokenizerProductSearch'] = ResolversParentTypes['SuggestTokenizerProductSearch']> = {
  __resolveType: TypeResolveFn<'CustomSuggestTokenizerProductSearch' | 'WhitespaceSuggestTokenizerProductSearch', ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
};

export type SuggestionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Suggestion'] = ResolversParentTypes['Suggestion']> = {
  text?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SyncInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['SyncInfo'] = ResolversParentTypes['SyncInfo']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelRef?: Resolver<ResolversTypes['Reference'], ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  syncedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxCategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxCategory'] = ResolversParentTypes['TaxCategory']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rates?: Resolver<Array<ResolversTypes['TaxRate']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxCategoryLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxCategoryLimitWithCurrent'] = ResolversParentTypes['TaxCategoryLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxCategoryLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxCategoryLimitsProjection'] = ResolversParentTypes['TaxCategoryLimitsProjection']> = {
  total?: Resolver<ResolversTypes['TaxCategoryLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxCategoryQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxCategoryQueryResult'] = ResolversParentTypes['TaxCategoryQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['TaxCategory']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxPortionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxPortion'] = ResolversParentTypes['TaxPortion']> = {
  amount?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxRate'] = ResolversParentTypes['TaxRate']> = {
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  country?: Resolver<ResolversTypes['Country'], ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  includedInPrice?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subRates?: Resolver<Array<ResolversTypes['SubRate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxedItemPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxedItemPrice'] = ResolversParentTypes['TaxedItemPrice']> = {
  totalGross?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalNet?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalTax?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxedPriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxedPrice'] = ResolversParentTypes['TaxedPrice']> = {
  taxPortions?: Resolver<Array<ResolversTypes['TaxPortion']>, ParentType, ContextType>;
  totalGross?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalNet?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalTax?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TermCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['TermCount'] = ResolversParentTypes['TermCount']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  productCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  term?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TermsFacetResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['TermsFacetResult'] = ResolversParentTypes['TermsFacetResult']> = {
  dataType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  missing?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  other?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  terms?: Resolver<Array<ResolversTypes['TermCount']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TextAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TextAttributeDefinitionType'] = ResolversParentTypes['TextAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TextLineItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['TextLineItem'] = ResolversParentTypes['TextLineItem']> = {
  addedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<TextLineItemDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<TextLineItemNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface TimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Time'], any> {
  name: 'Time';
}

export type TimeAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeAttribute'] = ResolversParentTypes['TimeAttribute']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeAttributeDefinitionTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeAttributeDefinitionType'] = ResolversParentTypes['TimeAttributeDefinitionType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeFieldResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeField'] = ResolversParentTypes['TimeField']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Time'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimeTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeType'] = ResolversParentTypes['TimeType']> = {
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TrackingDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['TrackingData'] = ResolversParentTypes['TrackingData']> = {
  carrier?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isReturn?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  provider?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  providerTransaction?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = {
  amount?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  custom?: Resolver<Maybe<ResolversTypes['CustomFieldsType']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  interactionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  state?: Resolver<ResolversTypes['TransactionState'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['TransactionType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransitionStagedOrderCustomLineItemStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransitionStagedOrderCustomLineItemStateOutput'] = ResolversParentTypes['TransitionStagedOrderCustomLineItemStateOutput']> = {
  actualTransitionDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  customLineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  customLineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fromStateResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  toStateResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransitionStagedOrderLineItemStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransitionStagedOrderLineItemStateOutput'] = ResolversParentTypes['TransitionStagedOrderLineItemStateOutput']> = {
  actualTransitionDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  fromStateResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  lineItemId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lineItemKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  toStateResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransitionStagedOrderStateOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransitionStagedOrderStateOutput'] = ResolversParentTypes['TransitionStagedOrderStateOutput']> = {
  force?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  stateResId?: Resolver<ResolversTypes['ResourceIdentifier'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Trigger'] = ResolversParentTypes['Trigger']> = {
  actions?: Resolver<Array<ResolversTypes['ActionType']>, ParentType, ContextType>;
  condition?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  resourceTypeId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TypeDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TypeDefinition'] = ResolversParentTypes['TypeDefinition']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<TypeDefinitionDescriptionArgs>>;
  descriptionAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  fieldDefinitions?: Resolver<Array<ResolversTypes['FieldDefinition']>, ParentType, ContextType, Partial<TypeDefinitionFieldDefinitionsArgs>>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<TypeDefinitionNameArgs>>;
  nameAllLocales?: Resolver<Array<ResolversTypes['LocalizedString']>, ParentType, ContextType>;
  resourceTypeIds?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TypeDefinitionQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['TypeDefinitionQueryResult'] = ResolversParentTypes['TypeDefinitionQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['TypeDefinition']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateStagedOrderItemShippingAddressOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateStagedOrderItemShippingAddressOutput'] = ResolversParentTypes['UpdateStagedOrderItemShippingAddressOutput']> = {
  address?: Resolver<ResolversTypes['AddressDraft'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateStagedOrderSyncInfoOutputResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateStagedOrderSyncInfoOutput'] = ResolversParentTypes['UpdateStagedOrderSyncInfoOutput']> = {
  channelResId?: Resolver<ResolversTypes['ChannelReferenceIdentifier'], ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  syncedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserProvidedIdentifiersResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserProvidedIdentifiers'] = ResolversParentTypes['UserProvidedIdentifiers']> = {
  customerNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<UserProvidedIdentifiersSlugArgs>>;
  slugAllLocales?: Resolver<Maybe<Array<ResolversTypes['LocalizedString']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ValueFacetResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ValueFacetResult'] = ResolversParentTypes['ValueFacetResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  productCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VersionedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Versioned'] = ResolversParentTypes['Versioned']> = {
  __resolveType: TypeResolveFn<'ApprovalFlow' | 'ApprovalRule' | 'AssociateRole' | 'AttributeGroup' | 'BusinessUnit' | 'Cart' | 'CartDiscount' | 'Category' | 'Channel' | 'CommercetoolsSubscription' | 'CustomObject' | 'Customer' | 'CustomerEmailToken' | 'CustomerGroup' | 'CustomerPasswordToken' | 'DiscountCode' | 'Extension' | 'InventoryEntry' | 'Message' | 'Order' | 'OrderEdit' | 'Payment' | 'Product' | 'ProductDiscount' | 'ProductSelection' | 'ProductTypeDefinition' | 'Quote' | 'QuoteRequest' | 'Review' | 'ShippingMethod' | 'ShoppingList' | 'StagedQuote' | 'StandalonePrice' | 'State' | 'Store' | 'TaxCategory' | 'TypeDefinition' | 'Zone', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
};

export type WhitespaceSuggestTokenizerResolvers<ContextType = any, ParentType extends ResolversParentTypes['WhitespaceSuggestTokenizer'] = ResolversParentTypes['WhitespaceSuggestTokenizer']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WhitespaceSuggestTokenizerProductSearchResolvers<ContextType = any, ParentType extends ResolversParentTypes['WhitespaceSuggestTokenizerProductSearch'] = ResolversParentTypes['WhitespaceSuggestTokenizerProductSearch']> = {
  type?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface YearMonthScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['YearMonth'], any> {
  name: 'YearMonth';
}

export type ZoneResolvers<ContextType = any, ParentType extends ResolversParentTypes['Zone'] = ResolversParentTypes['Zone']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastModifiedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lastModifiedBy?: Resolver<Maybe<ResolversTypes['Initiator']>, ParentType, ContextType>;
  locations?: Resolver<Array<ResolversTypes['Location']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ZoneLimitWithCurrentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ZoneLimitWithCurrent'] = ResolversParentTypes['ZoneLimitWithCurrent']> = {
  current?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  limit?: Resolver<Maybe<ResolversTypes['Long']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ZoneLimitsProjectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ZoneLimitsProjection'] = ResolversParentTypes['ZoneLimitsProjection']> = {
  total?: Resolver<ResolversTypes['ZoneLimitWithCurrent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ZoneQueryResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ZoneQueryResult'] = ResolversParentTypes['ZoneQueryResult']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  exists?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  results?: Resolver<Array<ResolversTypes['Zone']>, ParentType, ContextType>;
  total?: Resolver<ResolversTypes['Long'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ZoneRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ZoneRate'] = ResolversParentTypes['ZoneRate']> = {
  shippingRates?: Resolver<Array<ResolversTypes['ShippingRate']>, ParentType, ContextType>;
  zone?: Resolver<Maybe<ResolversTypes['Zone']>, ParentType, ContextType>;
  zoneRef?: Resolver<Maybe<ResolversTypes['Reference']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  APIClientWithSecret?: ApiClientWithSecretResolvers<ContextType>;
  APIClientWithoutSecret?: ApiClientWithoutSecretResolvers<ContextType>;
  APIClientWithoutSecretQueryResult?: ApiClientWithoutSecretQueryResultResolvers<ContextType>;
  AWSLambdaDestination?: AwsLambdaDestinationResolvers<ContextType>;
  AbsoluteDiscountValue?: AbsoluteDiscountValueResolvers<ContextType>;
  ActiveCartInterface?: ActiveCartInterfaceResolvers<ContextType>;
  AddStagedOrderCustomLineItemOutput?: AddStagedOrderCustomLineItemOutputResolvers<ContextType>;
  AddStagedOrderDeliveryOutput?: AddStagedOrderDeliveryOutputResolvers<ContextType>;
  AddStagedOrderDiscountCodeOutput?: AddStagedOrderDiscountCodeOutputResolvers<ContextType>;
  AddStagedOrderItemShippingAddressOutput?: AddStagedOrderItemShippingAddressOutputResolvers<ContextType>;
  AddStagedOrderLineItemOutput?: AddStagedOrderLineItemOutputResolvers<ContextType>;
  AddStagedOrderParcelToDeliveryOutput?: AddStagedOrderParcelToDeliveryOutputResolvers<ContextType>;
  AddStagedOrderPaymentOutput?: AddStagedOrderPaymentOutputResolvers<ContextType>;
  AddStagedOrderReturnInfoOutput?: AddStagedOrderReturnInfoOutputResolvers<ContextType>;
  AddStagedOrderShoppingListOutput?: AddStagedOrderShoppingListOutputResolvers<ContextType>;
  Address?: AddressResolvers<ContextType>;
  AddressDraft?: AddressDraftResolvers<ContextType>;
  Applied?: AppliedResolvers<ContextType>;
  ApprovalFlow?: ApprovalFlowResolvers<ContextType>;
  ApprovalFlowApproval?: ApprovalFlowApprovalResolvers<ContextType>;
  ApprovalFlowApproved?: ApprovalFlowApprovedResolvers<ContextType>;
  ApprovalFlowCompleted?: ApprovalFlowCompletedResolvers<ContextType>;
  ApprovalFlowCreated?: ApprovalFlowCreatedResolvers<ContextType>;
  ApprovalFlowQueryResult?: ApprovalFlowQueryResultResolvers<ContextType>;
  ApprovalFlowRejected?: ApprovalFlowRejectedResolvers<ContextType>;
  ApprovalFlowRejection?: ApprovalFlowRejectionResolvers<ContextType>;
  ApprovalRule?: ApprovalRuleResolvers<ContextType>;
  ApprovalRuleQueryResult?: ApprovalRuleQueryResultResolvers<ContextType>;
  ApproverConjunction?: ApproverConjunctionResolvers<ContextType>;
  ApproverDisjunction?: ApproverDisjunctionResolvers<ContextType>;
  ApproverHierarchy?: ApproverHierarchyResolvers<ContextType>;
  AsAssociate?: AsAssociateResolvers<ContextType>;
  Asset?: AssetResolvers<ContextType>;
  AssetDimensions?: AssetDimensionsResolvers<ContextType>;
  AssetSource?: AssetSourceResolvers<ContextType>;
  Associate?: AssociateResolvers<ContextType>;
  AssociateRole?: AssociateRoleResolvers<ContextType>;
  AssociateRoleAssignment?: AssociateRoleAssignmentResolvers<ContextType>;
  AssociateRoleBuyerAssignableChanged?: AssociateRoleBuyerAssignableChangedResolvers<ContextType>;
  AssociateRoleCreated?: AssociateRoleCreatedResolvers<ContextType>;
  AssociateRoleDeleted?: AssociateRoleDeletedResolvers<ContextType>;
  AssociateRoleNameSet?: AssociateRoleNameSetResolvers<ContextType>;
  AssociateRolePermissionAdded?: AssociateRolePermissionAddedResolvers<ContextType>;
  AssociateRolePermissionRemoved?: AssociateRolePermissionRemovedResolvers<ContextType>;
  AssociateRolePermissionsSet?: AssociateRolePermissionsSetResolvers<ContextType>;
  AssociateRoleQueryResult?: AssociateRoleQueryResultResolvers<ContextType>;
  Attribute?: AttributeResolvers<ContextType>;
  AttributeDefinition?: AttributeDefinitionResolvers<ContextType>;
  AttributeDefinitionResult?: AttributeDefinitionResultResolvers<ContextType>;
  AttributeDefinitionType?: AttributeDefinitionTypeResolvers<ContextType>;
  AttributeGroup?: AttributeGroupResolvers<ContextType>;
  AttributeGroupLimitWithCurrent?: AttributeGroupLimitWithCurrentResolvers<ContextType>;
  AttributeGroupLimitsProjection?: AttributeGroupLimitsProjectionResolvers<ContextType>;
  AttributeGroupQueryResult?: AttributeGroupQueryResultResolvers<ContextType>;
  AttributeReference?: AttributeReferenceResolvers<ContextType>;
  AuthorizationHeader?: AuthorizationHeaderResolvers<ContextType>;
  AzureFunctionsAuthentication?: AzureFunctionsAuthenticationResolvers<ContextType>;
  AzureServiceBusDestination?: AzureServiceBusDestinationResolvers<ContextType>;
  BaseMoney?: BaseMoneyResolvers<ContextType>;
  BigDecimal?: GraphQLScalarType;
  BooleanAttribute?: BooleanAttributeResolvers<ContextType>;
  BooleanAttributeDefinitionType?: BooleanAttributeDefinitionTypeResolvers<ContextType>;
  BooleanField?: BooleanFieldResolvers<ContextType>;
  BooleanType?: BooleanTypeResolvers<ContextType>;
  BusinessUnit?: BusinessUnitResolvers<ContextType>;
  BusinessUnitAddressAdded?: BusinessUnitAddressAddedResolvers<ContextType>;
  BusinessUnitAddressChanged?: BusinessUnitAddressChangedResolvers<ContextType>;
  BusinessUnitAddressRemoved?: BusinessUnitAddressRemovedResolvers<ContextType>;
  BusinessUnitAssociateAdded?: BusinessUnitAssociateAddedResolvers<ContextType>;
  BusinessUnitAssociateChanged?: BusinessUnitAssociateChangedResolvers<ContextType>;
  BusinessUnitAssociateModeChanged?: BusinessUnitAssociateModeChangedResolvers<ContextType>;
  BusinessUnitAssociateRemoved?: BusinessUnitAssociateRemovedResolvers<ContextType>;
  BusinessUnitAssociatesSet?: BusinessUnitAssociatesSetResolvers<ContextType>;
  BusinessUnitBillingAddressAdded?: BusinessUnitBillingAddressAddedResolvers<ContextType>;
  BusinessUnitBillingAddressRemoved?: BusinessUnitBillingAddressRemovedResolvers<ContextType>;
  BusinessUnitConfiguration?: BusinessUnitConfigurationResolvers<ContextType>;
  BusinessUnitContactEmailSet?: BusinessUnitContactEmailSetResolvers<ContextType>;
  BusinessUnitCreated?: BusinessUnitCreatedResolvers<ContextType>;
  BusinessUnitDefaultBillingAddressSet?: BusinessUnitDefaultBillingAddressSetResolvers<ContextType>;
  BusinessUnitDefaultShippingAddressSet?: BusinessUnitDefaultShippingAddressSetResolvers<ContextType>;
  BusinessUnitDeleted?: BusinessUnitDeletedResolvers<ContextType>;
  BusinessUnitNameChanged?: BusinessUnitNameChangedResolvers<ContextType>;
  BusinessUnitParentChanged?: BusinessUnitParentChangedResolvers<ContextType>;
  BusinessUnitQueryResult?: BusinessUnitQueryResultResolvers<ContextType>;
  BusinessUnitShippingAddressAdded?: BusinessUnitShippingAddressAddedResolvers<ContextType>;
  BusinessUnitShippingAddressRemoved?: BusinessUnitShippingAddressRemovedResolvers<ContextType>;
  BusinessUnitStatusChanged?: BusinessUnitStatusChangedResolvers<ContextType>;
  BusinessUnitStoreAdded?: BusinessUnitStoreAddedResolvers<ContextType>;
  BusinessUnitStoreModeChanged?: BusinessUnitStoreModeChangedResolvers<ContextType>;
  BusinessUnitStoreRemoved?: BusinessUnitStoreRemovedResolvers<ContextType>;
  BusinessUnitStoresSet?: BusinessUnitStoresSetResolvers<ContextType>;
  Cart?: CartResolvers<ContextType>;
  CartClassificationType?: CartClassificationTypeResolvers<ContextType>;
  CartCreated?: CartCreatedResolvers<ContextType>;
  CartDiscount?: CartDiscountResolvers<ContextType>;
  CartDiscountLimitWithCurrent?: CartDiscountLimitWithCurrentResolvers<ContextType>;
  CartDiscountLimitsProjection?: CartDiscountLimitsProjectionResolvers<ContextType>;
  CartDiscountQueryInterface?: CartDiscountQueryInterfaceResolvers<ContextType>;
  CartDiscountQueryResult?: CartDiscountQueryResultResolvers<ContextType>;
  CartDiscountTarget?: CartDiscountTargetResolvers<ContextType>;
  CartDiscountValue?: CartDiscountValueResolvers<ContextType>;
  CartLimitWithCurrent?: CartLimitWithCurrentResolvers<ContextType>;
  CartLimitsProjection?: CartLimitsProjectionResolvers<ContextType>;
  CartQueryInterface?: CartQueryInterfaceResolvers<ContextType>;
  CartQueryResult?: CartQueryResultResolvers<ContextType>;
  CartScoreType?: CartScoreTypeResolvers<ContextType>;
  CartValueType?: CartValueTypeResolvers<ContextType>;
  CartsConfiguration?: CartsConfigurationResolvers<ContextType>;
  Category?: CategoryResolvers<ContextType>;
  CategoryCreated?: CategoryCreatedResolvers<ContextType>;
  CategoryLimitsProjection?: CategoryLimitsProjectionResolvers<ContextType>;
  CategoryOrderHint?: CategoryOrderHintResolvers<ContextType>;
  CategoryOrderHintProductSearch?: CategoryOrderHintProductSearchResolvers<ContextType>;
  CategoryQueryResult?: CategoryQueryResultResolvers<ContextType>;
  CategorySearch?: CategorySearchResolvers<ContextType>;
  CategorySearchResult?: CategorySearchResultResolvers<ContextType>;
  CategorySlugChanged?: CategorySlugChangedResolvers<ContextType>;
  ChangeStagedOrderCustomLineItemMoneyOutput?: ChangeStagedOrderCustomLineItemMoneyOutputResolvers<ContextType>;
  ChangeStagedOrderCustomLineItemQuantityOutput?: ChangeStagedOrderCustomLineItemQuantityOutputResolvers<ContextType>;
  ChangeStagedOrderLineItemQuantityOutput?: ChangeStagedOrderLineItemQuantityOutputResolvers<ContextType>;
  ChangeStagedOrderOrderStateOutput?: ChangeStagedOrderOrderStateOutputResolvers<ContextType>;
  ChangeStagedOrderPaymentStateOutput?: ChangeStagedOrderPaymentStateOutputResolvers<ContextType>;
  ChangeStagedOrderShipmentStateOutput?: ChangeStagedOrderShipmentStateOutputResolvers<ContextType>;
  ChangeStagedOrderTaxCalculationModeOutput?: ChangeStagedOrderTaxCalculationModeOutputResolvers<ContextType>;
  ChangeStagedOrderTaxModeOutput?: ChangeStagedOrderTaxModeOutputResolvers<ContextType>;
  ChangeStagedOrderTaxRoundingModeOutput?: ChangeStagedOrderTaxRoundingModeOutputResolvers<ContextType>;
  ChangeSubscription?: ChangeSubscriptionResolvers<ContextType>;
  Channel?: ChannelResolvers<ContextType>;
  ChannelQueryResult?: ChannelQueryResultResolvers<ContextType>;
  ChannelReferenceIdentifier?: ChannelReferenceIdentifierResolvers<ContextType>;
  ClassificationShippingRateInput?: ClassificationShippingRateInputResolvers<ContextType>;
  ClassificationShippingRateInputDraftOutput?: ClassificationShippingRateInputDraftOutputResolvers<ContextType>;
  CloudEventsSubscriptionsFormat?: CloudEventsSubscriptionsFormatResolvers<ContextType>;
  CommercetoolsSubscription?: CommercetoolsSubscriptionResolvers<ContextType>;
  CommercetoolsSubscriptionQueryResult?: CommercetoolsSubscriptionQueryResultResolvers<ContextType>;
  ConfluentCloudDestination?: ConfluentCloudDestinationResolvers<ContextType>;
  Country?: GraphQLScalarType;
  Currency?: GraphQLScalarType;
  CustomField?: CustomFieldResolvers<ContextType>;
  CustomFieldsCommand?: CustomFieldsCommandResolvers<ContextType>;
  CustomFieldsType?: CustomFieldsTypeResolvers<ContextType>;
  CustomLineItem?: CustomLineItemResolvers<ContextType>;
  CustomLineItemDraftOutput?: CustomLineItemDraftOutputResolvers<ContextType>;
  CustomLineItemReturnItem?: CustomLineItemReturnItemResolvers<ContextType>;
  CustomLineItemStateTransition?: CustomLineItemStateTransitionResolvers<ContextType>;
  CustomLineItemsTarget?: CustomLineItemsTargetResolvers<ContextType>;
  CustomObject?: CustomObjectResolvers<ContextType>;
  CustomObjectLimitWithCurrent?: CustomObjectLimitWithCurrentResolvers<ContextType>;
  CustomObjectLimitsProjection?: CustomObjectLimitsProjectionResolvers<ContextType>;
  CustomObjectQueryResult?: CustomObjectQueryResultResolvers<ContextType>;
  CustomSuggestTokenizer?: CustomSuggestTokenizerResolvers<ContextType>;
  CustomSuggestTokenizerProductSearch?: CustomSuggestTokenizerProductSearchResolvers<ContextType>;
  Customer?: CustomerResolvers<ContextType>;
  CustomerActiveCartInterface?: CustomerActiveCartInterfaceResolvers<ContextType>;
  CustomerAddressAdded?: CustomerAddressAddedResolvers<ContextType>;
  CustomerAddressChanged?: CustomerAddressChangedResolvers<ContextType>;
  CustomerAddressRemoved?: CustomerAddressRemovedResolvers<ContextType>;
  CustomerCompanyNameSet?: CustomerCompanyNameSetResolvers<ContextType>;
  CustomerCreated?: CustomerCreatedResolvers<ContextType>;
  CustomerDateOfBirthSet?: CustomerDateOfBirthSetResolvers<ContextType>;
  CustomerDeleted?: CustomerDeletedResolvers<ContextType>;
  CustomerEmailChanged?: CustomerEmailChangedResolvers<ContextType>;
  CustomerEmailToken?: CustomerEmailTokenResolvers<ContextType>;
  CustomerEmailTokenCreated?: CustomerEmailTokenCreatedResolvers<ContextType>;
  CustomerEmailVerified?: CustomerEmailVerifiedResolvers<ContextType>;
  CustomerFirstNameSet?: CustomerFirstNameSetResolvers<ContextType>;
  CustomerGroup?: CustomerGroupResolvers<ContextType>;
  CustomerGroupLimitWithCurrent?: CustomerGroupLimitWithCurrentResolvers<ContextType>;
  CustomerGroupLimitsProjection?: CustomerGroupLimitsProjectionResolvers<ContextType>;
  CustomerGroupQueryResult?: CustomerGroupQueryResultResolvers<ContextType>;
  CustomerGroupReferenceIdentifier?: CustomerGroupReferenceIdentifierResolvers<ContextType>;
  CustomerGroupSet?: CustomerGroupSetResolvers<ContextType>;
  CustomerLastNameSet?: CustomerLastNameSetResolvers<ContextType>;
  CustomerLimitWithCurrent?: CustomerLimitWithCurrentResolvers<ContextType>;
  CustomerLimitsProjection?: CustomerLimitsProjectionResolvers<ContextType>;
  CustomerPasswordToken?: CustomerPasswordTokenResolvers<ContextType>;
  CustomerPasswordTokenCreated?: CustomerPasswordTokenCreatedResolvers<ContextType>;
  CustomerPasswordUpdated?: CustomerPasswordUpdatedResolvers<ContextType>;
  CustomerQueryInterface?: CustomerQueryInterfaceResolvers<ContextType>;
  CustomerQueryResult?: CustomerQueryResultResolvers<ContextType>;
  CustomerSearchConfiguration?: CustomerSearchConfigurationResolvers<ContextType>;
  CustomerSignInResult?: CustomerSignInResultResolvers<ContextType>;
  CustomerTitleSet?: CustomerTitleSetResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateAttribute?: DateAttributeResolvers<ContextType>;
  DateAttributeDefinitionType?: DateAttributeDefinitionTypeResolvers<ContextType>;
  DateField?: DateFieldResolvers<ContextType>;
  DateTime?: GraphQLScalarType;
  DateTimeAttribute?: DateTimeAttributeResolvers<ContextType>;
  DateTimeAttributeDefinitionType?: DateTimeAttributeDefinitionTypeResolvers<ContextType>;
  DateTimeField?: DateTimeFieldResolvers<ContextType>;
  DateTimeType?: DateTimeTypeResolvers<ContextType>;
  DateType?: DateTypeResolvers<ContextType>;
  Delivery?: DeliveryResolvers<ContextType>;
  DeliveryAdded?: DeliveryAddedResolvers<ContextType>;
  DeliveryAddressSet?: DeliveryAddressSetResolvers<ContextType>;
  DeliveryItem?: DeliveryItemResolvers<ContextType>;
  DeliveryItemsUpdated?: DeliveryItemsUpdatedResolvers<ContextType>;
  DeliveryRemoved?: DeliveryRemovedResolvers<ContextType>;
  Destination?: DestinationResolvers<ContextType>;
  Dimensions?: DimensionsResolvers<ContextType>;
  DimensionsProductSearch?: DimensionsProductSearchResolvers<ContextType>;
  DirectDiscount?: DirectDiscountResolvers<ContextType>;
  DirectDiscountDraftOutput?: DirectDiscountDraftOutputResolvers<ContextType>;
  DiscountCode?: DiscountCodeResolvers<ContextType>;
  DiscountCodeInfo?: DiscountCodeInfoResolvers<ContextType>;
  DiscountCodeQueryResult?: DiscountCodeQueryResultResolvers<ContextType>;
  DiscountedLineItemPortion?: DiscountedLineItemPortionResolvers<ContextType>;
  DiscountedLineItemPrice?: DiscountedLineItemPriceResolvers<ContextType>;
  DiscountedLineItemPriceForQuantity?: DiscountedLineItemPriceForQuantityResolvers<ContextType>;
  DiscountedProductPriceValue?: DiscountedProductPriceValueResolvers<ContextType>;
  DiscountedProductSearchPriceValue?: DiscountedProductSearchPriceValueResolvers<ContextType>;
  EnumAttribute?: EnumAttributeResolvers<ContextType>;
  EnumAttributeDefinitionType?: EnumAttributeDefinitionTypeResolvers<ContextType>;
  EnumField?: EnumFieldResolvers<ContextType>;
  EnumType?: EnumTypeResolvers<ContextType>;
  EnumValue?: EnumValueResolvers<ContextType>;
  EventBridgeDestination?: EventBridgeDestinationResolvers<ContextType>;
  EventGridDestination?: EventGridDestinationResolvers<ContextType>;
  Extension?: ExtensionResolvers<ContextType>;
  ExtensionDestination?: ExtensionDestinationResolvers<ContextType>;
  ExtensionLimitsProjection?: ExtensionLimitsProjectionResolvers<ContextType>;
  ExtensionQueryResult?: ExtensionQueryResultResolvers<ContextType>;
  ExternalDiscountValue?: ExternalDiscountValueResolvers<ContextType>;
  ExternalLineItemTotalPrice?: ExternalLineItemTotalPriceResolvers<ContextType>;
  ExternalOAuth?: ExternalOAuthResolvers<ContextType>;
  ExternalTaxAmountDraftOutput?: ExternalTaxAmountDraftOutputResolvers<ContextType>;
  ExternalTaxRateDraftOutput?: ExternalTaxRateDraftOutputResolvers<ContextType>;
  FacetResult?: FacetResultResolvers<ContextType>;
  FacetResultValue?: FacetResultValueResolvers<ContextType>;
  FieldDefinition?: FieldDefinitionResolvers<ContextType>;
  FieldType?: FieldTypeResolvers<ContextType>;
  FixedPriceDiscountValue?: FixedPriceDiscountValueResolvers<ContextType>;
  Geometry?: GeometryResolvers<ContextType>;
  GiftLineItemValue?: GiftLineItemValueResolvers<ContextType>;
  GoogleCloudFunctionDestination?: GoogleCloudFunctionDestinationResolvers<ContextType>;
  GoogleCloudPubSubDestination?: GoogleCloudPubSubDestinationResolvers<ContextType>;
  HighPrecisionMoney?: HighPrecisionMoneyResolvers<ContextType>;
  HttpDestination?: HttpDestinationResolvers<ContextType>;
  HttpDestinationAuthentication?: HttpDestinationAuthenticationResolvers<ContextType>;
  Image?: ImageResolvers<ContextType>;
  ImageProductSearch?: ImageProductSearchResolvers<ContextType>;
  ImportStagedOrderCustomLineItemStateOutput?: ImportStagedOrderCustomLineItemStateOutputResolvers<ContextType>;
  ImportStagedOrderLineItemStateOutput?: ImportStagedOrderLineItemStateOutputResolvers<ContextType>;
  InStore?: InStoreResolvers<ContextType>;
  InStoreMe?: InStoreMeResolvers<ContextType>;
  InheritedAssociate?: InheritedAssociateResolvers<ContextType>;
  InheritedAssociateRoleAssignment?: InheritedAssociateRoleAssignmentResolvers<ContextType>;
  InheritedStore?: InheritedStoreResolvers<ContextType>;
  Initiator?: InitiatorResolvers<ContextType>;
  InterfaceInteractionsRaw?: InterfaceInteractionsRawResolvers<ContextType>;
  InterfaceInteractionsRawResult?: InterfaceInteractionsRawResultResolvers<ContextType>;
  InventoryEntry?: InventoryEntryResolvers<ContextType>;
  InventoryEntryCreated?: InventoryEntryCreatedResolvers<ContextType>;
  InventoryEntryDeleted?: InventoryEntryDeletedResolvers<ContextType>;
  InventoryEntryQuantitySet?: InventoryEntryQuantitySetResolvers<ContextType>;
  InventoryEntryQueryResult?: InventoryEntryQueryResultResolvers<ContextType>;
  ItemShippingDetails?: ItemShippingDetailsResolvers<ContextType>;
  ItemShippingDetailsDraftOutput?: ItemShippingDetailsDraftOutputResolvers<ContextType>;
  ItemShippingTarget?: ItemShippingTargetResolvers<ContextType>;
  ItemState?: ItemStateResolvers<ContextType>;
  Json?: GraphQLScalarType;
  KeyReference?: KeyReferenceResolvers<ContextType>;
  KeyReferenceInput?: GraphQLScalarType;
  Limit?: LimitResolvers<ContextType>;
  LimitWithCurrent?: LimitWithCurrentResolvers<ContextType>;
  LineItem?: LineItemResolvers<ContextType>;
  LineItemDraftOutput?: LineItemDraftOutputResolvers<ContextType>;
  LineItemReturnItem?: LineItemReturnItemResolvers<ContextType>;
  LineItemStateTransition?: LineItemStateTransitionResolvers<ContextType>;
  LineItemsTarget?: LineItemsTargetResolvers<ContextType>;
  Locale?: GraphQLScalarType;
  LocalizableEnumAttributeDefinitionType?: LocalizableEnumAttributeDefinitionTypeResolvers<ContextType>;
  LocalizableEnumValueType?: LocalizableEnumValueTypeResolvers<ContextType>;
  LocalizableEnumValueTypeResult?: LocalizableEnumValueTypeResultResolvers<ContextType>;
  LocalizableTextAttributeDefinitionType?: LocalizableTextAttributeDefinitionTypeResolvers<ContextType>;
  LocalizedEnumAttribute?: LocalizedEnumAttributeResolvers<ContextType>;
  LocalizedEnumField?: LocalizedEnumFieldResolvers<ContextType>;
  LocalizedEnumType?: LocalizedEnumTypeResolvers<ContextType>;
  LocalizedEnumValue?: LocalizedEnumValueResolvers<ContextType>;
  LocalizedString?: LocalizedStringResolvers<ContextType>;
  LocalizedStringAttribute?: LocalizedStringAttributeResolvers<ContextType>;
  LocalizedStringField?: LocalizedStringFieldResolvers<ContextType>;
  LocalizedStringType?: LocalizedStringTypeResolvers<ContextType>;
  Location?: LocationResolvers<ContextType>;
  Long?: GraphQLScalarType;
  Me?: MeResolvers<ContextType>;
  MeFieldInterface?: MeFieldInterfaceResolvers<ContextType>;
  MeQueryInterface?: MeQueryInterfaceResolvers<ContextType>;
  Message?: MessageResolvers<ContextType>;
  MessagePayload?: MessagePayloadResolvers<ContextType>;
  MessageQueryResult?: MessageQueryResultResolvers<ContextType>;
  MessageSubscription?: MessageSubscriptionResolvers<ContextType>;
  MessagesConfiguration?: MessagesConfigurationResolvers<ContextType>;
  MethodTaxRate?: MethodTaxRateResolvers<ContextType>;
  MethodTaxedPrice?: MethodTaxedPriceResolvers<ContextType>;
  Money?: MoneyResolvers<ContextType>;
  MoneyAttribute?: MoneyAttributeResolvers<ContextType>;
  MoneyAttributeDefinitionType?: MoneyAttributeDefinitionTypeResolvers<ContextType>;
  MoneyField?: MoneyFieldResolvers<ContextType>;
  MoneyType?: MoneyTypeResolvers<ContextType>;
  MultiBuyCustomLineItemsTarget?: MultiBuyCustomLineItemsTargetResolvers<ContextType>;
  MultiBuyLineItemsTarget?: MultiBuyLineItemsTargetResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  MyPayment?: MyPaymentResolvers<ContextType>;
  MyPaymentQueryResult?: MyPaymentQueryResultResolvers<ContextType>;
  NestedAttributeDefinitionType?: NestedAttributeDefinitionTypeResolvers<ContextType>;
  NotProcessed?: NotProcessedResolvers<ContextType>;
  NotificationFormat?: NotificationFormatResolvers<ContextType>;
  NumberAttribute?: NumberAttributeResolvers<ContextType>;
  NumberAttributeDefinitionType?: NumberAttributeDefinitionTypeResolvers<ContextType>;
  NumberField?: NumberFieldResolvers<ContextType>;
  NumberType?: NumberTypeResolvers<ContextType>;
  Order?: OrderResolvers<ContextType>;
  OrderBillingAddressSet?: OrderBillingAddressSetResolvers<ContextType>;
  OrderCreated?: OrderCreatedResolvers<ContextType>;
  OrderCustomFieldAdded?: OrderCustomFieldAddedResolvers<ContextType>;
  OrderCustomFieldChanged?: OrderCustomFieldChangedResolvers<ContextType>;
  OrderCustomFieldRemoved?: OrderCustomFieldRemovedResolvers<ContextType>;
  OrderCustomLineItemAdded?: OrderCustomLineItemAddedResolvers<ContextType>;
  OrderCustomLineItemDiscountSet?: OrderCustomLineItemDiscountSetResolvers<ContextType>;
  OrderCustomLineItemQuantityChanged?: OrderCustomLineItemQuantityChangedResolvers<ContextType>;
  OrderCustomLineItemRemoved?: OrderCustomLineItemRemovedResolvers<ContextType>;
  OrderCustomTypeRemoved?: OrderCustomTypeRemovedResolvers<ContextType>;
  OrderCustomTypeSet?: OrderCustomTypeSetResolvers<ContextType>;
  OrderCustomerEmailSet?: OrderCustomerEmailSetResolvers<ContextType>;
  OrderCustomerGroupSet?: OrderCustomerGroupSetResolvers<ContextType>;
  OrderCustomerSet?: OrderCustomerSetResolvers<ContextType>;
  OrderDeleted?: OrderDeletedResolvers<ContextType>;
  OrderDiscountCodeAdded?: OrderDiscountCodeAddedResolvers<ContextType>;
  OrderDiscountCodeRemoved?: OrderDiscountCodeRemovedResolvers<ContextType>;
  OrderDiscountCodeStateSet?: OrderDiscountCodeStateSetResolvers<ContextType>;
  OrderEdit?: OrderEditResolvers<ContextType>;
  OrderEditApplied?: OrderEditAppliedResolvers<ContextType>;
  OrderEditLimitWithCurrent?: OrderEditLimitWithCurrentResolvers<ContextType>;
  OrderEditLimitsProjection?: OrderEditLimitsProjectionResolvers<ContextType>;
  OrderEditQueryResult?: OrderEditQueryResultResolvers<ContextType>;
  OrderEditResult?: OrderEditResultResolvers<ContextType>;
  OrderExcerpt?: OrderExcerptResolvers<ContextType>;
  OrderImported?: OrderImportedResolvers<ContextType>;
  OrderLineItemAdded?: OrderLineItemAddedResolvers<ContextType>;
  OrderLineItemDiscountSet?: OrderLineItemDiscountSetResolvers<ContextType>;
  OrderLineItemDistributionChannelSet?: OrderLineItemDistributionChannelSetResolvers<ContextType>;
  OrderLineItemRemoved?: OrderLineItemRemovedResolvers<ContextType>;
  OrderMessagePayload?: OrderMessagePayloadResolvers<ContextType>;
  OrderPaymentAdded?: OrderPaymentAddedResolvers<ContextType>;
  OrderPaymentRemoved?: OrderPaymentRemovedResolvers<ContextType>;
  OrderPaymentStateChanged?: OrderPaymentStateChangedResolvers<ContextType>;
  OrderQueryInterface?: OrderQueryInterfaceResolvers<ContextType>;
  OrderQueryResult?: OrderQueryResultResolvers<ContextType>;
  OrderReturnShipmentStateChanged?: OrderReturnShipmentStateChangedResolvers<ContextType>;
  OrderSearchConfiguration?: OrderSearchConfigurationResolvers<ContextType>;
  OrderShipmentStateChanged?: OrderShipmentStateChangedResolvers<ContextType>;
  OrderShippingAddressSet?: OrderShippingAddressSetResolvers<ContextType>;
  OrderShippingInfoSet?: OrderShippingInfoSetResolvers<ContextType>;
  OrderShippingRateInputSet?: OrderShippingRateInputSetResolvers<ContextType>;
  OrderStateChanged?: OrderStateChangedResolvers<ContextType>;
  OrderStateTransition?: OrderStateTransitionResolvers<ContextType>;
  OrderStoreSet?: OrderStoreSetResolvers<ContextType>;
  Parcel?: ParcelResolvers<ContextType>;
  ParcelAddedToDelivery?: ParcelAddedToDeliveryResolvers<ContextType>;
  ParcelData?: ParcelDataResolvers<ContextType>;
  ParcelItemsUpdated?: ParcelItemsUpdatedResolvers<ContextType>;
  ParcelMeasurements?: ParcelMeasurementsResolvers<ContextType>;
  ParcelMeasurementsUpdated?: ParcelMeasurementsUpdatedResolvers<ContextType>;
  ParcelRemovedFromDelivery?: ParcelRemovedFromDeliveryResolvers<ContextType>;
  ParcelTrackingDataUpdated?: ParcelTrackingDataUpdatedResolvers<ContextType>;
  Payment?: PaymentResolvers<ContextType>;
  PaymentCreated?: PaymentCreatedResolvers<ContextType>;
  PaymentInfo?: PaymentInfoResolvers<ContextType>;
  PaymentInteractionAdded?: PaymentInteractionAddedResolvers<ContextType>;
  PaymentMethodInfo?: PaymentMethodInfoResolvers<ContextType>;
  PaymentQueryResult?: PaymentQueryResultResolvers<ContextType>;
  PaymentStatus?: PaymentStatusResolvers<ContextType>;
  PaymentStatusInterfaceCodeSet?: PaymentStatusInterfaceCodeSetResolvers<ContextType>;
  PaymentStatusStateTransition?: PaymentStatusStateTransitionResolvers<ContextType>;
  PaymentTransactionAdded?: PaymentTransactionAddedResolvers<ContextType>;
  PaymentTransactionStateChanged?: PaymentTransactionStateChangedResolvers<ContextType>;
  PlainEnumValue?: PlainEnumValueResolvers<ContextType>;
  PlainEnumValueResult?: PlainEnumValueResultResolvers<ContextType>;
  PlatformFormat?: PlatformFormatResolvers<ContextType>;
  Point?: PointResolvers<ContextType>;
  PreviewFailure?: PreviewFailureResolvers<ContextType>;
  PreviewSuccess?: PreviewSuccessResolvers<ContextType>;
  PriceFunction?: PriceFunctionResolvers<ContextType>;
  Product?: ProductResolvers<ContextType>;
  ProductAddedToCategory?: ProductAddedToCategoryResolvers<ContextType>;
  ProductAssignment?: ProductAssignmentResolvers<ContextType>;
  ProductAssignmentQueryResult?: ProductAssignmentQueryResultResolvers<ContextType>;
  ProductCatalogData?: ProductCatalogDataResolvers<ContextType>;
  ProductCreated?: ProductCreatedResolvers<ContextType>;
  ProductData?: ProductDataResolvers<ContextType>;
  ProductDeleted?: ProductDeletedResolvers<ContextType>;
  ProductDiscount?: ProductDiscountResolvers<ContextType>;
  ProductDiscountLimitWithCurrent?: ProductDiscountLimitWithCurrentResolvers<ContextType>;
  ProductDiscountLimitsProjection?: ProductDiscountLimitsProjectionResolvers<ContextType>;
  ProductDiscountQueryResult?: ProductDiscountQueryResultResolvers<ContextType>;
  ProductDiscountValue?: ProductDiscountValueResolvers<ContextType>;
  ProductImageAdded?: ProductImageAddedResolvers<ContextType>;
  ProductLimitsProjection?: ProductLimitsProjectionResolvers<ContextType>;
  ProductOfSelection?: ProductOfSelectionResolvers<ContextType>;
  ProductOfSelectionQueryResult?: ProductOfSelectionQueryResultResolvers<ContextType>;
  ProductPrice?: ProductPriceResolvers<ContextType>;
  ProductPriceAdded?: ProductPriceAddedResolvers<ContextType>;
  ProductPriceChanged?: ProductPriceChangedResolvers<ContextType>;
  ProductPriceDiscountUpdateMessagePayload?: ProductPriceDiscountUpdateMessagePayloadResolvers<ContextType>;
  ProductPriceDiscountsSet?: ProductPriceDiscountsSetResolvers<ContextType>;
  ProductPriceExternalDiscountSet?: ProductPriceExternalDiscountSetResolvers<ContextType>;
  ProductPriceKeySet?: ProductPriceKeySetResolvers<ContextType>;
  ProductPriceModeSet?: ProductPriceModeSetResolvers<ContextType>;
  ProductPriceRemoved?: ProductPriceRemovedResolvers<ContextType>;
  ProductPriceSearch?: ProductPriceSearchResolvers<ContextType>;
  ProductPriceTier?: ProductPriceTierResolvers<ContextType>;
  ProductPricesSet?: ProductPricesSetResolvers<ContextType>;
  ProductProjection?: ProductProjectionResolvers<ContextType>;
  ProductProjectionMessagePayload?: ProductProjectionMessagePayloadResolvers<ContextType>;
  ProductProjectionSearchResult?: ProductProjectionSearchResultResolvers<ContextType>;
  ProductPublished?: ProductPublishedResolvers<ContextType>;
  ProductQueryResult?: ProductQueryResultResolvers<ContextType>;
  ProductReferenceIdentifier?: ProductReferenceIdentifierResolvers<ContextType>;
  ProductRemovedFromCategory?: ProductRemovedFromCategoryResolvers<ContextType>;
  ProductRevertedStagedChanges?: ProductRevertedStagedChangesResolvers<ContextType>;
  ProductSearchPriceTier?: ProductSearchPriceTierResolvers<ContextType>;
  ProductSearchVariant?: ProductSearchVariantResolvers<ContextType>;
  ProductSearchVariantAvailabilitiesResult?: ProductSearchVariantAvailabilitiesResultResolvers<ContextType>;
  ProductSearchVariantAvailability?: ProductSearchVariantAvailabilityResolvers<ContextType>;
  ProductSearchVariantAvailabilityWithChannel?: ProductSearchVariantAvailabilityWithChannelResolvers<ContextType>;
  ProductSearchVariantAvailabilityWithChannels?: ProductSearchVariantAvailabilityWithChannelsResolvers<ContextType>;
  ProductSelection?: ProductSelectionResolvers<ContextType>;
  ProductSelectionCreated?: ProductSelectionCreatedResolvers<ContextType>;
  ProductSelectionDeleted?: ProductSelectionDeletedResolvers<ContextType>;
  ProductSelectionProductAdded?: ProductSelectionProductAddedResolvers<ContextType>;
  ProductSelectionProductExcluded?: ProductSelectionProductExcludedResolvers<ContextType>;
  ProductSelectionProductRemoved?: ProductSelectionProductRemovedResolvers<ContextType>;
  ProductSelectionQueryInterface?: ProductSelectionQueryInterfaceResolvers<ContextType>;
  ProductSelectionQueryResult?: ProductSelectionQueryResultResolvers<ContextType>;
  ProductSelectionSetting?: ProductSelectionSettingResolvers<ContextType>;
  ProductSelectionVariantExclusionChanged?: ProductSelectionVariantExclusionChangedResolvers<ContextType>;
  ProductSelectionVariantSelectionChanged?: ProductSelectionVariantSelectionChangedResolvers<ContextType>;
  ProductSlugChanged?: ProductSlugChangedResolvers<ContextType>;
  ProductStateTransition?: ProductStateTransitionResolvers<ContextType>;
  ProductTypeDefinition?: ProductTypeDefinitionResolvers<ContextType>;
  ProductTypeDefinitionQueryResult?: ProductTypeDefinitionQueryResultResolvers<ContextType>;
  ProductTypeLimitWithCurrent?: ProductTypeLimitWithCurrentResolvers<ContextType>;
  ProductTypeLimitsProjection?: ProductTypeLimitsProjectionResolvers<ContextType>;
  ProductUnpublished?: ProductUnpublishedResolvers<ContextType>;
  ProductVariant?: ProductVariantResolvers<ContextType>;
  ProductVariantAdded?: ProductVariantAddedResolvers<ContextType>;
  ProductVariantAvailabilitiesResult?: ProductVariantAvailabilitiesResultResolvers<ContextType>;
  ProductVariantAvailability?: ProductVariantAvailabilityResolvers<ContextType>;
  ProductVariantAvailabilityWithChannel?: ProductVariantAvailabilityWithChannelResolvers<ContextType>;
  ProductVariantAvailabilityWithChannels?: ProductVariantAvailabilityWithChannelsResolvers<ContextType>;
  ProductVariantDeleted?: ProductVariantDeletedResolvers<ContextType>;
  ProductVariantExclusion?: ProductVariantExclusionResolvers<ContextType>;
  ProductVariantSelection?: ProductVariantSelectionResolvers<ContextType>;
  ProductVariantSelectionIncludeAllExcept?: ProductVariantSelectionIncludeAllExceptResolvers<ContextType>;
  ProductVariantSelectionIncludeOnly?: ProductVariantSelectionIncludeOnlyResolvers<ContextType>;
  ProjectCustomLimitsProjection?: ProjectCustomLimitsProjectionResolvers<ContextType>;
  ProjectProjection?: ProjectProjectionResolvers<ContextType>;
  PurchaseOrderNumberSet?: PurchaseOrderNumberSetResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  QueryLimitsProjection?: QueryLimitsProjectionResolvers<ContextType>;
  Quote?: QuoteResolvers<ContextType>;
  QuoteQueryInterface?: QuoteQueryInterfaceResolvers<ContextType>;
  QuoteQueryResult?: QuoteQueryResultResolvers<ContextType>;
  QuoteRequest?: QuoteRequestResolvers<ContextType>;
  QuoteRequestQueryInterface?: QuoteRequestQueryInterfaceResolvers<ContextType>;
  QuoteRequestQueryResult?: QuoteRequestQueryResultResolvers<ContextType>;
  RangeCount?: RangeCountResolvers<ContextType>;
  RangeCountDouble?: RangeCountDoubleResolvers<ContextType>;
  RangeCountLong?: RangeCountLongResolvers<ContextType>;
  RangeFacetResult?: RangeFacetResultResolvers<ContextType>;
  RawCustomField?: RawCustomFieldResolvers<ContextType>;
  RawProductAttribute?: RawProductAttributeResolvers<ContextType>;
  RawProductSearchAttribute?: RawProductSearchAttributeResolvers<ContextType>;
  RecalculateStagedOrderOutput?: RecalculateStagedOrderOutputResolvers<ContextType>;
  Reference?: ReferenceResolvers<ContextType>;
  ReferenceAttribute?: ReferenceAttributeResolvers<ContextType>;
  ReferenceAttributeDefinitionType?: ReferenceAttributeDefinitionTypeResolvers<ContextType>;
  ReferenceExpandable?: ReferenceExpandableResolvers<ContextType>;
  ReferenceField?: ReferenceFieldResolvers<ContextType>;
  ReferenceId?: ReferenceIdResolvers<ContextType>;
  ReferenceType?: ReferenceTypeResolvers<ContextType>;
  RefreshTokenLimitWithCurrent?: RefreshTokenLimitWithCurrentResolvers<ContextType>;
  RefreshTokenLimitsProjection?: RefreshTokenLimitsProjectionResolvers<ContextType>;
  RelativeDiscountValue?: RelativeDiscountValueResolvers<ContextType>;
  RemoveStagedOrderCustomLineItemOutput?: RemoveStagedOrderCustomLineItemOutputResolvers<ContextType>;
  RemoveStagedOrderDeliveryOutput?: RemoveStagedOrderDeliveryOutputResolvers<ContextType>;
  RemoveStagedOrderDiscountCodeOutput?: RemoveStagedOrderDiscountCodeOutputResolvers<ContextType>;
  RemoveStagedOrderItemShippingAddressOutput?: RemoveStagedOrderItemShippingAddressOutputResolvers<ContextType>;
  RemoveStagedOrderLineItemOutput?: RemoveStagedOrderLineItemOutputResolvers<ContextType>;
  RemoveStagedOrderParcelFromDeliveryOutput?: RemoveStagedOrderParcelFromDeliveryOutputResolvers<ContextType>;
  RemoveStagedOrderPaymentOutput?: RemoveStagedOrderPaymentOutputResolvers<ContextType>;
  ResourceIdentifier?: ResourceIdentifierResolvers<ContextType>;
  ReturnInfo?: ReturnInfoResolvers<ContextType>;
  ReturnInfoAdded?: ReturnInfoAddedResolvers<ContextType>;
  ReturnInfoDraftTypeOutput?: ReturnInfoDraftTypeOutputResolvers<ContextType>;
  ReturnInfoSet?: ReturnInfoSetResolvers<ContextType>;
  ReturnItem?: ReturnItemResolvers<ContextType>;
  ReturnItemDraftTypeOutput?: ReturnItemDraftTypeOutputResolvers<ContextType>;
  Review?: ReviewResolvers<ContextType>;
  ReviewCreated?: ReviewCreatedResolvers<ContextType>;
  ReviewQueryResult?: ReviewQueryResultResolvers<ContextType>;
  ReviewRatingSet?: ReviewRatingSetResolvers<ContextType>;
  ReviewRatingStatistics?: ReviewRatingStatisticsResolvers<ContextType>;
  ReviewStateTransition?: ReviewStateTransitionResolvers<ContextType>;
  ReviewTarget?: ReviewTargetResolvers<ContextType>;
  RuleApprover?: RuleApproverResolvers<ContextType>;
  RuleInfo?: RuleInfoResolvers<ContextType>;
  RuleRequester?: RuleRequesterResolvers<ContextType>;
  SNSDestination?: SnsDestinationResolvers<ContextType>;
  SQSDestination?: SqsDestinationResolvers<ContextType>;
  ScopedPrice?: ScopedPriceResolvers<ContextType>;
  ScoreShippingRateInput?: ScoreShippingRateInputResolvers<ContextType>;
  ScoreShippingRateInputDraftOutput?: ScoreShippingRateInputDraftOutputResolvers<ContextType>;
  SearchFilter?: GraphQLScalarType;
  SearchIndexingConfiguration?: SearchIndexingConfigurationResolvers<ContextType>;
  SearchIndexingConfigurationValues?: SearchIndexingConfigurationValuesResolvers<ContextType>;
  SearchKeyword?: SearchKeywordResolvers<ContextType>;
  SearchKeywordProductSearch?: SearchKeywordProductSearchResolvers<ContextType>;
  SearchKeywords?: SearchKeywordsResolvers<ContextType>;
  SearchKeywordsProductSearch?: SearchKeywordsProductSearchResolvers<ContextType>;
  SearchLimitsProjection?: SearchLimitsProjectionResolvers<ContextType>;
  SearchSort?: GraphQLScalarType;
  SelectionOfProduct?: SelectionOfProductResolvers<ContextType>;
  SelectionOfProductQueryResult?: SelectionOfProductQueryResultResolvers<ContextType>;
  Set?: GraphQLScalarType;
  SetAttributeDefinitionType?: SetAttributeDefinitionTypeResolvers<ContextType>;
  SetStagedOrderBillingAddressCustomFieldOutput?: SetStagedOrderBillingAddressCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderBillingAddressCustomTypeOutput?: SetStagedOrderBillingAddressCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderBillingAddressOutput?: SetStagedOrderBillingAddressOutputResolvers<ContextType>;
  SetStagedOrderCountryOutput?: SetStagedOrderCountryOutputResolvers<ContextType>;
  SetStagedOrderCustomFieldOutput?: SetStagedOrderCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderCustomLineItemCustomFieldOutput?: SetStagedOrderCustomLineItemCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderCustomLineItemCustomTypeOutput?: SetStagedOrderCustomLineItemCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderCustomLineItemShippingDetailsOutput?: SetStagedOrderCustomLineItemShippingDetailsOutputResolvers<ContextType>;
  SetStagedOrderCustomLineItemTaxAmountOutput?: SetStagedOrderCustomLineItemTaxAmountOutputResolvers<ContextType>;
  SetStagedOrderCustomLineItemTaxRateOutput?: SetStagedOrderCustomLineItemTaxRateOutputResolvers<ContextType>;
  SetStagedOrderCustomShippingMethodOutput?: SetStagedOrderCustomShippingMethodOutputResolvers<ContextType>;
  SetStagedOrderCustomTypeOutput?: SetStagedOrderCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderCustomerEmailOutput?: SetStagedOrderCustomerEmailOutputResolvers<ContextType>;
  SetStagedOrderCustomerGroupOutput?: SetStagedOrderCustomerGroupOutputResolvers<ContextType>;
  SetStagedOrderCustomerIdOutput?: SetStagedOrderCustomerIdOutputResolvers<ContextType>;
  SetStagedOrderDeliveryAddressCustomFieldOutput?: SetStagedOrderDeliveryAddressCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderDeliveryAddressCustomTypeOutput?: SetStagedOrderDeliveryAddressCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderDeliveryAddressOutput?: SetStagedOrderDeliveryAddressOutputResolvers<ContextType>;
  SetStagedOrderDeliveryCustomFieldOutput?: SetStagedOrderDeliveryCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderDeliveryCustomTypeOutput?: SetStagedOrderDeliveryCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderDeliveryItemsOutput?: SetStagedOrderDeliveryItemsOutputResolvers<ContextType>;
  SetStagedOrderDirectDiscountsOutput?: SetStagedOrderDirectDiscountsOutputResolvers<ContextType>;
  SetStagedOrderItemShippingAddressCustomFieldOutput?: SetStagedOrderItemShippingAddressCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderItemShippingAddressCustomTypeOutput?: SetStagedOrderItemShippingAddressCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderLineItemCustomFieldOutput?: SetStagedOrderLineItemCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderLineItemCustomTypeOutput?: SetStagedOrderLineItemCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderLineItemDistributionChannelOutput?: SetStagedOrderLineItemDistributionChannelOutputResolvers<ContextType>;
  SetStagedOrderLineItemPriceOutput?: SetStagedOrderLineItemPriceOutputResolvers<ContextType>;
  SetStagedOrderLineItemShippingDetailsOutput?: SetStagedOrderLineItemShippingDetailsOutputResolvers<ContextType>;
  SetStagedOrderLineItemTaxAmountOutput?: SetStagedOrderLineItemTaxAmountOutputResolvers<ContextType>;
  SetStagedOrderLineItemTaxRateOutput?: SetStagedOrderLineItemTaxRateOutputResolvers<ContextType>;
  SetStagedOrderLineItemTotalPriceOutput?: SetStagedOrderLineItemTotalPriceOutputResolvers<ContextType>;
  SetStagedOrderLocaleOutput?: SetStagedOrderLocaleOutputResolvers<ContextType>;
  SetStagedOrderOrderNumberOutput?: SetStagedOrderOrderNumberOutputResolvers<ContextType>;
  SetStagedOrderOrderTotalTaxOutput?: SetStagedOrderOrderTotalTaxOutputResolvers<ContextType>;
  SetStagedOrderParcelCustomFieldOutput?: SetStagedOrderParcelCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderParcelCustomTypeOutput?: SetStagedOrderParcelCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderParcelItemsOutput?: SetStagedOrderParcelItemsOutputResolvers<ContextType>;
  SetStagedOrderParcelMeasurementsOutput?: SetStagedOrderParcelMeasurementsOutputResolvers<ContextType>;
  SetStagedOrderParcelTrackingDataOutput?: SetStagedOrderParcelTrackingDataOutputResolvers<ContextType>;
  SetStagedOrderPurchaseOrderNumberOutput?: SetStagedOrderPurchaseOrderNumberOutputResolvers<ContextType>;
  SetStagedOrderReturnInfoOutput?: SetStagedOrderReturnInfoOutputResolvers<ContextType>;
  SetStagedOrderReturnItemCustomFieldOutput?: SetStagedOrderReturnItemCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderReturnItemCustomTypeOutput?: SetStagedOrderReturnItemCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderReturnPaymentStateOutput?: SetStagedOrderReturnPaymentStateOutputResolvers<ContextType>;
  SetStagedOrderReturnShipmentStateOutput?: SetStagedOrderReturnShipmentStateOutputResolvers<ContextType>;
  SetStagedOrderShippingAddressAndCustomShippingMethodOutput?: SetStagedOrderShippingAddressAndCustomShippingMethodOutputResolvers<ContextType>;
  SetStagedOrderShippingAddressAndShippingMethodOutput?: SetStagedOrderShippingAddressAndShippingMethodOutputResolvers<ContextType>;
  SetStagedOrderShippingAddressCustomFieldOutput?: SetStagedOrderShippingAddressCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderShippingAddressCustomTypeOutput?: SetStagedOrderShippingAddressCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderShippingAddressOutput?: SetStagedOrderShippingAddressOutputResolvers<ContextType>;
  SetStagedOrderShippingCustomFieldOutput?: SetStagedOrderShippingCustomFieldOutputResolvers<ContextType>;
  SetStagedOrderShippingCustomTypeOutput?: SetStagedOrderShippingCustomTypeOutputResolvers<ContextType>;
  SetStagedOrderShippingMethodOutput?: SetStagedOrderShippingMethodOutputResolvers<ContextType>;
  SetStagedOrderShippingMethodTaxAmountOutput?: SetStagedOrderShippingMethodTaxAmountOutputResolvers<ContextType>;
  SetStagedOrderShippingMethodTaxRateOutput?: SetStagedOrderShippingMethodTaxRateOutputResolvers<ContextType>;
  SetStagedOrderShippingRateInputOutput?: SetStagedOrderShippingRateInputOutputResolvers<ContextType>;
  SetStagedOrderStoreOutput?: SetStagedOrderStoreOutputResolvers<ContextType>;
  SetType?: SetTypeResolvers<ContextType>;
  Shipping?: ShippingResolvers<ContextType>;
  ShippingInfo?: ShippingInfoResolvers<ContextType>;
  ShippingMethod?: ShippingMethodResolvers<ContextType>;
  ShippingMethodLimitWithCurrent?: ShippingMethodLimitWithCurrentResolvers<ContextType>;
  ShippingMethodLimitsProjection?: ShippingMethodLimitsProjectionResolvers<ContextType>;
  ShippingMethodQueryResult?: ShippingMethodQueryResultResolvers<ContextType>;
  ShippingMethodsByCartInterface?: ShippingMethodsByCartInterfaceResolvers<ContextType>;
  ShippingRate?: ShippingRateResolvers<ContextType>;
  ShippingRateCartClassificationPriceTier?: ShippingRateCartClassificationPriceTierResolvers<ContextType>;
  ShippingRateCartScorePriceTier?: ShippingRateCartScorePriceTierResolvers<ContextType>;
  ShippingRateCartValuePriceTier?: ShippingRateCartValuePriceTierResolvers<ContextType>;
  ShippingRateInput?: ShippingRateInputResolvers<ContextType>;
  ShippingRateInputDraftOutput?: ShippingRateInputDraftOutputResolvers<ContextType>;
  ShippingRateInputLocalizedEnumValue?: ShippingRateInputLocalizedEnumValueResolvers<ContextType>;
  ShippingRateInputType?: ShippingRateInputTypeResolvers<ContextType>;
  ShippingRatePriceTier?: ShippingRatePriceTierResolvers<ContextType>;
  ShippingTarget?: ShippingTargetResolvers<ContextType>;
  ShoppingList?: ShoppingListResolvers<ContextType>;
  ShoppingListLimitWithCurrent?: ShoppingListLimitWithCurrentResolvers<ContextType>;
  ShoppingListLimitsProjection?: ShoppingListLimitsProjectionResolvers<ContextType>;
  ShoppingListLineItem?: ShoppingListLineItemResolvers<ContextType>;
  ShoppingListQueryInterface?: ShoppingListQueryInterfaceResolvers<ContextType>;
  ShoppingListQueryResult?: ShoppingListQueryResultResolvers<ContextType>;
  ShoppingListsConfiguration?: ShoppingListsConfigurationResolvers<ContextType>;
  StagedOrderUpdateActionOutput?: StagedOrderUpdateActionOutputResolvers<ContextType>;
  StagedQuote?: StagedQuoteResolvers<ContextType>;
  StagedQuoteQueryResult?: StagedQuoteQueryResultResolvers<ContextType>;
  StagedStandalonePrice?: StagedStandalonePriceResolvers<ContextType>;
  StandalonePrice?: StandalonePriceResolvers<ContextType>;
  StandalonePriceActiveChanged?: StandalonePriceActiveChangedResolvers<ContextType>;
  StandalonePriceCreated?: StandalonePriceCreatedResolvers<ContextType>;
  StandalonePriceDeleted?: StandalonePriceDeletedResolvers<ContextType>;
  StandalonePriceDiscountSet?: StandalonePriceDiscountSetResolvers<ContextType>;
  StandalonePriceExpiresAtSet?: StandalonePriceExpiresAtSetResolvers<ContextType>;
  StandalonePriceExternalDiscountSet?: StandalonePriceExternalDiscountSetResolvers<ContextType>;
  StandalonePriceKeySet?: StandalonePriceKeySetResolvers<ContextType>;
  StandalonePriceQueryResult?: StandalonePriceQueryResultResolvers<ContextType>;
  StandalonePriceStagedChangesApplied?: StandalonePriceStagedChangesAppliedResolvers<ContextType>;
  StandalonePriceStagedChangesRemoved?: StandalonePriceStagedChangesRemovedResolvers<ContextType>;
  StandalonePriceTierAdded?: StandalonePriceTierAddedResolvers<ContextType>;
  StandalonePriceTierRemoved?: StandalonePriceTierRemovedResolvers<ContextType>;
  StandalonePriceTiersSet?: StandalonePriceTiersSetResolvers<ContextType>;
  StandalonePriceValidFromAndUntilSet?: StandalonePriceValidFromAndUntilSetResolvers<ContextType>;
  StandalonePriceValidFromSet?: StandalonePriceValidFromSetResolvers<ContextType>;
  StandalonePriceValidUntilSet?: StandalonePriceValidUntilSetResolvers<ContextType>;
  StandalonePriceValueChanged?: StandalonePriceValueChangedResolvers<ContextType>;
  State?: StateResolvers<ContextType>;
  StateQueryResult?: StateQueryResultResolvers<ContextType>;
  Store?: StoreResolvers<ContextType>;
  StoreCountriesChanged?: StoreCountriesChangedResolvers<ContextType>;
  StoreCountry?: StoreCountryResolvers<ContextType>;
  StoreCreated?: StoreCreatedResolvers<ContextType>;
  StoreDeleted?: StoreDeletedResolvers<ContextType>;
  StoreDistributionChannelsChanged?: StoreDistributionChannelsChangedResolvers<ContextType>;
  StoreLanguagesChanged?: StoreLanguagesChangedResolvers<ContextType>;
  StoreLimitWithCurrent?: StoreLimitWithCurrentResolvers<ContextType>;
  StoreLimitsProjection?: StoreLimitsProjectionResolvers<ContextType>;
  StoreNameSet?: StoreNameSetResolvers<ContextType>;
  StoreProductSelectionsChanged?: StoreProductSelectionsChangedResolvers<ContextType>;
  StoreQueryResult?: StoreQueryResultResolvers<ContextType>;
  StoreSupplyChannelsChanged?: StoreSupplyChannelsChangedResolvers<ContextType>;
  StringAttribute?: StringAttributeResolvers<ContextType>;
  StringField?: StringFieldResolvers<ContextType>;
  StringType?: StringTypeResolvers<ContextType>;
  SubRate?: SubRateResolvers<ContextType>;
  SubscriptionsLimitsProjection?: SubscriptionsLimitsProjectionResolvers<ContextType>;
  SuggestResult?: SuggestResultResolvers<ContextType>;
  SuggestResultEntry?: SuggestResultEntryResolvers<ContextType>;
  SuggestTokenizer?: SuggestTokenizerResolvers<ContextType>;
  SuggestTokenizerProductSearch?: SuggestTokenizerProductSearchResolvers<ContextType>;
  Suggestion?: SuggestionResolvers<ContextType>;
  SyncInfo?: SyncInfoResolvers<ContextType>;
  TaxCategory?: TaxCategoryResolvers<ContextType>;
  TaxCategoryLimitWithCurrent?: TaxCategoryLimitWithCurrentResolvers<ContextType>;
  TaxCategoryLimitsProjection?: TaxCategoryLimitsProjectionResolvers<ContextType>;
  TaxCategoryQueryResult?: TaxCategoryQueryResultResolvers<ContextType>;
  TaxPortion?: TaxPortionResolvers<ContextType>;
  TaxRate?: TaxRateResolvers<ContextType>;
  TaxedItemPrice?: TaxedItemPriceResolvers<ContextType>;
  TaxedPrice?: TaxedPriceResolvers<ContextType>;
  TermCount?: TermCountResolvers<ContextType>;
  TermsFacetResult?: TermsFacetResultResolvers<ContextType>;
  TextAttributeDefinitionType?: TextAttributeDefinitionTypeResolvers<ContextType>;
  TextLineItem?: TextLineItemResolvers<ContextType>;
  Time?: GraphQLScalarType;
  TimeAttribute?: TimeAttributeResolvers<ContextType>;
  TimeAttributeDefinitionType?: TimeAttributeDefinitionTypeResolvers<ContextType>;
  TimeField?: TimeFieldResolvers<ContextType>;
  TimeType?: TimeTypeResolvers<ContextType>;
  TrackingData?: TrackingDataResolvers<ContextType>;
  Transaction?: TransactionResolvers<ContextType>;
  TransitionStagedOrderCustomLineItemStateOutput?: TransitionStagedOrderCustomLineItemStateOutputResolvers<ContextType>;
  TransitionStagedOrderLineItemStateOutput?: TransitionStagedOrderLineItemStateOutputResolvers<ContextType>;
  TransitionStagedOrderStateOutput?: TransitionStagedOrderStateOutputResolvers<ContextType>;
  Trigger?: TriggerResolvers<ContextType>;
  TypeDefinition?: TypeDefinitionResolvers<ContextType>;
  TypeDefinitionQueryResult?: TypeDefinitionQueryResultResolvers<ContextType>;
  UpdateStagedOrderItemShippingAddressOutput?: UpdateStagedOrderItemShippingAddressOutputResolvers<ContextType>;
  UpdateStagedOrderSyncInfoOutput?: UpdateStagedOrderSyncInfoOutputResolvers<ContextType>;
  UserProvidedIdentifiers?: UserProvidedIdentifiersResolvers<ContextType>;
  ValueFacetResult?: ValueFacetResultResolvers<ContextType>;
  Versioned?: VersionedResolvers<ContextType>;
  WhitespaceSuggestTokenizer?: WhitespaceSuggestTokenizerResolvers<ContextType>;
  WhitespaceSuggestTokenizerProductSearch?: WhitespaceSuggestTokenizerProductSearchResolvers<ContextType>;
  YearMonth?: GraphQLScalarType;
  Zone?: ZoneResolvers<ContextType>;
  ZoneLimitWithCurrent?: ZoneLimitWithCurrentResolvers<ContextType>;
  ZoneLimitsProjection?: ZoneLimitsProjectionResolvers<ContextType>;
  ZoneQueryResult?: ZoneQueryResultResolvers<ContextType>;
  ZoneRate?: ZoneRateResolvers<ContextType>;
};

